<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++静态检查工具总结]]></title>
    <url>%2F2018%2F11%2F24%2Fstatic-analizer%2F</url>
    <content type="text"><![CDATA[最近在尝试做代码审查，发现很多时候我们把时间花在了低级的规范性错误上面，为了节省这一部分的时间，我尝试了各种静态检查工具，这里做个简单的汇总，方便日后的查看。 clang-format严格来说，它不是静态检查工具，而是代码格式化的工具，类似的工具还有astyle，但是相对来说，clang-format会好用一些，支持的配置参数也多一些。它的使用请参考Clang-Format Style Options。 使用统一的代码格式化工具，可以极大的代码格式上面的问题，在多人合作的项目中显得特别的有用。 cpplintcpplint是Google提供的工具，用于检查我们的代码是否符合Google C++ Style Guide，我们目前的编码规范是基于Google的规范，所以这个工具基本上可以直接使用。 安装这个工具是Python写的，所以你可以直接通过pip来安装这个工具的最新版本 1pip3 install cpplint 使用这个工具的使用比较简单，直接使用命令： 1cpplint &lt;文件名&gt; 比如我们有源文件hello.cpp如下： 12345678#include &lt;iostream&gt;int main(int argc, char *argv[])&#123; std::string message = "Hello World"; std::cout &lt;&lt; message &lt;&lt; std::endl; return 0;&#125; 使用cpplint hello.cpp我们会得到如下消息： hello.cpp:0: No copyright message found. You should have a line: “Copyright [year] “ [legal/copyright] [5] hello.cpp:4: { should almost always be at the end of the previous line [whitespace/braces] [4] Done processing hello.cpp Total errors found: 2 过滤掉我们不要求的项如果你并不是严格的直接Google C++ Style Guide，cpplint可能会报一些你不想要的错误，这个时候，我们可以通过filter参数过滤掉这些错误，比如假如你们不执行关于copyright的规定，你可以加上如下filter。 1cpplint --filter=-legal/copyright hello.cpp legal/copyright这个字段可以在错误列表中找到，注意前面的-号，表示不做这个检查，相反的+表示做这个检查。 另外一种方式是在你想要忽略的代码后面加上// NOLINT 123int main(int argc, char* argv[])&#123; // NOLINT&#125; 集成到 VIM 中每次都需要执行这个命令会显得非常的繁琐，把这个过程自动化的一个方式是集成到你的开发环境中去，在编辑的时候自动执行这条命令。比如我给我的VIM安装了ale插件，同时配置cpplint为检查工具。具体的配置方法，请查看ale的官方文档。 在代码 commit 之前自动检查当然如果你的开发环境不支持这种集成，你可以把这个过程放到git的pre-commit或者pre-push之前，下面是来自brickgao的一段gist 12345678910111213141516171819202122232425262728293031323334353637#!/bin/sh## Modified from http://qiita.com/janus_wel/items/cfc6914d6b7b8bf185b6## An example hook script to verify what is about to be committed.# Called by "git commit" with no arguments. The hook should# exit with non-zero status after issuing an appropriate message if# it wants to stop the commit.## To enable this hook, rename this file to "pre-commit".if git rev-parse --verify HEAD &gt;/dev/null 2&gt;&amp;1then against=HEADelse # Initial commit: diff against an empty tree object against=4b825dc642cb6eb9a060e54bf8d69288fbee4904fi# Redirect output to stderr.exec 1&gt;&amp;2cpplint=cpplintsum=0filters='-build/include_order,-build/namespaces,-legal/copyright,-runtime/references'# for cppfor file in $(git diff-index --name-status $against -- | grep -E '\.[ch](pp)?$' | awk '&#123;print $2&#125;'); do $cpplint --filter=$filters $file sum=$(expr $&#123;sum&#125; + $?)doneif [ $&#123;sum&#125; -eq 0 ]; then exit 0else exit 1fi cppcheckcppcheck是一个历史比较悠久的静态检查工具，它的侧重点在于检查代码的逻辑而不是代码的风格。它可以和cpplint一起使用，相互补充。 安装绝大部分的系统，可以直接通过包管理器安装cppcheck，以Ubuntu为例： 1sudo apt install cppcheck 使用cppcheck比cpplint方便一些的地方在于，它支持目录检查，而cpplint只支持文件检查。 1cppcheck src 表示检查src路径下面的所有文件 配置和cpplint一样，这个工具支持过滤，你可以通过--enable=all打开所有的过滤器 1cppcheck --enable=all src 具体支持的filter，可以通过cppcheck --help中的--enable选项说明来查看，这不再赘述。 不足这个工具最大的问题在于比较容易误判，所以我通常很少会直接使用--enable=all，而是直接使用默认的配置。 clang-check、clang static analyzer、clang-tidy把这三个工具放一块儿讲是因为它们实际上都是clang衍生出来的工具，极其类似互有交叉，大部分情况下我们使用其中之一就够了（我实际上不清楚为什么会有三个这样的工具同时存在）。 这几个工具实际上是编译器级别的检查，它们需要编译文件从而检查代码，所以理论上他们的可靠性会比cpplint和cppcheck要强一些，同时它的耗时也会它们长一些。 目前我使用的是clang-tidy，它和clang-check非常类似，但是它支持扩展自定义的检查。另外官方提供run-clang-tidy脚本用于实现对整个项目的文件做检查，用起来非常的方便。 安装在Ubuntu中使用如下命令可以安装clang-tidy 1sudo apt install clang-tidy 使用clang-tidy的使用，比前面提到的工具要复杂一些，因为它需要编译源码，所以需要知道怎么编译源文件。我们可以通过CMake来生成这个编译命名文件： 1cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ... DCMAKE_EXPORT_COMPILE_COMMANDS这个选项会生成一个叫compile_commands.json的文件，有了这个文件，我们可以直接在编译目录下执行run-clang-tidy命令，对整个项目做静态的检查。 配置clang-tidy支持的检查项特别多，你可以通过： 1clang-tidy -list-checks -checks=* 来查看所有支持的检查，使用： 1clang-tidy -list-checks 来查看所有已经enable的检查，具体的文档请参考clang-tidy 注意：如果你使用的是zsh，上面的通配符会失效，你可以切换到bash执行这些命令，或者使用setopt no_nomatch来关闭zsh对于通配符的拦截]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读代码]]></title>
    <url>%2F2018%2F10%2F21%2Fhow-to-read-code-md%2F</url>
    <content type="text"><![CDATA[写这篇文章之前，我脑海中实际上想总结的内容是如何快速的定位到一个别人项目中的BUG。就个人经验来说：找自己代码中的BUG，要比找别人代码中的BUG简单；找目前在维护的代码的BUG，比找半年以前写的代码的BUG容易。这些现象的背后揭示的道理是，一段代码，你理解的越是透彻，你能找出其中的问题的概率越大。所以在谈怎么样快速定位到一个BUG之前，想先聊聊怎么样去读懂别人写的代码。 据说绝大部分的程序员宁可自己重写，也不愿意去维护别人写的代码。这其中有部分原因是有很大一部分程序员都觉得自己的水平比别人高（虽然很多人不好意思承认这一点），另外一部分原因在于，有时候要读懂别人的代码很难，花费的代价比自己重写一遍还大。那么，到底是什么东西在阻碍我们读懂一段代码，我们又该如何去客服这些困难呢？ 你读不懂他的代码这种情况其实很少出现，我们通常不会需要跨语言去找BUG（全栈除外），但是同一门语言的不同版本还是有可能会碰到的，比如下面这两段C++代码，可能会有部分C++程序员看不懂： 1auto [itelem, success] = mymap.insert(std::pair(’a’, 100)); 12345int foo(a) int a;&#123; return 0;&#125; 其中第一段是C++17中定义变量的语法，而第二段是C语言K&amp;R版本定义函数的语法。维护别人的程序很多时候碰到的情况是第二种，你可能遇到一些过时的写法。 TIPS：持续学习无论学什么语言都需要不断的学习，因为我们用到的绝大部分语言都还在在不断的演化中。 你理解不了他的代码绝大部分人，如果说自己的读不懂一段代码，实际上都是在说，这段代码他无法理解。很多时候我们清楚的知道每一条语句在说什么，但是就是理解不了整段代码的作用（这种感觉就像读一段英文，每个单词你都懂，但是你不知道整句话在说什么）。比如下面这个摘自我最近一个项目中的函数： 123456void SystemInfoGetUUID(const char* id, ResultHandler handle_result, const char* /* params */) &#123; const ResultType&amp; result__ = SystemInfoGetUUID__(); auto result = StandardizeResult(result__, id); handle_result(id, result.data());&#125; 你可能看懂了每一条语句（毕竟没几行），但是不一定明白这段代码的真正含义是什么，因为你不了解这段代码的作用是什么？ 代码，大到整个项目，小到一个函数，广义上你都有可以理解为是算法——解决问题的步骤，所以理解一段代码你首先要清楚他要解决的问题是什么，如果我告诉大家，上面这个函数之所以这么写是因为我们需要把所有的返回值统一成一个标准格式的JSON串返回给调用方，理解上面这个函数大概会简单得多。 找出一段代码的作用有很多种方式： 问作者，如果代码的原作者就在你的身边，不要犹豫，直接问。 看文档，大部分成熟的项目都会有完善的文档，而大部分文档说的就是代码在做什么。 增加上下文，如果项目没有文档，或者文档中没写你想读懂的那一部分代码的作用，你可以尝试把这段代码放到更广阔的上下文中去理解。大部分程序或者说函数都有输入输出，也就是这里说的上下文，找到它的上下文，通常对于理解它的作用会有很大的帮助。 忽略细节，成大事不拘小节，读大的项目代码也是一样的。如果你知道一个函数的功能，有时候你可以直接忽略掉它的实现。 TIPS: 找上下文（输入、输出）关于找一段程序的上下文，我了解到方法主要有下面这些： 看单元测试找这个函数的单元测试，非常有效的一种方式，因为测试用例中通常给出了各种输入并检查对应的输出。可惜这种方法适用范围不广，因为它的前提是这个函数或者模块有测试用例。 代码跳转工具使用代码跳转工具，查找调用这个函数的地方在哪里。这种方式通常情况下会有多个匹配点，一方面会增加你阅读的困难，另一方面却可以给你更多的参考例子。 有些工具可以生成函数调用关系图（比如C++中的doxygen+graphviz），从图中找上下文有时比在代码中直接找要简单很多。 从main函数开始读这是迫不得已的情况下的大招，因为程序的入口通常是mian函数，所以你想查找的函数，总会有某一条来自main函数的执行路径（如果你写的是库，通常main函数在测试代码中）。 上面两个方式实际上是一种倒推的思路，而这个方法实际上的逻辑是正向的暴力穷举，它可能会耗费很长的时间，但在项目比较小或者时间比较充足的情况下很有用，它实际上相当于模拟计算机的执行过程。这个步骤可以考虑借助调试器，单步跟踪，一步一步的往下读，让调试器去帮你记住代码的上下文。 你理解不了他为什么这样写他的代码每个程序员会有自己习惯的编码风格，就是每个人写出来的字都有自己的影子一样。不理解他为什么这么写，其实对于代码的维护并不会带来太大的问题，所以遇到这种情况，最好克制自己修改它的冲动，除非其中确实有BUG。 除此之外，我们能做的另外一件事情就是去学习或者建立你们团队的编码规范，因为它的存在会大大的减少你读不懂别人为什么这样写的可能性。 参考： 【1】：https://www.quora.com/How-do-I-learn-to-read-code 【2】：https://selftaughtcoders.com/how-to-quickly-and-effectively-read-other-peoples-code/]]></content>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读左传——郑]]></title>
    <url>%2F2018%2F09%2F23%2Fzuozhuan-zhen%2F</url>
    <content type="text"><![CDATA[郑庄公说起春秋的霸业，通常人们会说齐桓晋文，因为他们两个是春秋时期最显赫的霸主。实际上 在齐桓公称霸之前，郑庄公也曾经小霸诸侯。 郑庄公，名寤生，现在很难判断寤生这个词的含义，但是可以肯定的是他的出生让他母亲 武姜很不舒服，所以他母亲喜欢他弟弟共叔段不喜欢他。左传里面的第一个长篇故事《郑伯 克段于鄢》，说的是郑庄公如何打败他弟弟的故事。共叔段在他母亲的帮助，一步一步的走 向夺权篡位之路，庄公一开始就知道，但是没有采取任何行动，直到共叔段真的要篡位的时 候，一举把他干掉。有人说庄公非常的腹黑，把弟弟养肥了杀掉，不断纵容他作恶，直到他 走上谋反之路。也有人从这段故事中读到了一个不断想要在母亲面前证明自己的不被宠爱的 孩子的满腔委屈。庄公大概极度愤慨，才会在干掉共叔段之后对母亲说出：不及黄泉无相 见这样的狠话。但是他终究还是爱自己母亲的，所以话刚说完就后悔了，最终引出了颍考 叔那个掘地及泉隧而相见的妙计。 郑庄公和他父亲郑武公都是周王的卿士，平王东迁，靠的是晋国和郑国的力量，庄公能够小 霸一定意义上来说靠的就是这种优势。可惜这张王牌他没有打好，他做的事情有点挟天子以 令诸侯，比如他以王师虢师伐卫，又以虢师伐宋，很明显用公家资源办私事儿。周天子不爽 他（可能和上面这种行为有关），所以想把政权给虢公，庄公为了这件事情和周天子交换了 人质。但最后周天子还是把政权分给了虢公，郑庄公就派人把天子的麦子割了。君子说 信 不由衷，质无益也，明恕行之，要之以理，虽无有质，谁能间之。周郑的关系不断恶化， 最后两国交战，郑祝聃射王中肩。 郑庄公能够崛起，很大程度上靠的是他强大的武力，他不断的和宋、卫、陈、蔡、周、戎交 战，武力上基本上可以碾压这些国家。郑国在战术上可以说是先驱，左传记载了他们和戎人 、周人交战时使用的战术，都非常的精妙。 晚年的庄公似乎比年轻的时候温和很多，他不在单打独斗，和齐国、鲁国结成了同盟。伐许 而入却没有占领他们的土地，感叹周室衰微，有种英雄落幕的感觉。 庄公最大的失败估计在于他对后世没有很好的安排，他的儿子其实都很能干，太子忽其实算 一个比较厉害的角色，可惜遇到子突这么能干的弟弟。庄公死后郑国内乱，从此也就迅速的 衰落下去了。]]></content>
      <tags>
        <tag>历史</tag>
        <tag>左传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux开发者的Windows生存指南]]></title>
    <url>%2F2018%2F09%2F15%2Fwindows-powershell-tips%2F</url>
    <content type="text"><![CDATA[平常习惯了linux的zsh+tmux+vim组合，开发体验非常完美，最近应该工作需求不得不 在 Windows上做大量的开发，简直就是煎熬。花了一点时间折腾，最终用 nvim+powershell 的方式勉强支撑起Windows下的开发。这篇文章总结了我尝试过的各 种方式，谈谈我对这几种方式的优缺点的看法。 visual studio + vim 插件个人的构建工具，很久以前就从automake切到了cmake，所以切到Windows系统下做开发 ，第一种尝试就是直接用cmake生成sln项目，然后用visual studio做编译和调试。我 最终弃用它作为首选方式的原因主要有下面两个： 割裂这种方式给人一种强烈割裂感：我需要在cmd种去执行cmake生成项目，然后 切换到 visual studio上做编辑。visual studio 2017实际上集成了cmake支持，但 是还是会有需要从cmake模式切换到解决方案模式的情况（比如设置一些调试参数之类的 ），依旧没有办法找到一种很舒适的集成环境。 文件编码visual studio是一个很奇怪的IDE，无比臃肿，但却没有提供设置文件默认编码格式的功 能（至少没有较简单的方式），这对于跨平台的开发来说简直就是噩梦，我不得不手动的把 每一个源文件转换成统一的UTF8格式，防止在Linux平台打开的时候出现乱码（写个脚本也 许可以稍微减轻这种痛苦）。 WSLWSL刚出来那会儿，个人还是有点小激动，有些人甚至开始调侃说Windows会成为最好的 Linux发行版本。我尝试着用了一段时间，最后还是弃了，原因主要有下面几个： IO太慢这点在操作GIT的时候尤其明显，经常卡到飞起。 终端太难用WSL默认的终端太丑，连主题配置都不支持。我试过很多其他的终端，包括wsl-terminal ，hyper，对于主题和字体的支持都不尽如人意。算起来hyper其实是一个不错的选择， 只是没有办法很好的支持nerd fonts。 系统上下文的切换很繁琐WSL像是一个内置到windows中的小虚拟机，所以这种方式和使用虚拟机一样，需要在两个 系统中不停的切换。进程的上下文切换有开销，系统切换同样也有。 比如，WSL中有python、cmake、git，原生系统中也有python、cmake、git。但是两套 工具在行为上并没有办法完全做到一致。 最明显的例子就是cmake，它在Linux上是接受 cmake_build_type这个参数的，但是 在windows上会直接忽略掉，因为Linux上，会为 release和debug生成不同的 makefile，而visual studio只生成同一个sln并在构建的时候动态指定 release和 debug。我没有办法完全在WSL中工作，所以需要不断在两种系统上下文中切换。这种感 觉这就像是你为同一个功能写了两份代码，你不得不维护两份。为了避免这种不一致性，你 最好只装一套原生的工具集，如果你不得不安装两套，那就只能自求多福了（比如wsl，自 动Python，而你用到了一些只有在原生系统中才能用的Python脚本） 还有一个比较尴尬的地方就是两者对于HOME目录的定义不同，我要在原生系统中找到 WSL中的文件夹很难，这进一步加重了切换系统的成本。 nvim + powershell这种方式是我目前比较习惯的一种方式，nvim基本兼容vim，而且内置了对于terminal的支 持，当然nvim默认的终端是cmd，你可以把它改成Powershell。 我之所以使用这种方式主要是应为下面这几个原因： 快天下武功唯快不破，nvim的轻巧可以碾压visual studio好几条街，编辑的体验也比 visual studio好太多。 美我得承认我是一个颜控，我没有办法忍受难看的字体，更受不了无法配置主题的终端。 nvim+powershell这种方式，可以支持nerd fonts，可以支持主题的配置，powershell 的主题和字体设置默认随nvim的相关设置，集成度非常的高。 原滋原味这种方式不需要使用WSL，没有切换系统的烦恼，也不存在两套工具之间的差异的苦恼。 模拟Linux的开发体验Linux给开发带来的感觉如丝般顺滑，而nvim+powershell的组合可以尽可能的模拟这种体 验。这主要归功于powershell的插件支持，下面是我用到的一些插件。 psreadline这个插件可以给你linux的终端命令输入体验，你可以通过ctrl-w删除一个单词，可以用 ctrl-a跳到行首，这些操作的便捷性远远高于原生的输入方式。psreadline甚至支持 vi-mode，简直完美。 psfzffzf，我通常只用于查找历史命令，但是这对于一个终端控来说，就这一个功能带来的效率 提升就已经无与伦比了 posh-git让 git 的命令可以自动提示，分支可以自动显示。可惜这个插件有点慢。]]></content>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读左传——鲁]]></title>
    <url>%2F2018%2F09%2F09%2Fzuozhuan-one%2F</url>
    <content type="text"><![CDATA[鲁隐公隐公可以算是一个悲情角色了，他的为人是很正派的，他因为摄政称王春秋不书继位，被弑 而亡春秋不书葬，幸亏有左传的存在，让我们可以看到这背后的辛酸。 隐公的悲剧说到底都是他父亲惠公（这种德行也能谥号称惠，估计有其他过人之处）埋下的 祸根。春秋，国君依礼应该只有一位夫人，惠公夫人孟子（孟是排行老大，子是姓，宋国人 ）无子，卒，继室以声子，生隐公。按理隐公是庶长子，正常情况下，惠公去世，隐公会顺 理成章的成为下一任国君。 天意弄人，宋武公生了一个女儿仲子（仲是排行老二），生而有文在手曰：鲁夫人，所以仲 子也要嫁给鲁国。按照史记的说法，仲子本来要嫁给隐公（他本来是下一任国君，所以他的 夫人就成了下一任鲁夫人），但是惠公看仲子长的漂亮，自己把她娶了做下一任夫人，生下 了嫡子：桓公。于是隐公就这样默默的从第一顺位继承人，变成了第二顺位继承人。 鲁桓公出生不久，惠公就去世了，太子太小，隐公摄政称王但奉弟弟为君。有人认为春秋从 隐公开始（春秋来自鲁国的国史，国史不可能从隐公开始，如果春秋是孔子根据鲁史编的， 他选隐公开始，可能是有他的考虑的）是因为隐公这种行为非常像鲁国的始封君周公旦，立 成王，但是自己摄政称王，安定周朝的天下。 隐公其实算得上是一位贤主，他的统治期间，最主要的政策就是和各国讲和，创造一个稳定 的环境。他的统治期间，国家没被打过，跟着郑庄公去打宋国（宋国自己蠢没办法），还得 了几块地。 但是隐公魄力上终究比周公差了点，最明显的差别是，周公摄政称王得以善终，但是隐公没 有。隐公其实一直没把自己当国君，所以他的生母死了，不以夫人礼下葬，但是桓公生母死 了用的是夫人礼（还特意建了新的庙，夫人本来不单独建庙，夫人死了，牌位安放在国君的 庙中，但是鲁惠公庙中已经有了原配夫人孟子的牌位，所以仲子不能以夫人礼放到惠公的庙 中，只能单独建一个庙，可谓煞费苦心），改葬惠公，他也不当主祭，让桓公当主祭，大夫 死了也不参加小歛。 公子翚，当时的权臣，以小人之心猜测隐公其实想自己为王，自愿为隐公杀了桓公，条件是 要封自己为太宰（当时鲁国没有这种官职）。隐公真心想让位，没答应，让公子翚去把自己 养老的城池修好一点。公子翚怕了，反咬隐公一口，在桓公面前说隐公想篡位（桓公大概也 是猪脑子，真想篡位干嘛不在他还小的时候直接干掉他）。桓公就合谋公子翚把隐公杀了， 让寪氏做了替罪羔羊。 这种事情，其实周公也碰到过，他哥哥管叔以为他想篡位，联合纣王之子武庚造反，周公平 叛之后把他哥哥杀了。这种手腕可能听起来很残忍，但是他能做到罚不避亲，真正让人信服 。隐公之死告诉我们很重的一个道理是，对作恶要绝对的零容忍，公子翚这种不君之人，如 果隐公没有放过他，可能他最后真的可以安安心心的去养老，成就一段佳话。 鲁桓公鲁庄公]]></content>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++包管理器——conan]]></title>
    <url>%2F2018%2F04%2F23%2Fconan-tutorial%2F</url>
    <content type="text"><![CDATA[C++可以说是社区驱动型语言，它不像Java和Go背后有主导的公司在推，它的发展更多靠的是由各路专家组成的标准委员会。所以一直以来，它饱受诟病的一点是较难统一，虽然有统一的标准，但是不同的组织有不同的实现和扩充，不同的构建方式，不同的包管理工具。 近年来，CMake慢慢的成为了C++项目构建方式的事实标准，而这篇文章要介绍的是个人认为很有可能在未来几年成为C++包管理工具事实标准的：conan。 官方文档本文只是一个入门性质的教程，讲解我个人在使用理解conan的时候的心得以及遇到的一些问题。推荐大家在看完本文之后找一个时间完成的阅读一下最权威的官方文档。 包管理器很多语言都有自己的包管理器，比如Python的PyPi，C#的Nuget，Rust的cargo。我们可以看一下下面这个直观的例子——gRPC的使用——来感受一下有包管理工具和没有包管理器的区别： C++ 版本（Ubuntu为例子，Windows 更复杂）Pre-requisites1$ [sudo] apt-get install build-essential autoconf libtool pkg-config Protoc12$ cd grpc/third_party/protobuf$ sudo make install # 'make' should have been run by core grpc Build from Source12345$ git clone -b $(curl -L https://grpc.io/release) https://github.com/grpc/grpc$ cd grpc$ git submodule update --init$ make$ [sudo] make install Android 版本123compile 'io.grpc:grpc-okhttp:1.11.0'compile 'io.grpc:grpc-protobuf-lite:1.11.0'compile 'io.grpc:grpc-stub:1.11.0' 眼神再不好使，大概也能看出，Android版本会比C++版本简单很多，更重要的是Android版本除了拷贝上面这段代码之外其他的基本都是自动化的过程，而C++版本需要你各种手动的输入和折腾才能侥幸得到你想要的结果。 包管理器有最大的好处在于，绝大部分操作都是自动化的，所以它的操作很简单，基本不会出现错误。作为C++的死忠粉，我除了仇视Android的开发者之外没有其他选择。直到有一个天我遇到conan，这个跨平台的C++包版本管理器，我终于可以像下面使用Windows的gRPC： 12[requires]gRPC/1.9.1@inexorgame/stable 嗯，世界真美好。 跨平台的包管理器实际上，conan并不是第一个流行起来的C++包管理器，在VS的生态中，Nuget可以用于管理VS平台的C++包，所以如果你只需要支持Windows平台，你可以直接使用Nuget，因为它和VS的集成度会比较高，在开发上可能便利性可能会超过conan。 conan最大的优势在于它的跨平台，它可以支持： 不同的操作系统（Windows，Linux，macOS，FreeBSD等等） 不同的编译器（gcc，msvc，clang等等） 不同的构建工具（CMake，QMake，MSBuild，Autotools等等） 不同的构建方式（原生编译，交叉编译等等） 如果你需要一个跨平台的解决方案，conan可能是目前唯一的选择 安装有意思的是，作为C++的包版本管理器，conan不是用C++来实现的，它甚至不是使用编译型语言来实现的，它使用的是脚本语言Python【1】。所以安装conan之前，我们需要先安装Python和pip，然后执行下面的命令安装conan包： 1$ pip install conan 使用conan的使用其实分为两个角色：包的使用者和包的创建者，这一节重点介绍包的使用者的操作，下一节介绍包的创建者的操作。 本小节以假设你使用CMake来做自动构建，其他的自动构建工具大同小异，我会在后文中给出参考文档 conanfile.txtconan的使用比较方便，我们只需要一个配置文件conanfile.txt【2】，用于写明我们需要直接依赖的包即可（conan会自动处理依赖的传递）： 12345[requires]zlib/1.2.11@conan/stable[generators]cmake conan install然后执行下面这条命令： 1$ conan install . 上面这条命令中的.表示conanfile.txt的路径，如果你不是在同一个路径下面（比如在编译路径下），你需要指定相对路径或者全路径。通常上面这条命令会自动安装我们想要的包，然后在在执行install命令的路径下生成三个文件： conanbuildinfo.txt conanbuildinfo.cmake conaninfo.txt 其中conaninfo.txt这个文件可以用来判断这个包的详细信息，包括编译器信息，系统架构（x86，x86_64等），通常如果你自动安装出现编译错误时可以考虑查看这个文件来确认一下包的信息和你期望的信息是否一致（比如你想要一个Debug包，但是下载成来Release包）。 conanbuildinfo.cmake这个文件是给CMake用的，让它知道如何引用依赖包，比如头文件的引用路径，库的引用路径，库的链接等信息。相对的conanbuildinfo.txt这个文件可供我们阅读，排查上面这些信息是否有误。不同的generators导致不同的供构建系统使用的文件生成（比如如果指定generators是visual_studio，会生成conanbuildinfo.props），但是统统都会生成供我们阅读的conanbuildinfo.txt。 引用生成自动生成的编译文件我们需要额外的设置，把这个生成的文件集成到我们自己的编译系统中去，比如如果我们使用的是CMake，我们需要修改我们顶层的的CMakefile.txt，加入下面这两句（第一句的include怎么写，依赖于我们在哪个路径下执行conan install命令）： 12include($&#123;CMAKE_BINARY_DIR&#125;/conanbuildinfo.cmake)conan_basic_setup() 然后让我们的target链接我们的依赖库， 1target_link_libraries(target $&#123;CONAN_LIBS&#125;) 上面这个过程通常只需要执行一次，所以其实工作量比我们想象中的要小一些。 使用动态库大部分的包既提供动态库版本又提供动态库版本，大部分包默认情况下自动安装static版本的包，如果你需要使用shared版本的包，通常可以在配置文件中加入shared这个option（注意，并不是所有的包都会提供这个选项）： 12[options]zlib:shared=True 在Windows中，动态库分成两个部分xxx.dll会导出库xxx.lib，dll不用参与链接，但是需要放到可执行目录下，所以使用动态库通常还意味着需要拷贝dll到bin目录下，conan使用import这个配置来自动完成这个操作： 123[imports]bin, *.dll -&gt; ./binlib, *.dylib* -&gt; ./bin 使用 Debug 版本的库默认情况下，conan自动安装Release版本的包，但是使用Debug版本的库对于调试开发其实比较有帮助。和前面不同的是，如果我们想要使用Debug版本包，我们通常不是使用conanfile.txt而是使用命令行参数： 1conan install . -s build_type=Debug 上面的-s表示setting，主要包括build_type，compiler，arch等。设置和选项最大的不同在于，设置是conan内置的，每个包都存在，而option是每个包单独定义的，不同的包可能有不同的option（虽然像shared这样的option基本上都会有，理论上更像是setting，conan最新的版本默认都加上这个选项，个人感觉更像是conan的设计失误的一种弥补范式）。 除了-s参数之外，conan还提供-o参数用于指定选项： 1conan install . -o zlib:shared=True 你甚至可以不提供conanfile.txt文件，直接使用命令行完成包的安装： 1conan install zlib/1.2.11@conan/stable -g cmake -s build_type=Debug -o zlib:shared=True profile其实和option一样，setting既可以用命令行参数指定，也可以通过配置文件指定，只不过setting是写在profile而不是conanfile.txt中。conan安装完之后会有一个默认的profile：$HOME/.conan/profiles/default【3】。如果你想要系统默认都下载Debug包，你可以修改这个文件，把build_type改成Debug。 如果你不想影响全局，又不想频繁的输入命令行参数，你可以在$HOME/.conan/profiles/下新建一个profile，比如myproject，然后使用下面命令安装依赖包： 1conan install . --profile=myproject 这种方式在对于简单的参数来说没有太大的意义，但是对于交叉编译的中特别有用，可以避免大量的参数的输入工作。 其他工具的集成前面的例子以CMake为例，其他工具的集成使用可以参考下面这个官方文档 创建一个包好吧，我得承认，上面一小节其实带着忽悠的成分。因为实际上conan目前的生态并不是特别完善，所以很多时候，你可能找不到你想要的包，很多时候你可能没有办法直接通过install安装你要的包的依赖。 俗话说，求人不如求己，我们完全可以自己的打包，自己用。这一些节主要介绍如何创建一个conan包。 理解conan的包名在实际创建一个包之前，我们先来理解一下conan包的包名。 1zlib/1.2.11@conan/stable 上面这个包名包含四个部分： zlib 名字 1.2.11 版本 conan 用户 stable 通道（channel） 虽然它们出现在同一个名字中，但它们不在同一个位置设置。前面两个通常写在配置文件中，而后面两个在命令行中指定。 包的创建步骤创建一个包，实际上就是编译一个包的过程，只不过conan把这个过程脚本化来而已。所以在创建一个包之前，我们先整理一下编译一个包需要的步骤： 重复下面这三个步骤，直到所有依赖编译完成，后然执行下面三个步骤编译自身 下载源码 编译 安装 所以创建一个conan包大概也就是把这几个步骤自动化而已，自动化这些操作的脚本叫做：conanfile.py，官方称之为recipe。recipe是菜谱的意思，这个词非常好的体现了conanfile.py的功能，引导conan一步一步的创建一个包。 conanfile.py一个 conanfile.py 通常的像下面这个样子： 1234567891011121314151617181920212223242526272829303132from conans import ConanFile, CMake, toolsclass HelloConan(ConanFile): name = "Hello" version = "0.0.1" license = "MIT" url = "https://github.com/hello/hello.git" description = "Hello conan" settings = "os", "compiler", "build_type", "arch" options = &#123;"shared": [True, False]&#125; default_options = "shared=False" generators = "cmake" def source(self): self.run("git clone https://github.com/hello/hello.git") def build(self): cmake = CMake(self) cmake.configure(source_folder="hello") cmake.build() def package(self): self.copy("*.h", dst="include", src="hello") self.copy("*hello.lib", dst="lib", keep_path=False) self.copy("*.dll", dst="bin", keep_path=False) self.copy("*.so", dst="lib", keep_path=False) self.copy("*.dylib", dst="lib", keep_path=False) self.copy("*.a", dst="lib", keep_path=False) def package_info(self): self.cpp_info.libs = ["hello"] 你可以使用下面的命令来创建这个脚本： 1conan new Hello/0.0.1 conanfile.py是一个合法的Python脚本，里面定义了一个继承自：ConanFile的类。这个类包括两个部分：属性和方法，属性用于设置一些只读信息而方法用于自动化打包的逻辑。下面我们分步骤讲解一下Conan的打包过程。 依赖conanfile.py提供了两种方式来声明包的依赖，属性requires和requirements成员函数。通常如果依赖逻辑比较简单，我们可以直接设置属性。 1234class MyLibConan(ConanFile): requires = (("Hello/0.1@user/testing"), ("Say/0.2@dummy/stable", "override"), ("Bye/2.1@coder/beta", "private")) 依赖本身有两种属性，override和private。前者出现在需要覆盖依赖的依赖的时候；而后者用于限定内部依赖，比如动态库中依赖的静态库。 如果依赖的逻辑比较复杂，比如需要根据不同的option和setting来设定，我们可以在requirements()成员函数中声明依赖： 12345def requirements(self): if self.options.myoption: self.requires("zlib/1.2@drl/testing", private=True) else: self.requires("opencv/2.2@drl/stable", override=True) 这个成员函数最终调用的是requires()函数，这个函数同样可以设置private和override属性。 下载源码依赖处理完之后，我们可以正式的编译我们自己的包来，第一步要做的就是获取源码，同样源码获取其实分为两种情况，一种是使用exports_sources属性，一个使用source()成员函数。 使用哪一种方式主要看你的recipe文件（conanfile.py）是否和源码放在一起。假如你是这个包的开发者，通常你可以把你的recipe和你的源码放一起托管到同一个仓库，假如你只是打包人员【4】，通常你的recipe和源码不在同一个仓库。 如果recipe和源码在同一个仓库，通常使用exports_sources，否则使用source()成员函数。 exports_sources这个属性可以用于导出当前仓库下的源码，比如： 1exports_sources = "include*", "src*", "!src/build/*" recipe中的大部分属性如果支持多个都是以这种tuple的形式设置，因为它们是只读的。如上所示，我们可以使用通配符*也可以排除单独的文件!。 source() 方法如果你需要手动下载代码，你可以定义这个成员函数，然后在函数内部编写源码的获取逻辑，最常用的两种方式是：git clone和下载源码包。 12def source(self): self.run("git clone https://github.com/openssl/openssl.git") 12345source_tgz = "https://www.openssl.org/source/openssl-%s.tar.gz" % versiondef source(self): tools.download(self.source_tgz, "openssl.tar.gz") tools.unzip("openssl.tar.gz") conan给我们提供了大量的工具辅助我们编写recipe，这些工具大多集中在tools模块里面，比如我们上面用到的tools.download和tools.unzip 编译这个过程可能是整个过程中最复杂的操作，因为C++没有统一的构建工具（CMake慢慢的在变成事实标准，但是目前还有大量的历史遗留项目不支持CMake）。幸运的是，conan本身提供了很多封装来帮助我们减少这个过程的复杂性。 CMake如果你在编写一个新项目，很有可能你也在使用CMake（如果不是，推荐你试试），如果你使用CMake，那么构建实际上也非常简单，因为conan提供了CMake这个类帮我们简化编译流程： 1234def build(self): cmake = CMake(self) cmake.configure() cmake.build() AutoToolsBuildEnvironment在CMake流行之前，在泛UNIX圈我们通常使用AutoTool来自动构建我们的项目，如果你恰好需要处理这种项目，我们可以使用Conan提供的AutoToolsBuildEnvironment来编译项目。 1234def build(self): env_build = AutoToolsBuildEnvironment(self) env_build.configure() env_build.make() MSBuild如果你的项目需要在Windows下使用，但又没有使用CMake，很有可能你用来VS的MSBuild来做自动构建，同样conan为我们提供了MSBuild类来简化编译逻辑： 123def build(self): msbuild = MSBuild(self) msbuild.build("MyProject.sln") 同时兼容多种编译方式如果你没有办法使用统一的方式处理所有平台的编译，我们可以根据settting或options动态选择： 12345def build(self): if self.settings.os == "Windows": build_with_msbuild(self) else: build_with_cmake(self) 打包编译完成之后，我们需要对编译输出打包，在conan中打包分为两种情况，主要得看我们的自动构建系统是否已经做了打包这个环节。 构建脚本包含打包如果我们使用CMake或者使用AutoTool，我们通常会在编译脚本中指定要安装的文件，这样在执行make install的时候，可以把我们想要的头文件和库文件都安装到指定的目录。如果我们的构建脚本中包含这些操作，那么打包这一步我们可以什么都不做，只需要在编译的时候加上install这个步骤就可以了。 如果你使用CMake你可以调用install()函数： 123def build(self): ... cmake.install() 如果你使用AutoTool，你可以使用make()函数并指定install参数 123def build(self): ... env_build.make(args=['install']) 构建脚本不包含打包如果你的构建脚本中没有包含打包这个过程，你可以通过conan提供的package()成员函数来完成打包，你可以自动拷贝你想要的文件。 123def package(self): self.copy("*.h", dst="include") self.copy("*.so", dst="lib", keep_path=False) conan会自动查找符合条件的文件，并拷贝到最终的输出目录下面。这个操作对于MSBuild的编译比较方便。 配置包信息打包的过程实际上到上面已经结束了，最后这个步骤其实是设置包的信息，以便使用者能够正常的使用，最常见的操作是设置self.cpp_info.libs这个属性，它用来告诉使用者在使用的时候需要链接什么库。 12def package_info(self): self.cpp_info.libs = [&quot;hello&quot;] 上面这段代码表示使用的时候需要在库引用列表中加上hello（具体的设置方式还要看使用者用的是什么编译器）。 创建本地的conan包有了上面脚本，我们可以使用下面的命令来创建一个conan包： 1conan create . guorongfei/testing 它会把recipe和相关的文件拷贝到本地的缓存中，然后根据recipe创建一个包。本地缓存通常放在$HOME/.conan/data目录下，我们可以直接在这个目录下面找到我们刚刚创建的包，通常这个包里面会包含下面几个目录， export export_source source build package 其中 export 里面存放了我们的recipe，剩下的几个目录的功能我们在前面conanfile.py的讲解中有讲解，这里不赘述。package中存放了我们最终打包出来的文件，如果你想知道自己打的包对不对，可以检查一下这个目录。 conan 打包的内部过程conan打包的内部过程可以用下面这张表来描述： conan create 把文件拷贝到本地缓存中，之后把文件拷贝到source目录下，执行source()函数下载代码，然后把文件拷贝到build目录下（没一种配置都会有一个相应的build目录），执行build()函数，最后执行package()函数把最终的输出拷贝的对应的package目录。 如果我们的编译脚本中包含了install这个步骤，所有的文件会被install到package目录下，所以可以不用编写package()再做拷贝。 只打包不编译上面提到，不同的成员函数对应打包的不同的步骤，如果我们没有办法获取源码，只能获取到二进制文件，但是又不想自己去设置库的路径，conan给我们提供来一种方式：只打包不编译。 因为我们不需要编译，所以recipe中绝大部分的函数我们都可以不重载，通常我们只需要重载packet()和packet_info()方法。假如我们已经下载好了所有需要的文件，我们可以这样写： 12345678910111213141516171819from conans import ConanFile, CMake, toolsclass HelloConan(ConanFile): name = "Hello" version = "0.0.1" license = "MIT" url = "https://github.com/hello/hello.git" description = "Hello conan" settings = "os", "compiler", "build_type", "arch" options = &#123;"shared": [True, False]&#125; default_options = "shared=False" generators = "cmake" def package(self): self.copy("*") def package_info(self): self.cpp_info.libs = ["hello"] 当然我们也可以重载build()函数从构建服务器上自动下载已经编译好的二进制包进行打包。如果我们只打包不编译，我们可以使用export-pkg命令创建包： 1conan export-pkg . Hello/0.0.1@conan/testing 把本地的conan包上传到远程的仓库上面这些步骤让我们在本地创建了一个conan包，但是独乐乐不如众乐乐，我们最后一个步骤通常是把包上传到远程仓库。这里涉及到三个步骤： 1. 添加远程仓库1conan remote add remote_name remote_url 2. 获取上传权限下面这条命令可以用于获取远程仓库的权限，通常下载不需要权限，但是上传需要。 1conan user 3. 上传包因为我们可能创建了多个包（不同到setting，不同到options），我们可以加上 --all 表示上传所有到包。 1conan upload Hello/0.0.1@conan/testing --all conan是一个去中心化的包版本管理工具，模型和git十分相识。 美中不足我非常希望conan是一个完美的包版本管理器，但是它毕竟不是，我个人使用过程中最大的麻烦是他们对于Android的交叉编译支持其实不是特别友好。 交叉编译交叉编译是指在一个架构中编译另一个架构的包，比如在Linux上编译Android的包。conan对于交叉编译的支持是通过创建toolchain，并且设置CXX、CC、SYSTEM_ROOT等环境变量来实现的，这种方式在AutoTool流行的年代比较流行，目前很多嵌入式开发依旧使用这中方式。具体的使用方式参考官方给的例子： Cross building Boost C++ libraries to Android with Conan 但是Android的NDK，现在也支持使用toolchain这种方式，但是这种方式在后续会被慢慢的移除掉。NDK目前的交叉编译使用的是CMake的toolchain.cmake这种方式，直接使用CMake系统来完成交叉编译，它不需要单独制作toolchian，使用起来其实方便很多。但是目前conan并不支持这种方式。 使用技巧使用了一段时间的conan之后，积累了一些相关的经验补充在这里： 使用alias创建别名包，避免频繁的更新依赖我们在创建和使用一个conan包的时候都需要指定这个conan包的版本 12345# 创建conan create . HelloConan/0.1.0@conan/teting# 使用conan install HelloConan/0.1.0@conan/teting 这给使用上带来的问题是，如果我更新了一个包，但是并没有改变他的接口，使用者依旧 需要更新自己的依赖：比如更新conanfile.txt。使用者很多时候只要前后版本可以兼容 ，使用者通常自是想要使用最新版本就可以了。 conan提供了alias来实现最新版本这个概念，比如如果我们刚刚创建了0.1系列最新的包HelloConan/0.1.5@conan/teting这个包，我们可以使用下面的命令把最新版本设置为这个包： 1conan alias HelloConan/0.1@conan/testing HelloConan/0.1.5@conan/testing 手动创建包，避免每次更新都重新编译整包conan create这条命令的背后实际上执行了整个打包流程【5】，这条命令很方便，但是 会导致所有的包都重新编译一遍，而很多时候其实我们只是做了非常小的一个改动而已。 为了充分的利用编译缓存，我们可以手动的执行打包流程，也就是手动执行conan create背后的指令： 123conan install . --install-folder=./buildconan build . --source-folder=./ --build-folder=./buildconan export-pkg . HelloConan/0.1.0@conan/testing --package-folder=./build/package conan create实际上依次执行了conan source，conan install，conan build，conan package，conan export-pkg这几条命名。它之所以慢是因为每次都需要重新执行这些命令，如果我们手动创建包，我们可以有下面这些改进： 不执行source，因为源码就在我们手上，可能就是当前这个目录 选择性执行conan install，依赖项实际上我们可以只安装一次，后续的编译不需要重复执行 指定同一个编译目录，这个是最见效的方式，我们可以把编译目录手动设置为固定的目录，这样可以充分的利用编译缓存来极大是缩短编译时间。 不执行conan package，因为conan export-pkg会执行package()函数，也就是conan package命令做的事情。 需要注意的是，export-pkg包含两种不同的执行模式，如果我们在build这个步骤中使用了cmake.install()创建了包，我们只需要指定package-folder就可以了（这种情况通常我们不写package函数），否则我们需要指定source-folder和build-folder，以便执行package函数打包。 【1】：为什么使用脚本语言来实现编译语言的包版本管理器可以参考官方的解释：Why a C++ package manager can’t be written in C++ 【2】：这个文件的格式比较像toml，但我没有找到官方的说法。 【3】：Windows 中的 HOME 目录通常是用户目录的根目录。 【4】：比如目前网络上存在大量的开源C/C++项目没有conan包，我们可以为这些包编写打包脚本 【5】：https://docs.conan.io/en/latest/developing_packages/package_dev_flow.html]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++轮子——函数式编程]]></title>
    <url>%2F2018%2F04%2F16%2Fcpp-std-functional%2F</url>
    <content type="text"><![CDATA[和算法配套出现的组件除了迭代器之外还有仿函数，这篇文章会重点介绍仿函数的使用以及和它相关的函数式编程工具。 仿函数算法库中有很多算法都有一个重载的版本，接收一个Callable object用于提升算法的灵活性。 1234567template&lt; class InputIt, class UnaryPredicate &gt;InputIt find_if( InputIt first, InputIt last, UnaryPredicate p );template&lt; class InputIt, class T, class BinaryOperation &gt;T accumulate( InputIt first, InputIt last, T init, BinaryOperation op ); 语法上可调用对象（Callable object）是指可以使用函数调用符号操作它的任何对象，它可以表示很多对象，比如普通的函数，也比如一个重载了函数调用符的类型对象。如果可调用对象的返回值是bool则称之为Predicate（有人翻译成谓词）。接收Predicate的算法通常都以_if结尾，比如：std::find_if，std::copy_if。 我们把重载了函数调用符的对象称为仿函数，它在功能上是一个函数，在语法上是一个类。它和普通函数最大的区别是它可以保存内部状态。 假如我们现在要找出第一个奇数，我们可以这样写： 12bool is_odd(int a) &#123; return a % 2; &#125;std::find_if(std::begin(a), std::end(a), is_odd) 假如我们要查找第一个偶数，我们可以写成这样： 12bool is_even(int a) &#123; return !is_odd(a); &#125;std::find_if(std::begin(a), std::end(a), is_even) 但是如果我实现成仿函数，我们可以这样写： 123456789101112131415161718class FindOdd &#123;public: NumberPredicate(bool found_odd) &#123; ... &#125; bool operator()(int a) const &#123; if (found_odd_) &#123; ... &#125; ... &#125;private: bool found_odd_;&#125;;std::find_if(std::begin(a), std::end(a), FindOdd(true));std::find_if(std::begin(a), std::end(a), FindOdd(false)); 上面这个例子其实并不太恰当，我不推荐在一个函数中实现两个功能，但是它展示了仿函数区别于普通函数的重要特性——可以保存状态。 Predicate 应该是纯函数Predicate是指返回值为bool的Callable object，而纯函数是指这个对象不会有side effect，也就是说如果以同样的参数调用这个对象，结果是一样的。之所以这么建议是因为Predicate作为算法的参数而存在，而参数的传递是值拷贝，如果Predicate不是纯函数，而算法内部实现中拷贝的这个Predicate，它会导致Predicate的失效。比如我们先要删除容器中的第三个元素，我们可以写一个仿函数如下： 12345678910class ThirdElement &#123;public: ThirdElement() : called_times_(0) &#123;&#125; bool operator()(int a) &#123; return ++called_times_ == 3; &#125;private: std::size_t called_times_;&#125;; 然后用remove_if算法： 12std::vector&lt;int&gt; ia = &#123;1, 2, 3, 4, 5, 6&#125;;ia.erase(std::remove_if(std::begin(ia), std::end(ia), ThirdElement())); 可惜的是，这段代码可能把第六个元素也给删除掉了，因为remove_if可能实现成这个样子。 123456789template &lt;typename FwdIterator, typename Predicate&gt;FwdIterator remove_if(FwdIterator begin, FwdIterator end, Predicate p) &#123; begin = find_if(begin, end, p); if (begin == end) return begin; FwdIterator next = begin; return remove_copy_if(++next, end. begin, p);&#125; 这里的主要问题是p，这个变量在find_if中拷贝了一份，在remove_copy_if中又拷贝了一份。而这两份是独立的对象，状态不共享，所以删除了两次。 当然，不要天真的认为把called_times_设置为static，共享状态就没事儿了，因为它会导致你第一次调用可行，第二次调用却会失败。 lambda很多时候，我们为算法提供的Callable Object是一个非常简单的函数，比如前面提到的is_odd和is_even。单独处于这个目的创建一个函数或者仿函数其实比较繁琐。C++11中加入的lambda可以很好的解决这个问题。查找奇数，我们可以这样写： 123std::find_if(std::begin(ia), std::end(ia), [](int a) &#123; return a % 2;&#125;); 对于短小的函数，这种写法会更简单，也更优雅。 闭包和绝大部分语言中的lambda一样，它可以用来创建闭包。所谓闭包是指一个函数以及相关的引用环境组合而成的实体。比如在Python里面一个闭包可以这样写： 12345678def print_zen_of_python(): msg = "zen of python" def printer(): print(msg) return printerclosure = print_zen_of_python()closure() 这里面print_zen_of_python内部的printer函数以及引用环境msg组成来一个闭包。这个概念在C++中也是一样的，不同的是，C++不存在垃圾的自动回收，所以环境的捕获需要自己手动完成。捕获方式是把要捕获的变量放在方括号中，比如： 1234int num = 2;std::find_if(std::begin(ia), std::end(ia), [num](int a) &#123; return a % num;&#125;); 变量的捕获默认都是以拷贝的方式放到lambda对象中，你也可以使用引用来捕获变量： 1234int num = 2;std::find_if(std::begin(ia), std::end(ia), [&amp;num](int a) &#123; return a % num;&#125;); 如果在成员方法中，你可以使用捕获当前对象（这种方式实际上是使用引用捕获*this）。 123std::find_if(std::begin(ia), std::end(ia), [this](int a) &#123; return a % num_;&#125;); lambda更多的语法细节不在这里讨论，有兴趣的可以参考Lambda expressions。 匿名的函数对象实际上，lambda构造的是一个匿名的函数对象，比如： 123[&amp;num](int a) &#123; return a % num;&#125; 实际上等同于（编译器的具体实现应该不是下面这个样子，构造函数应该是不需要的，具体实现方式我清楚，但是逻辑上来说两者等价）： 12345678910class ClosureType &#123;public: ClosureType(int&amp; num) : num_(num) &#123;&#125; auto operator()(int a) const &#123; return a % num_; &#125;private: int&amp; num_;&#125;; 注意，默认情况下，函数调用符重载用默认用的const，这意味着你不能改变通过值拷贝捕获到lambda内部的值，下面的写法是不合法的： 1234[num](int a) &#123; num++; // error return a % num;&#125; 原因我们在上文中有提到，这里不在赘述。如果需要改变内部值，可以在参数列表后面加上mutable： 1234[num](int a) mutable &#123; num++; // ok return a % num;&#125; 此外，函数的返回值可以默认推导，如果你需要指定返回值（比如自动推导会失败），可以使用后置返回值的方式： 1234[num](int a) mutable -&gt; bool &#123; num++; // ok return a % num;&#125; C++14之后，参数的类型可以是auto，捕获列表可以有初始化值： 1234567[num](auto a) &#123; return a % num;&#125;[num = this-&gt;num_](auto a) &#123; return a % num;&#125; std::function在C++中，可调用对象包括很多种，比如普通函数、函数指针、成员函数指针、仿函数、lambda。对于这些可调用对象C++11提供来一个高阶的封装：std::function，它可以用于表示各种各样的可调用对象（甚至包括读取成员变量），下面这个例子来自cppreference。 123456789101112131415161718192021222324252627282930313233// store a free functionstd::function&lt;void(int)&gt; f_display = print_num;f_display(-9);// store a lambdastd::function&lt;void()&gt; f_display_42 = []() &#123; print_num(42); &#125;;f_display_42();// store the result of a call to std::bindstd::function&lt;void()&gt; f_display_31337 = std::bind(print_num, 31337);f_display_31337();// store a call to a member functionstd::function&lt;void(const Foo&amp;, int)&gt; f_add_display = &amp;Foo::print_add;const Foo foo(314159);f_add_display(foo, 1);// store a call to a data member accessorstd::function&lt;int(Foo const&amp;)&gt; f_num = &amp;Foo::num_;std::cout &lt;&lt; "num_: " &lt;&lt; f_num(foo) &lt;&lt; '\n';// store a call to a member function and objectusing std::placeholders::_1;std::function&lt;void(int)&gt; f_add_display2 = std::bind( &amp;Foo::print_add, foo, _1 );f_add_display2(2);// store a call to a member function and object ptrstd::function&lt;void(int)&gt; f_add_display3 = std::bind( &amp;Foo::print_add, &amp;foo, _1 );f_add_display3(3);// store a call to a function objectstd::function&lt;void(int)&gt; f_display_obj = PrintNum();f_display_obj(18); 回调的处理这个模板类可以用于非常方便的处理回调函数。 在std::function出现之前，回调可能使用动多态来实现的： 1234567using Renderer = std::shared&lt;IRenderer&gt;;Renderer renderer = CreateRenderer();void HandleData(const Data&amp; data) &#123; auto frame = Decode(data); renderer-&gt;Render(frame);&#125; 这种方式使得所有的渲染类需要继承子IRenderer，这是继承的解决方案。另外一种方案是使用std::function把继承变成组合。 1234567using Renderer = std::function&lt;void(const Frame&amp;)&gt;;auto render = std::bind(&amp;RendererImpl::Render, renderer)void HandleData(const Data&amp; data) &#123; auto frame = Decode(data); render(frame);&#125; 详细的用法，请参考std::function。 如何多态的存储一个函数对象std::function的实现，在《C++设计新思维》一书中第五章有非常详细的介绍，有兴趣的可以参考这本书。 std::bind前面谈到，std::function是Callable Object的封装，而std::bind可以认为是Callable Object的Adaptor，它可以用于绑定Callable Object的部分参数，从而变成改变函数调用的接口。比如： 12345678using Foo = std::function&lt;int(int)&gt;;int Bar(int a, int b) &#123; return a * b;&#125;Foo double_num = std::bind(Foo, 2, std::placeholder::_1);assert(double_num(3) == 6); 这里面最有意思的地方在于，std::bind把Bar这个需要两个参数的函数变成了一个只需要一个参数就能调用的对象。这个函数可以非常方便的把一个成员函数转换成一个普通方式就可以调用的函数，这在创建线程，注册回调的时候非常方便： 12auto feature = std::async(std::bind(&amp;Renderer::Render, this));asio::async_read(socket, buffer, std::bind(&amp;DataReceiver::OnReadData, this)); 当然，std::async自身可以处理成员函数的情况，所以上面例子中的std::bind是多余的。 实现细节std::bind最精妙的地方在于它可以使用std::placeholder::_1这样的占位符来实现实参的自动分派，它内部的实现逻辑极其精妙，我曾经单独写过一篇文章简要的分析它的实现逻辑，有兴趣的同学可以参考一下，这里不在赘述。 【1】如果成员变量是引用，const成员函数里面可以修改引用指向的数据的值。这个问题换成指针可能会好理解一点，int * const i 表示你不能修改i的值，而不是不能修改i指向的值。引用一旦绑定就不可能更改，所以成员函数const与否对于引用来说意义不大。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++轮子——STL算法和迭代器]]></title>
    <url>%2F2018%2F04%2F13%2Falgorithm-and-iterator%2F</url>
    <content type="text"><![CDATA[STL的六大组件中最主要的是容器和算法这两个，一个泛化数据的存储，一个泛化数据的操作。前面两篇文章我们简单的介绍了STL中的容器，这篇文章将会介绍STL算法以及粘合容器和算法的迭代器。STL是基于模板实现，容器基于模板类，而算法基于模板函数。在具体介绍算法和迭代器之前，我们先简单的回顾一下模板函数的语法。 模板函数模板函数的语法其实很简单，只要把正常的函数的参数类型或者返回值类型都参数化就可以了。比如选择两个数中的最大值，我们可以使用std::max： 12template&lt; class T &gt;const T&amp; max( const T&amp; a, const T&amp; b ); 这个模板函数中两个参数的类型和返回值的类型都参数化了。 自动类型推导模板函数有一个非常重要的特性是——它支持类型的自动推导。我们实例化一个模板类的时候需要手动指定模板参数类型： 1std::vector&lt;int&gt; iv; 但是我们实例化一个模板函数却通常不需要，因为参数可以自动推导【1】： 1std::max(1, 999); 当然有些情况下自动推导会失败（下面这个例子中，两个实参的类型不一样，自动推导有歧义），这个时候我们可以显式指定模板函数的参数类型： 1std::max&lt;double&gt;(1, 2.0); 简化模板类的创建模板函数参数的自动推导在使用上非常方便，这一点被广泛的用于模板类的工厂方法的实现（广义上任何用于创建类的实例的方法都可以称为工厂方法）。比如我们要构造一个std::pair，有两种方式。 第一，显式指定模板类参数： 1std::pair&lt;int, int&gt; point(1, 2); 第二，使用模板函数自动推导： 1std::make_pair(1, 2); 很显然后面这种方式用起来会比前面的方式舒服一些。标准库中存在大量的这一类型的工厂方法，比如：std::make_tuple，std::make_excpetion_ptr，std::make_shared&lt;T&gt;等等。 数据和操作容器和算法的关系，实际上对应着数据和操作的关系。 计算机领域有一个非常著名的公式： 程序 = 数据结构 + 算法 换句话说，我们可以认为【2】： 程序 = 数据 + 操作 在STL中，容器抽象了数据的存储，算法抽象了数据的操作。当然这个说法其实并不准确，因为数据的操作还有一部分（比如插入删除等）直接放到了容器的内部作为成员函数而存在。操作应该实现为成员函数还是算法，主要取决于这个操作是否和数据存储相关（还有可能和效率相关）。理论上说和存储方式无关的操作都可以实现为算法【3】。 算法和数据类型、数据存储方式无关下面这段算法的定义来自《算法导论》 An algorithm is a sequence of computational steps thats transform the input into the output. 翻译成中文是说 算法是把输入变成输出的一系列计算步骤 这段定义有几个隐含的点值得讨论： 1. 算法和输入数据的类型无关当我们描述快速排序算法的时候，我们其实在描述排序的步骤，至于数据类型是int还是double和算法本身其实没有关系。这个概念在C语言中比较不好表达，通常需要通过void*加上函数指针来实现。比如C语言中的排序算法定义如下： 12void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) ); C++中因为模板函数的存在，参数类型可以被参数化，所以这个问题解决起来就方便很多，C++中的std::sort定义如下： 12template&lt; class RandomIt &gt;void sort( RandomIt first, RandomIt last ); 现在，std::sort只需要实现算法逻辑，不需要考虑数据类型。 这个定义显然比C的定义要简单很多也清晰很多 2. 算法和输入的数据是如何存储无关【4】我们描述一个算法，说的是数据的操作步骤，至于如何完成这些操作，实际上并没有规定。在C语言中，操作如何完成和数据如何存储有很大的关系，比如我们要实现指针的递增操作，我们的数据必须是连续存储的。但是在C++中，通过操作符的重载可以让数据的操作和数据如何存储的解耦开来。比如在C语言中线性查找算法的一个典型例子：查找一个字符串中的指定字符的函数strchr定义如下： 1char *strchr( const char *str, int ch ); 而在C++中，查找线性查找算法std::find定义如下： 12template&lt; class InputIt, class T &gt;InputIt find( InputIt first, InputIt last, const T&amp; value ); strchar要求数据必须是连续存储，而且必须以\0结尾，而std::find却没有这个要求，你可以用它来查找链表中的数据。解耦数据的存储和算法实现的关键在于输入数据的泛化，而这个泛化的关键在于迭代器组成的区间。 区间前面提到算法是把输入变成输出的计算步骤，所以要写一个范型算法，首先要解决的问题是如何表达输入。一个范型算法的输入通常是由两个迭代器组成的左闭右开的区间表示的，C语言中则通常是一个首地址+长度这种方式。使用半开闭区间的方式有下面这些好处： 空集的概念很好表示，首尾相同即可 [beg, beg) 比较容易返回错误值，数据查找，如果没有找到，我们不需要返回一个特殊值，直接返回end，就可以来，因为end不在区间内部，返回它很好的表达没有找到这个概念。 比较容易表达迭代终止条件这个概念，beg == end即可表示迭代终止，这对于迭代器来说是很重要的，因为它不需要支持算数操作符，只需要支持判等符即可。 大多算法如果有输出，基本上也都是返回一个迭代器，如果成功，返回区间内的值，如果失败返回end。 获取区间在C++11之前，我们通常使用容器提供的begin和end成员来获取区间： 12std::vector&lt;int&gt; ia = &#123;1, 3, 4, 2, 8&#125;;std::find(ia.begin(), ia.end(), 3); 在C++11提供来范型函数std::begin，std::end，来获取区间（STL刚开始就是用这两个函数，只是加入标准库的过程中被去掉，现在又加回来了）。 12char ia[] = &#123;1, 3, 4, 2, 8&#125;;std::find(std::begin(ia), std::end(ia), 3); PS：数组大小的自动推导也是一个非常有意思的点，有兴趣的可以自行了解一下。 简化其实每次都要调用std::begin、std::end，非常无聊，一不小心还可能输错。boost::range库可以帮我们简化这个过程： 12std::vector&lt;int&gt; ia = &#123;1, 3, 4, 2, 8&#125;;boost::find(ia); 迭代器前一节提到算法的输入通常是一个区间，而这个区间由两个迭代器组成。迭代器是指针这个概念的泛化，和其他所有的泛型定义一样，它实际上是一个Concept，基本定义如下： The Iterator concept describes types that can be used to identify and traverse the elements of a container. 也就是说它主要提供两个功能，标识元素以及遍历容器。对于一个普通的泛型算法来说，遍历功能表现在它的参数上面，而标识功能表现在它的返回值。这两个功能的存在意味着所有的迭代器都支持下面两个操作： *i解引用，因为迭代器支持标识元素，解引用可能是用于取值也可能是用于赋值，具体看后文迭代器的分类。 ++i，因为迭代器支持遍历。 迭代器作为容器（这里说的容器是广义上的容器，C数组也算是容器之一）和算法之间的桥梁而存在。但是算法的输入通常都不是迭代器这个Concept，而是这个Concept的5个Refinement。 迭代器的分类迭代器虽然是指针的泛化版本，但是大部分的算法实际要求的特性会比指针少很多，为了尽可能的提升算法的适用性，迭代器的功能被拆分成5个不同的Concept：输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机迭代器。 输入迭代器输入迭代器提供两个主要的功能： 取值 判等 这可以说是非常简单的功能（当然还要加上迭代器自身支持的操作，见前文），但是仅仅基于这两个功能我们就可以写出很多有用的算法： 比如求和： 12template&lt; class InputIt, class T &gt;T accumulate( InputIt first, InputIt last, T init ); 判等： 123template&lt; class InputIt1, class InputIt2 &gt;bool equal( InputIt1 first1, InputIt1 last1, InputIt2 first2 ); 迭代： 12template&lt; class InputIt, class UnaryFunction &gt;UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f ); 查找： 12template&lt; class InputIt, class T &gt;InputIt find( InputIt first, InputIt last, const T&amp; value ); 输出迭代器和输入迭代器相对的一个概念是输出迭代器，它要求的核心功能是能够对指定的元素写入数据：也就是说支持 *i = x。需要注意的是，这是一个只写的概念，支持写入并不代表支持读取数据，比如 x = *i 不一定合法。因为*操作符可能返回的是对象（这种对象通常称为代理），而这个对象可能并不支持拷贝构造或者到x类型的转换。 输出迭代器通常用于算法的输出参数，比如： 拷贝： 12template&lt; class InputIt, class OutputIt &gt;OutputIt copy( InputIt first, InputIt last, OutputIt d_first ); 前向迭代器前向迭代器是一个支持数据多次读取的输入迭代器，如果前向迭代器是一个可变（mutable相对于只读const而言）迭代器的话，它符合输出迭代器的要求。 前向迭代器和前两个迭代器最大的区别是它支持多次读写，对于输入迭代器来说*i == *i 是不一定成立的（多次读取同一个迭代器可能读到不同的值，比如典型的std::istream_iterator），而对于前向迭代器来说却成立。这个特性使得它可以用于Multipass（表示区间可多次扫描，相对于Singlepass的单次扫描）的算法。 12template&lt; class ForwardIt, class T &gt;bool binary_search( ForwardIt first, ForwardIt last, const T&amp; value ); 它同时也适用于既需要输出又需要判等的情况（输出迭代器不支持判等）： 12template&lt; class ForwardIt, class T &gt;void fill( ForwardIt first, ForwardIt last, const T&amp; value ); 双向迭代器双向迭代器是一种支持双向迭代的前向迭代器，也就是说它支持--操作，大部分涉及到逆序相关的算法都需要使用到双向迭代器： 12template&lt; class BidirIt &gt;void reverse( BidirIt first, BidirIt last ); 12template&lt; class BidirIt1, class BidirIt2 &gt;BidirIt2 copy_backward( BidirIt1 first, BidirIt1 last, BidirIt2 d_last ); 随机迭代器最后这个迭代器，是最接近指针概念的迭代器。它是一种能在常量时间内指向任意元素的双向迭代器。它要求迭代器支持算数运行，也就是 i + n，b - a 这一类的操作。这种迭代器要求比较高，能够实现比较复杂的算法。 比如，打乱数据： 12template&lt; class RandomIt, class URBG &gt;void shuffle( RandomIt first, RandomIt last, URBG&amp;&amp; g ); 又如，排序： 12template&lt; class RandomIt &gt;void sort( RandomIt first, RandomIt last ); 层次关系图做一个简单的总结的话，迭代器的分类大概像下面这样子。OutputIterator和ForwardIterator直接的线故意没有画上箭头，是因为他们不完全是Concept和Refinement的关系。 123456789101112131415161718+---------------+ +----------------+| InputIterator | | OutputIterator |+----------+----+ +-------+--------+ | | | | | +------------------+ | +--&gt; ForwardIterator +---+ +--------+---------+ | | +----------v------------+ | BidirectionalIterator | +----------+------------+ | | +----------v------------+ | RandomAccessIterator | +-----------------------+ 区分迭代器实际类别的重要性需要我们注意的一点是，算法对于迭代器的要求定义的是最低条件，而不是特定条件。迭代器之间其实存在一种递进关系，如果一个算法要求输入InputIterator，那么你输入Forwarditerator也是可行的。算法的实现通常会充分的利用了这一点，来最大限度的提升性能。比如STL中提供了std::advance这个算法用于向前移动迭代器（C ++11之后有std::next和对应std::prev，std::next有返回值，但是在C++17之前要求输入前向迭代器），这个迭代器要求输入输入迭代器。 12template&lt; class InputIt, class Distance &gt;void advance( InputIt&amp; it, Distance n ); 它保证最差的情况下是线性复杂度，但是如果我们输入的是随机迭代器，它可以达到常量复杂度，因为随机迭代器支持简单的算数运算可以通过+n的方式直接返回结果。此外如果你给定的迭代器是双向迭代器，它还支持向后移动。 解决上面的问题的其中一种方式是使用函数重载，额外提供advance_random，和advance_bidirctional两个函数，把选择权抛给用户。这种方式实现简单，但是接口复杂，而且难用。 STL在接口上并没有提供std::advance_random这样的接口，而是使用了统一的接口，但这意味着这个算法的内部必须判断输入的迭代器的类别（注意用词，它需要知道迭代器属于什么类别而不是迭代器到底是什么类型，比如int*的类型是int指针，而迭代器分类中属于随机迭代器，下文中的表述除非特殊说明，否则说的都是类别classification而不是类型type）。 传统的OO思维类型判断可能是提供一个方法返回类型，但是STL并不是这样做的，它通过另外一种更加灵活的技术——Traits——来实现迭代器所属类别的判断。 std::iterator_traitstraits技术的一个很实用的模板技术，它通常用于特征或者说的提取。std::iterator_traits是标准库中提供的traits之一用于提取迭代器的特征（其他的还有char_traits，number_traits）。这个类通常内部至于类型定义，没有实际的数据成员和方法（有成员方法的又被称为Policy，当然这种分类是概念上的分类，实际上标准库中有很多traits类有成员方法，比如char_traits，number_traits）。 std::iterator_traits的定义是一个空的模板，不同的迭代器对它做特化实现静多态。 12template&lt; class Iterator&gt;struct iterator_traits; 这种实现方式我们在前面讲std::hash的使用也有提到过，它最大的优势在于高度的灵活性，因为它和实际需要获取特征的迭代器是解耦合的。相比于使用成员的方式，它最大的优势是可以兼容指针，你没有办法给指针加上成员，但是你可以对指针加上特化。 12345template&lt; class T &gt;struct iterator_traits&lt;T*&gt;;template&lt; class T &gt;struct iterator_traits&lt;T*&gt;; std::hash中使用到的特化技术是全特化技术，而这里使用到的偏特化技术【5】。 std::iterator_traits定义了下面五个类型成员（member type） difference_type value_type pointer reference iterator_category 比如对于指针的特化中，上面这几个类型被定义为下面的类型： Member type Definition difference_type std::ptrdiff_t value_type T pointer T* reference T&amp; iterator_category std::random_access_iterator_tag 其中最后一个类型可以用于显示指针属于随机迭代器。 Concept在类型系统的表示方式：TAG指针的迭代器分类被定义为：std::random_access_iterator_tag，这是一个很有意思的话题，因为它用类型来表示来Concept，而前面提到Concept并不是一个类型而是符合某些条件的类型的集合。因为它不是具体的类型，所以这些tag实际上只用做类别区分，并没有任何的成员。此外而Concept，Refinment的关系实际上也被表示为空类的父子继承关系： 12345struct input_iterator_tag &#123; &#125;;struct output_iterator_tag &#123; &#125;;struct forward_iterator_tag : public input_iterator_tag &#123; &#125;;struct bidirectional_iterator_tag : public forward_iterator_tag &#123; &#125;;struct random_access_iterator_tag : public bidirectional_iterator_tag &#123; &#125;; 注意看，forward_iterator_tag只是继承了input_iterator_tag。 在做traits的特化的时候，我们可以用上面这些TAG来表示迭代器的实际分类。 1typedef std::random_access_iterator_tag iterator_category; 标准库中存在一个工具类 [std::iterator](http://devdocs.io/cpp/iterator/iterator) 帮助我们定义上面这些类型。 算法是如何利用迭代器的分类信息的前面提到，充分利用迭代器的分类信息可以提升算法的性能，而算法利用分类信息的方式通常是函数重载，我们回头来看std::advance的实现方式【6】： 12345678910111213141516171819202122232425262728293031323334353637template &lt;class _InputIter&gt;inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14void __advance(_InputIter&amp; __i, typename iterator_traits&lt;_InputIter&gt;::difference_type __n, input_iterator_tag)&#123; for (; __n &gt; 0; --__n) ++__i;&#125;template &lt;class _BiDirIter&gt;inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14void __advance(_BiDirIter&amp; __i, typename iterator_traits&lt;_BiDirIter&gt;::difference_type __n, bidirectional_iterator_tag)&#123; if (__n &gt;= 0) for (; __n &gt; 0; --__n) ++__i; else for (; __n &lt; 0; ++__n) --__i;&#125;template &lt;class _RandIter&gt;inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14void __advance(_RandIter&amp; __i, typename iterator_traits&lt;_RandIter&gt;::difference_type __n, random_access_iterator_tag)&#123; __i += __n;&#125;template &lt;class _InputIter&gt;inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX14void advance(_InputIter&amp; __i, typename iterator_traits&lt;_InputIter&gt;::difference_type __n)&#123; __advance(__i, __n, typename iterator_traits&lt;_InputIter&gt;::iterator_category());&#125; 实现的关键在于在内部构造一个空对象来完成函数分派，这种技术我们在前面讲std::array的时候顺带提到过一次。 常见数据结构的迭代器C++中存在大量的数据结构，包括容器，数组，字符串等，这些常用的数据结构都提供迭代器给我们使用，这里简单的罗列一下他们提供的迭代器类型： 数据结构 迭代器类别 C 数组 随机 字符串 随机 vector 随机 deque 随机 list 双向 map 双向 set 双向 forward_list 前向 算法和迭代器使用上需要注意的点区间合法性算法的输入通常是一个迭代器组成的区间 [first，last），遍历的时候从first开始遍历直到first == last 为止，如果 first 用于到不了 last，会形成死循环。 迭代器失效问题迭代器是指针的泛化版本，它实际上遗传了指针的一些问题：比如野指针。这个问题在容器插入和删除的时候非常常见，比如在std::vector尾部插入数据，可能导致底层数组的重新分配，它会导致之前的迭代器失效，类似野指针。 12345std::vector&lt;int&gt; iv = &#123;1, 2&#125;;auto beg = std::begin(iv);iv.push_back(3);*beg = 4; // 可能会崩溃 越界和指针一样，迭代器通常不检查越界问题，所以如果你传入的区间比实际的区间要大，这将会导致崩溃。在一点在隐式区间中很容易出现： 123int a[] = &#123;1, 3, 5, 7, 9&#125;;std::vector&lt;int&gt; iv;std::copy(std::begin(a), std::end(a), std::begin(iv)); 上面这段代码非法，因为std::copy()第三个参数包含一隐含的大小为std::end(a) - std::begin(a)的区间，而iv是一个空数组，显然不存在这样的区间。 安全模式解决上面说到的这些问题，一种比较简单的方式是在Debug版本中使用Safe Mode，不同的编译器提供来不同的方式开启Safe Mode，比如GCC中可以使用-D_GLIBCXX_DEBUG来开启，MSVC在Debug模式下会默认执行检测。 因为迭代器是一个Concept，而不是一个类，所以STL的实现者可以把迭代器定义为一个具有检查功能的代理类从而提供检查功能。 迭代器适配器解决迭代越界的另外一种方式是使用，迭代器适配器，比如说上面提供的问题可以通过下面这种方式解决： 123int a[] = &#123;1, 3, 5, 7, 9&#125;;std::vector&lt;int&gt; iv;std::copy(std::begin(a), std::end(a), std::back_inserter(iv)); std::back_inserter实际上是一个工厂方法（参考前面std::make_pair），它帮我们创建一个std::back_inserter_iterator。而std::back_inserter_iterator是一个迭代器适配器。 前面讲序列容器的时候有提到容器适配器，它们都是适配器，但是适配的方向不同。容器适配器把容器的接口适配成其他的接口，而迭代器适配器把别的接口适配成迭代器的接口。最本质的区别就是，容器适配器不是容器，而迭代器适配器是迭代器。 STL中提供了大量的迭代器适配器，主要的包括下面几类： 插入类这三个都是输出迭代器： back_inserter_iterator，用 push_back() 适配 front_insert_iterator，用 push_front() 适配 insert_iterator，用 insert() 适配 输入输出这些迭代器负责把输入输出库和迭代器融合到一起，主要有istream_iterator，ostream_iterator，istreambuf_iterator，ostreambuf_iterator。 1234std::istringstream str(&quot;0.1 0.2 0.3 0.4&quot;);std::partial_sum(std::istream_iterator&lt;double&gt;(str), std::istream_iterator&lt;double&gt;(), std::ostream_iterator&lt;double&gt;(std::cout, &quot; &quot;)); 输出： 0.1 0.3 0.6 1 PS: 对于字符串的处理，std::istringstream配合算法可以达到非常好的效果。 逆序迭代器std::reverse_iterator可以把正向的遍历变成逆序遍历，比如查找，默认查找第一个，但是如果我使用std::reverse_iterator适配一下，我们可以轻易的实现查找最后一个元素的功能。 逆序迭代器在实现上有一个难点就是区间的合法性，算法的区间，大部分都是定义为[begin, end)，这种形式，读取begin合法而读取end不合法。但是区间如果反过来，(begin -1, end -1 ]这个区间却不一定合法，因为begin - 1通常不是一个合法的迭代器。为了解决这个问题，逆序迭代器中的元素物理位置和逻辑位置有一个元素的偏差。物理上我们依旧使用[begin, end)这个区间，逻辑上对end 的操作存取的是end - 1 这个位置。物理位置到逻辑位置的转换可以通过 base 成员返回。【7】。 【1】：理解模板参数的自动推导是理解C++11中auto的关键，关于这一点《Effctive Modern C++》第一章有详细的介绍。 【2】：这个是个人理解，和上面的等式并不能划等号 【3】：算法是普通的成员函数，一个操作应该实现为普通的函数还是成员函数可以参考《Effctive C++ 第三版》条款23。 【4】： 算法和数据的存储方式无关这一点，是STL中容器和算法库分离的很重的一个原因，而这种分离可以极大的提升算法的适用范围，降低代码重复性。比如Java中的ArrayList和LinkedList都实现了indexOf方法来实现查找的功能，而C++中只实现了一个std::find它可以通吃c array，std::array，std::vector，std::deque，std::list，std::string等，这其实也是范型算法的魅力所在。 【5】：全特化和偏特化的区别请参考《C++模板》一书 【6】：这是 libcxx 目前的实现 2018-04-16 【7】：更详细的细节可以参考标准，或者《Effctive STL》一书]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种跨平台的C/C++动态库的符号隐藏方式]]></title>
    <url>%2F2018%2F04%2F11%2Fsymbol-visibility%2F</url>
    <content type="text"><![CDATA[什么是符号隐藏在同一个文件中，如果有一些函数我们并不想要让外部访问，我们通常会添加 static 修饰符，把它设置为内部链接属性。 1static void foo(); 但是通常库不太可能是单文件组成，这些文件中有些是做接口给外部使用，有些则单纯的只是库的内部实现。对于外部使用者来说，内部实现的这些符号没有实际的作用，理论上我们完全可以像对待文件内部符号一样把它们统统隐藏掉。但是在语言层面我们并没有相关的语法用于表达这个概念（Java中的包访问权限和C#中的internal类似这个概念）。不同的编译器提供了不同的方式来完成这件事情，这篇文章总结了一种跨平台的处理方式。 符号隐藏的作用一般来说做符号隐藏有以下三个作用： 安全，去掉不必要的符号，可以增加逆向破解的难度。 压缩空间，符号实际上是放在 dll 中的，去掉这些符号可以缩减 dll 的大小 性能，符号隐藏掉意味着它不会参与到动态链接过程，编译器可以有更大的优化空间，可能会产生更好的性能。 如何做符号隐藏符号隐藏可以采用下面几个步骤（文中假定你使用MSVC或者4.0以上版本的GCC，低版本GCC不支持符号隐藏）： 1. 动态库符号能否隐藏在于它在动态链接的过程中是否需要用到。静态库实际上是目标文件的集合，它并没有完成链接过程。所以符号隐藏通常都是基于动态库的，静态库的符号隐藏没有很好的跨平台方式，如果想要尝试，可以参考下面这些链接。 How to apply gcc -fvisibility option to symbols in static libraries? Symbol hiding in static libraries built with Xcode/gcc 2. 默认隐藏所有的符号MSVC和GCC在动态库符号的默认属性上面有较大的差别，MSVC默认所有的符号都是隐藏的，而GCC默认所有的符号都是可见的。虽然我不太喜欢臃肿的MSVC，但是我不得不承认在这一点上，我更倾向于MSVC的选择。 如果你使用MSVC编译器，这个步骤你可以什么都不做，如果你使用GCC，你需要给你的编译器加上-fvisibility=hidden选项，你也可以加上-fvisibility-inlines-hidden把内联函数隐藏掉。如果你使用Autotool，你可以通过设置LD_CXXFLAG来控制默认隐藏，如果你使用CMake，可以通过set(CMAKE_CXX_VISIBILITY_PRESET hidden)来完成这一点。 3. 把你想要公开的接口的属性设置为外部可见在MSVC中，我们通过在编译的时候设置__declspec(dllimport)和使用的时候设置__declspec(dllexport)来完成这一点，在GCC中则简单一些统一设置成__attribute__ ((visibility (&quot;default&quot;)))即可。 辅助宏上面这些步骤比较繁琐，通常会定义宏来协助处理这一部分内容，下面是来自GCC WIKI的一个模板 1234567891011121314151617181920212223242526272829303132// Generic helper definitions for shared library support#if defined _WIN32 || defined __CYGWIN__ #define FOX_HELPER_DLL_IMPORT __declspec(dllimport) #define FOX_HELPER_DLL_EXPORT __declspec(dllexport) #define FOX_HELPER_DLL_LOCAL#else #if __GNUC__ &gt;= 4 #define FOX_HELPER_DLL_IMPORT __attribute__ ((visibility ("default"))) #define FOX_HELPER_DLL_EXPORT __attribute__ ((visibility ("default"))) #define FOX_HELPER_DLL_LOCAL __attribute__ ((visibility ("hidden"))) #else #define FOX_HELPER_DLL_IMPORT #define FOX_HELPER_DLL_EXPORT #define FOX_HELPER_DLL_LOCAL #endif#endif// Now we use the generic helper definitions above to define FOX_API and FOX_LOCAL.// FOX_API is used for the public API symbols. It either DLL imports or DLL exports (or does nothing for static build)// FOX_LOCAL is used for non-api symbols.#ifdef FOX_DLL // defined if FOX is compiled as a DLL #ifdef FOX_DLL_EXPORTS // defined if we are building the FOX DLL (instead of using it) #define FOX_API FOX_HELPER_DLL_EXPORT #else #define FOX_API FOX_HELPER_DLL_IMPORT #endif // FOX_DLL_EXPORTS #define FOX_LOCAL FOX_HELPER_DLL_LOCAL#else // FOX_DLL is not defined: this means FOX is a static lib. #define FX_API #define FOX_LOCAL#endif // FOX_DLL 我们想要导出一个符号的时候使用FOX_API： 1class FOX_API Fox &#123;&#125;; 在编译动态库的时候，设置FOX_DLL和FOX_DLL_EXPORTS这两个宏。在使用动态库的是，定义FOX_DLL这个宏。]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++轮子——STL关联容器]]></title>
    <url>%2F2018%2F03%2F23%2Fassociative-contianer%2F</url>
    <content type="text"><![CDATA[上一篇文章中我们简单的介绍了一下STL中的序列容器和容器适配器，这篇文章中我们将重点介绍STL中的关联容器（最后四个在概念上应该不是关联容器，但是因为和前面的容器联系太紧密，统一放在这里讲解），主要内容包括： std::set std::map std::multi_map std::multi_set std::unordered_map std::unordered_set std::unordered_multimap std::unordered_multiset std::set通常提到关联容器，大家可能首先会想到的是std::map，这里先讲解std::set是避免出现关联数组和关联容器概念上的混淆。前者是数据结构中的概念，而后则是C++中特有的概念。 什么关联容器关联容器这个概念，在C++里面是一个Concept（关于concept的讨论我们在上一篇文章中有讲解，这里不再赘述），它的基本定义如下： An AssociativeContainer is an ordered Container that provides fast lookup of objects based on keys. 翻译成中文，大概是说关联容器是提供了基于key的快速查找功能的有序容器。它实际上是 Container 这个 Concept 的 Refinement。 RefinementRefinement 在泛型编程中是一个非常重要的概念，它和 Concept 的关系类似于OO世界中父子继承关系。我们知道 Concept 表示的不是一个类型而是一个类型集合，所以 Refinement 表示的其实也是一个类型集合，这些类型比 Concept 中的定义的类型要有更多的约束和特性（约束和特性其实是一个问题的两个方面，你约束的越是严格，你能够使用的特性越多，但是你能使用的场景越少，比如 Java 中 Object 类哪儿都能用，又哪儿都用不了）。 有序在数学概念上，集合表示具有某种特定性质的事物的总体，它有三个特性：无序性、互异性、确定性。 个人认为，C++世界里面的std::set其实并不是传统意义上的集合，因为它不符合无序的特性（当然你也可以理解成无序表示任何顺序都可以，有序也属于无序的一种状态）。 Key 值的只读属性需要特别提醒的是，因为关联容器使用key值排序，你不能修改key值，否则你会破坏关联容器的内部结构（虽然有些情况下更改key值在逻辑上是合理并且合法的【1】）。在C++11之后，关联容器返回的迭代器，key都默认是const。如果你需要更改key的值，最好的方式是先删除，再插入（有move的存在，这一步的开销相对小一些）。 互异互异是指集合内部的任意两个元素都不相同，这一点在std::set中满足，但是在std::multi_set中并不满足。 std::set元素的互异在编程中有一个非常大的作用是去重，当然你也可以使用sort+unique的方式来处理去重，但是std::set的方式在逻辑上更具有表达力。 成员方法std::set中的很多成员和std::map类似，只不过它们的value_type不一样，std::set&lt;std::string&gt;的value_type是std::string，而std::map&lt;int, std::string&gt;的value_type是std::pair&lt;const int, std::string&gt;。因此这一小节不介绍相关的成员函数，你可以查看std::map的相关成员函数的介绍，然后对照std::set的文档来理解这一部分内容。 std::mapstd::map可能是C++世界使用得最广泛的关联容器，它以键值对的形式存储数据的一种关联容器，可以用于充当关联数组。 关联数组在数据结构的范畴里面，map又被称为关联数组。一个普通的数组，可以使用int（严格来说应该是size_t）做为下标来访问数组内部的元素，关联数组则可以使用任意类型做为下标来存取数组内部的数组。当然这里说的数组是一个逻辑上的概念，关联数组的实现物理上的实现通常是树或者哈希表等等。 需要注意的是关联数组和关联容器是完全不同的两个概念，关联容器强调的是提供快速访问的有序容器，这个概念只存在于C++中；而关联数组强调的是键值对的形式存储数据，并通过key来快速访问数据，这个概念是传统数据结构中的概念，在不同的语言对应不同的类型，比如Java的map，Python的dict。关联容器不一定是关联数组，比如set；关联数组也不一定是关联容器，比如unordered_map。 红黑树map和set的实现通常是一个颗红黑树，红黑树是一种平衡二叉排序树。它的节点要么是黑要么是红，但是如果节点是红，它的两个子节点一定是黑，而且任意节点到叶子节点的任意路径中的黑色节点一样多。这个特性可以保证树的两个分支深度最多只会出现2:1的关系（全黑和红黑相间），所以它基本平衡，它不完美，没有AVL好看，但是它的实现比较简单，出现不平衡的时候，调整比较简单，所以在实际运用中使用的频率很高（比如Linux内核的进程调度用的就是红黑树）。 数据的添加往map里面添加数据有三种方式：operator[]，insert，emplace。效率上来说，通常后面的效率会高于前面的效率。emplace和insert的区别我们在C++轮子 —— STL 序列容器一文中有提到过，这里不再重复解释。 理论上来说，operator[]实际上是数据访问的方式，但是因为它返回的是引用，所以可以直接用于改变元素的值。如果 key 不存在，operator[]会先调用mapped_type的默认构造创建一个空的对象（如果你确保数据存在，可以考虑使用std::map::at，如果key不存在它会抛异常）。比如一个统计单词出现次数的程序可以这样写： 1234567std::map&lt;std::string, std::size_t&gt; words;std::istringstream iss(str);std::string word;while (iss &gt;&gt; word) &#123; words[word]++;&#125; 上面这段代码之所以能够成功运行，是因为如果单词第一次出现，words[word]会使用std::size_t的默认构造（std::size_t()）创建一个新的元素并返回，这样一来新的单词出现次数可以做正确的累加。 同样因为这个特性你不应该使用operator[]来判断数据是否存在，下面是一个错误的示范。 123if (words["word_not_exist"]) &#123; //&#125; 因为如果元素不存在，它会创建一个新的对象，如果你只是想判断元素是否存在，这种行为通常都不是你想要的。 你实际上需要的是功能是Contains，正确的写法是使用std::map::find函数（或者std::map::lower_bound)： 1234auto iter = words.find(&quot;word_not_exist&quot;);if (iter != std::end(words)) &#123; //&#125; operator[]在mapped_type是一个比较重的类型的时候，也可能造成不必要的开销。因为它会县构建一个空的对象，随后又被特换掉，比如你有一个map用于映射人名和职位名称。 12std::map&lt;std::string, std::string&gt; employee;employee[&quot;bob&quot;] = &quot;software enginer&quot;; 这个地方先用”bob”构造了std::string，然后用这个值作为key创建了一个空字符串作为value，然后返回这个vlaue的引用，最后调用这个value的operator=完成赋值。实际上中间的空的字符串完全可以不需要构造，想要去掉这个不必要的开销，我们可以直接调用insert方法来插入数据。 1employee.insert(std::make_pair(&quot;bob&quot;, &quot;software enginer&quot;)); 需要注意的是map的value_type是std::pair&lt;const std::string, std::string&gt;而不是std::string. 如果你不想构建这个pair，你可以使用emplace。 1employee.emplace("bob", "software enginer"); find前面在谈到Contains的时候我们有提到，std::map::find，之所以单独提到它是因为序列容器的查找通常使用的都是算法：std::find，而关联容器通常都提供find成员，你当然也可以用std::find，但是它的复杂度是O(N)，而find成员的复杂度是O(logn)。通常如果一个容器提供了某个算法的同名成员函数，你都应该应该优先使用成员函数，因为它们的效率更高，或者无法使用算法实现（比如 std::map::count，std::list::erase等）。当然换句话说，如果你找不到某个你想要的成员函数的时候，你可以去算法库里面找找。 lower_bound，upper_bound，equal_range关联容器的核心特点是元素有序，所以可以快速的查找数据。它不仅可以查找数据是否存在，它还可以用于查找给定元素的上下界区间。你可以使用lower_bound函数查找到给定元素的下界，也就是容器中第一个不小于【2】指定元素的位置；同样你可以使用upper_bound来找出到给定元素的上界，也就是容器中第一个大于给定元素的位置；而equan_range可以用于返回前两者构成的区间。 定义上可能比较绕，我们举一个具体的例子： 123456789101112const std::map&lt;uint32_t, uint32_t&gt; kBitratesOfResolution = &#123; &#123;192 * 144, 400&#125;, // 144p &#123;320 * 240, 500&#125;, // 240p &#123;480 * 360, 600&#125;, // 360p &#123;640 * 480, 900&#125;, // 480p &#123;1280 * 720, 1800&#125;, // 720p &#123;1920 * 1080, 30000&#125;, // 1080p&#125;;kBitratesOfResolution.lower_bound(1280*720); // 720p 指定的那个位置kBitratesOfResolution.upper_bound(1280*720); // 1080p 所指的那个位置kBitratesOfResolution.equal_range(1280*720); // [720p, 1080p] 如果你在你的程序中需要查找最吻合的某个值（比如上面例子中的找到给定分辨率最合适的比特率），你可以使用上面提到的这几个函数，它们可以在logn之内找到给定的位置。如果你使用的是std::vector，你可以考虑使用sort + binary_search来实现这个功能（如果真的极度在乎性能，而且你的元素不太会变动，你可以考虑用一个排序数组来替代std::map）。 equal_range对于std::map来说感觉没太大的作用，但是对于std::multi_map来说比较实用。 std::multi_set 和 std::multi_mapstd::multi_set和std::multi_map在接口和实现结构上和std::set和std::map是一样的，只不过在multi_xxx版本支持key值可以重复，这里不再重复介绍。key值重复对类似于字典这种功能比较有用（一个字可以有多个解释）。 std::unordered_map、std::unordered_set、std::unordered_multimap、std::unordered_multiset这四个容器在功能上和std::map、std::set类似，但是通常都使用哈希表来实现的，这四个容器是在C++11中才加入到标准库中的，但是实际上在早加入标准之前在很多STL的实现中就默认带了类似功能的容器（比如SGI的版本），它们通常的命名是hash_map和hash_set。为了避免和之前的内容产生冲突，这四个个容器在加入标准库的过程中被命名为以unordered_开头。 这几个容器在接口和内部结构上基本上是一致的，因此下面的讲解以std::unordered_map为例，其他几个大家可以对照文档理解。 无序关联容器这几个容器正如名字上显示的那样是无序的，所以他们不是关联容器，他们在容器分类上被称为无序关联容器（这个名字有点像西红柿炒鸡蛋不放蛋）。下面是 UnorderedAssosiativeContainer 的简明定义。 Unordered associative containers are Containers that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations. 哈希表《程序设计实践》一书中提到四个最常用的数据结构：数组、链表、树、哈希表。在STL中分别对应std::vector，std::list，std::map，std::unordered_map。标准虽然不规定std::unordered_map的实现方式，但是通常的实现都是哈希表。 一个哈希表的典型结构如下图： 1234567891011121314151617181920212223242526272829303132 table +------+ | | | | | | +----&gt; | | | +------+ | | | | | | +----&gt; | | | +------+ | | | +-----+-----+-----+ +---------------+ | |bucket+---&gt; | | | | | | +----&gt; | | +-----+-----+-----+E +--------&gt; | hash function +---+ +------+ | | | | | +---------------+ +----&gt; | | | | | | +------+ | | | +----&gt; | | | | | | +------+ | | | +----&gt; | | | | | | +------+ | | | | | | +----&gt; | | | | +------+ 一个元素，通过一个 hash 函数，映射到哈希表的一个bucket（也有人称之为slot）中。理想情况下，对于哈希表的基本操作都可以在常量时间内完成。所以在查找元素方面，hash表的效率是最高的（序列容器是O(N)，关联容器是O(logn)）。 哈希冲突和红黑树不同的是，哈希表的时间复杂度是一种概率论上的值（计算方法可以参考《算法导论》一书），实际的效果到底怎么样，还要看元素在哈希表中是分布情况。 首先需要注意的是，元素和bucket之间，不会是一一对应的关系，如果有这种关系，我们直接使用数组就可以了，不用使用哈希表。我们给定一个哈希函数，随着元素的增多一定会产生哈希冲突，解决哈希冲突的方式比较多，STL中通常使用外链的方式，把所有哈希值相同的元素通过一个单链表串起来。哈希冲突越严重，哈希表的效率就越低。假如我们给出下面这样一个哈希函数： 123std::size_t hash_fun(int a) &#123; return 0;&#125; 那么所有的元素都会被放到第一个bucket的外链中，这样一来哈希表也就退化成了一个单链表链表，它的操作是非常低效的。所以哈希表的效率关键在于选择一个好的哈希函数（如何选择好的哈希函数是一个非常复杂的问题，有大量的算法，有兴趣的同学可以去看看《算法导论》）。 哈希函数std::unordered_map的原型如下： 1234567template&lt; class Key, class T, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt; std::pair&lt;const Key, T&gt; &gt;&gt; class unordered_map; 可以看出，默认情况下它使用std::hash计算哈希值。但是std::hash实际上是一个函数，而是仿函数（重载了函数调用操作符的类），它的原型如下： 12template&lt; class Key &gt;struct hash; 注意这个模板本身没有定义，它只有声明，因为没有任何一个默认实现是适合所有类型的。标准库为内置类型定义了这个模板的特化： 12345678910111213141516171819template&lt;&gt; struct hash&lt;bool&gt;;template&lt;&gt; struct hash&lt;char&gt;;template&lt;&gt; struct hash&lt;signed char&gt;;template&lt;&gt; struct hash&lt;unsigned char&gt;;template&lt;&gt; struct hash&lt;char16_t&gt;;template&lt;&gt; struct hash&lt;char32_t&gt;;template&lt;&gt; struct hash&lt;wchar_t&gt;;template&lt;&gt; struct hash&lt;short&gt;;template&lt;&gt; struct hash&lt;unsigned short&gt;;template&lt;&gt; struct hash&lt;int&gt;;template&lt;&gt; struct hash&lt;unsigned int&gt;;template&lt;&gt; struct hash&lt;long&gt;;template&lt;&gt; struct hash&lt;long long&gt;;template&lt;&gt; struct hash&lt;unsigned long&gt;;template&lt;&gt; struct hash&lt;unsigned long long&gt;;template&lt;&gt; struct hash&lt;float&gt;;template&lt;&gt; struct hash&lt;double&gt;;template&lt;&gt; struct hash&lt;long double&gt;;template&lt; class T &gt; struct hash&lt;T*&gt;; 也就是说，使用上面这些类型作为std::unordered_map的key的时候可以直接使用，但是其他类型会导致编译错误，因为找不到std::hash的实现。假如我们想要使用我们自己定义的类型作为key，那么我们要实现自己的std::hash的特化。 12345678910111213141516171819202122232425struct Name &#123; std::string first_name; std::string last_name;&#125;;bool operator==(const Name&amp; lhs, const Name&amp; rhs) &#123; return lhs.first_name == rhs.first_name &amp;&amp; lhs.last_name == rhs.last_name;&#125;namespace std&#123; template&lt;&gt; struct hash&lt;Name&gt; &#123; typedef Name argument_type; typedef std::size_t result_type; result_type operator()(argument_type const&amp; s) const &#123; result_type const h1 ( std::hash&lt;std::string&gt;&#123;&#125;(s.first_name) ); result_type const h2 ( std::hash&lt;std::string&gt;&#123;&#125;(s.last_name) ); return h1 ^ (h2 &lt;&lt; 1); &#125; &#125;;&#125;std::unordered_set&lt;Name&gt; names; 特化在泛型中的地位，类似于虚函数在OO中的地位，一个对应静多态，一个对应动多态。你也可以直接实现另一个仿函数，作为std::unordered_map的参数传入进去。 123456789101112// custom hash can be a standalone function object:struct MyHash&#123; std::size_t operator()(Name const&amp; s) const &#123; std::size_t h1 = std::hash&lt;std::string&gt;&#123;&#125;(s.first_name); std::size_t h2 = std::hash&lt;std::string&gt;&#123;&#125;(s.last_name); return h1 ^ (h2 &lt;&lt; 1); &#125;&#125;;std::unordered_set&lt;Name, MyHash&gt; names; 哈希函数的实现有下面两个细节需要注意： 实现operator==，哈希表要求两个相等的元素，哈希值必须一致，通常实现了函数函数的同时也会实现判等操作符。 哈希函数的实现可以借助boost::hash_combine来完成，具体参考 boost::hash 库。 装载因子哈希表是一种典型的用空间换时间的数据结构，我们说哈希表的效率关键在于哈希函数取得的散列效果（所以哈希表又被称为散列表），哈希值越是分散，哈希表的效率越高。哈希函数的散列效果则和装载因子相关。 所谓装载因子是指：size()/bucket_size()，可以看出装载因子越高（在Java的哈希表实现中，这个值默认为 0.75，C++标准并不规定这个值，目前libstdc++和libcxx的实现都使用的是1.0），哈希冲突的概率越大，装载因子越低，哈希冲突的概率越小，但是浪费的空间也越多。 你可以通过std::unordered_map::load_factor获取目前的装载因子，通过std::unordered_map::max_load_factor来获取或者设置装载因子。随着元素的增加，load_factor 会不断接近 max_load_factor，当它超过这个后者的时候，std::unordered_map会自动调整内部bucket的数量，并重新做散列，以降低load_factor，保证效率。如果你的空间足够的多可以考虑增大max_load_factor来提高效率。 当然这个自动重散列的过程和std::vector的自动扩充空间一样，会导致数据的拷贝，效率上比较低。对于std::vector如果你知道你的数据有多少，你可以通过 reserve来预留空间，对于 unordered_map 来说，你可以使用 reserve 和 rehash 两个函数来完成这件事情。这两个函数的关系在于前者接收的是元素个数，后者接收的bucket的个数。假如你预计你有 100 个元素，你可以通过下面两种方式预留空间。 12reserve(100);rehash(100 / max_load_factor()); bucketstd::unordered_map中其实还存在一系列用于处理 bucket 的接口，我平时没有用过，并不太清楚他们的使用场景，但是他们对于打印哈希表的内部结构比较有用 【1】 《Effctive STL》中有提到，如果key是对象，你只是使用这个对象中的某个成员变量当成实际的key，更改其他成员是合法的。但是个人还是不建议这么使用。 【2】上面的表述中都只是用了不小于、大于这种说法，并没有等于不等于这种说法，因为map只要求元素提供operator&lt;，不要求提供operator==。判断元素是否相等实际上是通过:!(a &lt; b || b &lt; a) 这样的判断来实现的，它和 operator== 并不完全等价。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>C++轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ const 到底表示什么]]></title>
    <url>%2F2018%2F03%2F14%2Fcpp-const%2F</url>
    <content type="text"><![CDATA[这两天在看《CLR via C#》一书，发现C#在语法上区分了常量和只读两个概念，使用const关键字表示常量，使用readonly关键字表示只读。我当时转念一想，C++中对应的const如何表达这两种概念呢？细思之下发现，C++里面这个问题比我想象中的要复杂很多，特意写一篇文章记录一下。 常量不等于常量表达式我觉得弄清楚这个问题的关键点在于区分常量和常量表达式这个概念。我们可以用下面这个例子来说明： 12const int size = 7;int days[size]; 上面这段代码在C++中是合法的（虽然你可能更应该使用std::array），但是在C99之前是不合法的（C99允许变长数组，和这里讨论的问题不属于同一个范畴）。也就是说C++中的const和C语言中的const含义并不相同。 常量要解释清楚这个问题，我们需要先解释清楚常量这个概念，常量这个概念其实包含两种完全不一样的含义： 在编译期间计算对象的值 这个对象在作用域内部不会更改 第一个含义实际上说的是常量表达式，而第二个含义实际上说的是只读属性。 C++ 中的常量表达式C++中常量表达式定义如下： Defines an expression that can be evaluated at compile time 一个可以在编译期间确定值的表达式是由整型值、浮点值或者枚举值开始，组合操作符和常量函数而来的值。在语法上，morden c++使用constexpr来表达常量表达式这个概念，比如下面的例子（我没有写；是为了强调它是一个表达式）： 1constexpr int x = 7 C++ 中的只读属性只读属性实际上表达的含义是我保证在这个对象在作用域内部不会更改它的值，这种属主要用在约定接口上面。在语法上，C++使用const表达只读这个概念，比如下面的例子。 1int foo(const std::vector&lt;int&gt;&amp; ia); 这个函数签名约定无论foo如何实现，它不会更改ia的内容。 C 语言中的常量表达式C 语言中的常量表达式的定义如下： An expression that involves only constants. C语言中没有特殊的语法表示这个概念，通常会使用宏来替代 12#define PI (3.14)#define SIZE (1500 - 8 - 8) C 语言中的只读属性C 语言中同样使用 const 关键字表示只读。 为什么上面的代码在C++中合法，在C中不合法呢前面提到，数组的长度必须是一个常量表达式，这在C89和C++中都是一致的。不同地方在于C和C++的常量表达式定义不通。 我们说C++中使用consexpr表示常量表达式，所以在C++中，上面的代码应该像下面这样写： 123// morden cppconstexpr int size = 7;int days[size]; 但是因为在C++11之前，并不存在consexpr这个关键字，所以const关键字就兼任了表示常量表达式的功能，所以上面的代码和下面这一段是等价的： 123// old cppconst int size = 7;int days[size]; C89中常量表达式只允许包含常量，所以在C89中，size并不是常量表达式（size是一个只读变量而不是常量）所以上面这段代码在C89中不合法，合法的写法如下： 12#define SIZE (7)int days[SIZE]; 【1】文中如果使用morden cpp，表示C++11以后的版本，old cpp表示C++11以前的版本，如果只用了C++或者CPP则表示所有的版本都适用。 【2】C++中的常量请参考《C++程序设计语言》第四版，10.4 小节 【3】C中的常量请参考《C程序设计语言》第二版，2.3 小节]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++轮子 —— STL 序列容器]]></title>
    <url>%2F2018%2F02%2F25%2Fstl-part-two-vector%2F</url>
    <content type="text"><![CDATA[STL中大家最耳熟能详的可能就是容器，容器大致可以分为两类，序列型容器（SequenceContainer）和关联型容器（AssociativeContainer）这篇文章中将会重点介绍STL中的各种序列型容器和相关的容器适配器。主要内容包括 std::vector std::array std::deque std::queue std::stack std::priority_queue std::list std::forward_list std::vector提到STL，大部分人的第一反应是容器，而提到容器大部分人首先想到的是std::vector。斯特劳斯特卢普的观点来说，std::vector是所有的容器中的首先，如果你不清楚应该使用哪个容器，那就选std::vector吧（当然，你不应该不清楚选哪个容器，合格是程序员对自己写的代码应该要了如指掌）。 std::vector的使用非常简单，下面是一个简单的例子。 123456#include &lt;vector&gt; // 1int main(int argc, char* argv[]) &#123; std::vector&lt;int&gt; ages = &#123; 1, 2, 3, 4 &#125;; // 2 return 0;&#125; 头文件// 1中引入了std::vector的头文件，需要注意的是所有C++标准库的头文件都是没有.h结尾的。这么做是为了区分，C标准库的头文件和C++标准库的头文件。比如最具代表性的： 12#include &lt;string.h&gt; // C 标准库头文件，包含 strlen，memset 等函数#include &lt;string&gt; // C++ 标准库头文件，包含 std::string 类 此外对于所有C标准库头文件，如果你是在C++项目中引用，你应该使用#include &lt;cxxx&gt;这种方式而不是#include &lt;xxx.h&gt;这种形式。也就是说我们应该使用#include &lt;cstring&gt;而不是#include &lt;string.h&gt; std::vector 还是 vector我见过很多的人（包括很多书）的习惯是在源文件头部写上using namespace std;然后在代码中使用vector&lt;int&gt;，而不是直接使用std::vector&lt;int&gt;。 我个人的习惯是直接使用std::vector&lt;int&gt;，因为namespace对我来说是一个模块，写明了std::有更强的模块内聚表达力，而且也不太容易出现名字碰撞。 初始化// 2在构造std::vector的时候直接给了初始值，这是C++11的特性，在C++11之前不能这样写，有一种大致等同的写法如下： 12int initilizer[4] = &#123; 1, 2, 3, 4 &#125;;std::vector&lt;int&gt; ages(initilizer, initilizer + 4); std::vector&lt;int&gt; ages = { 1, 2, 3, 4 }这种写法实际上从语法分析上来说是分成下面几个步骤的： { 1, 2, 3, 4 } 被编译器构造成一个临时变量std::initializer_list&lt;int&gt;，然后使用临时变量构造一个临时变量 std::vector&lt;int&gt;，然后再用 std::vector&lt;int&gt;的拷贝构造函数构造最终的ages 123std::initializer_list&lt;int&gt; initilizer;std::vector&lt;int&gt; tmp(initilizer);std::vector&lt;int&gt; ags(tmp); 当然上面的分析只是语法上的分析，绝大部分编译器都可以优化掉tmp，而且因为{1, 2, 3, 4}转换成std::initializer_list是编译器在编译器完成的事情，所以其实效率比我们想象中要高一些。 std::vectorstd::vector有一个特化版本std::vector&lt;bool&gt;，用于实现dynamic bitset，需要注意的是，这个特化版本并不是容器，它的迭代器无法很好的适配STL中的所有算法。它的存在是为了节省空间，它的每一个元素只占用一位而不是一个字节。为了实现这种优化，operator[]返回的是一个代理类，你没有办法取单个元素的地址。通常的建议是，如果你不需要动态的bitset，你可以使用std::bitset，如果你需要dynamic bitset你可以考虑使用std::deque&lt;bool&gt;替代。 push_back vs emplace_backC++11在容器尾部添加一个元素调用的函数是push_back，它在libcxx中的实现如下： 12345678910111213141516template &lt;class _Tp, class _Allocator&gt;inline _LIBCPP_INLINE_VISIBILITYvoidvector&lt;_Tp, _Allocator&gt;::push_back(const_reference __x)&#123; if (this-&gt;__end_ != this-&gt;__end_cap()) &#123; __RAII_IncreaseAnnotator __annotator(*this); __alloc_traits::construct(this-&gt;__alloc(), _VSTD::__to_raw_pointer(this-&gt;__end_), __x); __annotator.__done(); ++this-&gt;__end_; &#125; else __push_back_slow_path(__x);&#125; 这里存在两次元素的构造，一次是 __x 参数的构造，一次是容器内部原始的拷贝构造。也就是说使用拷贝构造在末尾构造一个新的元素。emplace_back是C++11为减少其中一次拷贝而引入的新的接口，在libcxx中的实现如下 12345678910111213141516171819202122232425template &lt;class _Tp, class _Allocator&gt;template &lt;class... _Args&gt;inline#if _LIBCPP_STD_VER &gt; 14typename vector&lt;_Tp, _Allocator&gt;::reference#elsevoid#endifvector&lt;_Tp, _Allocator&gt;::emplace_back(_Args&amp;&amp;... __args)&#123; if (this-&gt;__end_ &lt; this-&gt;__end_cap()) &#123; __RAII_IncreaseAnnotator __annotator(*this); __alloc_traits::construct(this-&gt;__alloc(), _VSTD::__to_raw_pointer(this-&gt;__end_), _VSTD::forward&lt;_Args&gt;(__args)...); __annotator.__done(); ++this-&gt;__end_; &#125; else __emplace_back_slow_path(_VSTD::forward&lt;_Args&gt;(__args)...);#if _LIBCPP_STD_VER &gt; 14 return this-&gt;back();#endif&#125; back() 和 pop_back()std::vector内部的数据使用连续的空间存储，除了在尾部插入和删除之外都会需要涉及到其他元素的挪动（空间不足的时候在尾部插入也会需要挪动元素）。std::vector 提供了两个接口用于删除尾部数据， 12reference back();void pop_back(); 理想状态下，我们可以用一个接口完成 1value_type pop_back(); 之所以分开成两个接口是为了保证异常安全，如果让pop_back返回尾部数据就必然涉及到尾部数据的拷贝，而这个拷贝可能抛出异常导致数据的丢失。 自动增长std::vector 会在内存不够的时候自动增长空间，这是相对于C数组来说最大的一个优势。那么空间不够的时候怎么增长呢？答案是不知道。之所以特地强调这一点是为了说明C++标准一个非常重要的特点，规定结果不规定实现，甚至不规定结果。很多人因此抨击C++，带着来自其他语言的优越感嘲笑着为不确定性而焦头烂额的C++工程师。标准之所以这样规定，很大程度上承袭自C语言，C语言标准在很多地方不给出确定的结果是为了给编译器最大的选择，从而达到性能的最优化，毕竟那个时代性能真的很重要。 实际上标准规定push_back是Amortized constant，但并没有规定应该怎么实现，所以最准确的答案是不知道，虽然如果要实现Amortized constant，必须分配 2 倍以上的空间。 这里之所有特地强调这个点，是希望大家重视C++代码的可移植性，做到这一点的关键就是以来行为而不依赖实现。C++作为系统编程语言，几乎可以在任何平台上跑，它的可移植性实际上远高于Java语言。 缩减 std::vectorstd::vector会在空间不够的时候自动分配空间，但是它并不会在空间冗余的时候自动释放空间。如果你使用C++11之后的版本，你可以使用std::vector::shrink_to_fit来回收空间，否则你需要像下面这个缩减空间。 12std::vector&lt;int&gt; ages;std::vector&lt;int&gt;(ages.begin(), ages.end()).swap(ages) 这种用法叫做copy and swap在拷贝构造函数的实现中用的也很多。这个地方需要特别注意的是临时变量和实际变量位置不能写反ages.swap(std::vector&lt;int&gt;(ages.begin(), ages.end()))是语法错误，因为std::vector::swap的原型如下： 1void swap( vector&amp; other ); 临时变量（前面哪个匿名对象）是右值，无法绑定到一个左值引用上面。 兼容 C 数组C++很重要的一个特性就是兼容C语言，C的接口中，如果需要传入一个数组，通常的方式s是传入一个起始地址加上一个长度，如下： 1void* memset( void* dest, int ch, std::size_t count ); 如果你现在有一个std::vector，现在需要把它传递给C，接口你可以调用std::vector::data这个成员变量获取底层的内存空间的首地址。std::vector和其他的容器一个非常重要的区别就是它保证了底层的内存空间的连续性，也就是说，它保证了内存空间和C数组的兼容性，能用C数组的地方都可以使用std::vector，而且它还能保证内存空间的自动管理。 std::vector 的内存模型我们来看下面这段代码： 12std::vector small(100);std::vector large(1000); 那么 sizeof(small) 和 sizeof(large) 哪个大呢？答案是一样大，要解答这个问题我们需要了解 std::vector 的内存模型。std::vector的实现的内存模型并不完全一样，但是基本上都大同小异，类似下面这种结构。 123456789101112 stack +------------+ | begin +----------+ +------------+ | | end +-------------------------------+ +------------+ | |+-------+ cap | v v| +------------+ +--------------------+----------+| | ...... | | | | heap| +------------+ +--------------------+----------+| ^+---------------------------------------------------------------+ 从上面的图中我们可以看出small和large真正的差别其实在heap不在stack，所以说sizeof(small) == sizeof(large)。 返回一个 std::vector 的开销到底有多大大概是受C语言的影响，很多人觉得返回一个std::vector的开销很大，很多人为了能够避免这部分开销，选择使用输入参数的方式返回函数的返回值。 1void foo(std::vector&lt;int&gt;&amp; out); 这种写法和下面的写法到底有多大的开销上的区别呢？ 1std::vector foo(); 在我看来其实差别并不大，原因主要有两个： 因为RVO和NRVO的存在，第一种写法和第二种写法很有可能在最后生成的代码上是一致的。 及时foo的实现导致没有办法做RVO，在C++11中返回一个std::vector的开销实际上也不大，以为返回值都是以move而不是以copy的方式返回的，也就是说真正拷贝的部分只是stack上的那一部分，heap那一部分是不需要拷贝的。 所以大部分情况下，你都可以放心的返回一个std::vector，因为相对下引用参数的写法，直接用返回值会有更好的代码可读性。 123456std::vector&lt;int&gt; param_out;foo(param_out);// 远没有下面的写法直观std::vector out = foo(); std::arraystd::vector会自动管理使用到的内存，这是一个非常重要的特性，但是如果你的数据的大小是已知而且固定的，这个特性对于你来说是不必要的开销。因为前面提到std::vector的数据实际上放到heap上面，访问需要额外的解引用，而且它可能内部有内存空闲，空间有浪费。这种情况下你可以考虑使用std::array来替换std::vector。 12345678enum LogLevel &#123; kTrace, kInfo, kDebug, kWarning, kError &#125;;void PrintLog(LogLevel level, const std::string&amp; msg) &#123; static const std::array&lt;std::string, 5&gt; kTags = &#123;"trace", "info", "debug", "waring", "error"&#125;; std::cout &lt;&lt; "[ " &lt;&lt; kTags[level] &lt;&lt; " ] " &lt;&lt; msg &lt;&lt; std::endl;&#125; 非类型参数上面的定义有一个很有意思的地方是，第二个参数是一个数值而不是一个类型，C++模板参数分为类型参数和非类型模板参数，其中后者可以使用整型、指针和引用。指针和引用我没怎么见过，整型出现的频率倒是比较高，比如上面的例子其实可以改写成下面这个样子： 1234567891011121314151617181920212223242526272829enum LogLevel &#123; kTrace, kInfo, kDebug, kWarning, kError &#125;;template &lt;LogLevel LEVEL&gt;struct LogTag &#123;&#125;;template &lt;LogLevel LEVEL&gt;void PrintLog(const std::string&amp; msg) &#123; PrintLog(LogTag&lt;LEVEL&gt;(), msg);&#125;void PrintLog(LogTag&lt;kTrace&gt;, const std::string&amp; msg) &#123; std::cout &lt;&lt; "[ trace ] " &lt;&lt; msg &lt;&lt; std::endl;&#125;void PrintLog(LogTag&lt;kInfo&gt;, const std::string&amp; msg) &#123; std::cout &lt;&lt; "[ info ] " &lt;&lt; msg &lt;&lt; std::endl;&#125;void PrintLog(LogTag&lt;kDebug&gt;, const std::string&amp; msg) &#123; std::cout &lt;&lt; "[ debug ] " &lt;&lt; msg &lt;&lt; std::endl;&#125;void PrintLog(LogTag&lt;kWarning&gt;, const std::string&amp; msg) &#123; std::cout &lt;&lt; "[ warning ] " &lt;&lt; msg &lt;&lt; std::endl;&#125;void PrintLog(LogTag&lt;kError&gt;, const std::string&amp; msg) &#123; std::cout &lt;&lt; "[ error ] " &lt;&lt; msg &lt;&lt; std::endl;&#125; 这种写法的效率会比使用vector的效率要高，因为LogLevel在编译器期间就已经确定，所以在编译期间就已经确定需要调用哪一个函数，不需要做一次额外的数组访问。 为什么不直接使用C数组std::array实际上是一个容器，它提供来迭代器可以很方便的遍历元素，它可以用过 size() 方法返回数组的大小，而且它是zero cost abstraction的绝佳体现，它的开销实际上并不比C数组要大，但是却提供来大量的方便易用的接口，可以和STL很好的整合在一起，所以如果你使用C++，你基本上可以考虑告别C数组了，变长数组你可以使用vector，定长数组可以使用std::array。 std::deque前文提到，std::vector的内存空间是连续的，在头部插入数据需要移动所有数据是O(N)级别的操作，因为开销过于巨大，std::vector并没有提供在头部插入和删除的接口。如果我们真的有这样的需求，我们可以选择使用std::deque。它支持在头部和尾部以O（1）的开销插入和删除数据，同时可以在O（1）时间内访问任意元素。 push_front、front、pop_front如果你选择使用std::deque而不是vector，十有八九你是为了用这三个函数，std::deque提供这三个函数用于在队列的头部插入和删除数据。需要注意的是下面两点： 这三个函数的复杂度都是O（1） 提供三个函数而不是两个函数是为了保证异常安全性 内存模型std::deque是如何做到O（1）时间内访问任意元素又保证O（1）时间在头部和尾部操作数据内？这要从它的内存模型说起。 std::deque在逻辑上也是一个数组，只不过在物理上它的空间并不连续，它实际上由一段一段的小块儿内存拼接而成，这些小块儿的内存我们姑且叫它buffer，把这些buffer串在一起的就形成了一个逻辑上的一纬数组，用来串连这些buffer我们姑且称之为map 123456789101112 +------+-------+-------+-------+--------+------+ | | | | | | | map +------+---+---+----+--+----+--+----+---+------+ | | | | +--v-+ +--v-+ +--v-+ +--v-+ | | | | | | | | buffer | | | | | | | | | | | | | | | |begin +--&gt; +----+ | | | | +----+ &lt;-+ end | | | | | | | | | | | | | | | | +----+ +----+ +----+ +----+ 这个结构实际上是把一维数组变成了二维结构，本质上来说它就是通过增加一个间接层来实现的。再一次印证来那句老化，什么问题都可以通过增加间接层来解决。 逻辑上的数组我们说逻辑上，std::deque也是一个数组，它支持取下标操作符，可以在O（1）时间内访问容器内部的任意元素。需要注意的是std::deque的O（1）和vector的O（1）存在常数上的差别，因为vector只需要一次解引用就可以获取元素而std::deque需要两次。 std::deque的这种逻辑和物理存储不一致的特性也从另外一个侧面反应了接口和实现直接的本质区别。编程的核心思想在于抽象，而抽象的核心在于分离接口和实现。 自动回收空间和vector一样空间不足的时候会自动分配分配新的空间，大多数情况下只需要分配固定大小的buffer挂到map上，但是buffer过多的时候会导致map的重新分配。和vector不同的是std::deque会自动回收多余的空间，如果你对于运行时的内存要求非常严苛，而且会频繁的插入和删除数据可以考虑使用std::deque。 首尾插入和删除数据可以保证其他迭代器的合法性std::deque还有一个特性就是如果你只是在头部或者尾部操作数据，你之前持有的迭代器不会失效，这一点我们会放到后面迭代器相关的文章中重点的讨论。 std::queue传统的数据结构课程中，提到同时操作头部和尾部，我们首先想到的应该是队列，它是一种FIFO的结构，广泛的使用在各种程序中。STL中提供来std::queue这个模板类来实现这一结构，但是需要特别注意的是它不是一个容器，它是容器适配器。 什么是容器想要理解为什么我们说std::queue不是容器，我们需要理解前面我们一直没有讨论的一个问题——什么是容器？ 加入你生活在OO的世界，你需要定义某一个概念，通常你会定义一个接口（这里说的接口是语法层面的接口而不是逻辑层面的接口），然后定义需要支持的函数，比如（伪代码）： 12345678910111213template&lt;typename T&gt;class IContainer &#123;public: virtual ~IContainer() = default; virtual size_t size() = 0; virtual T at(size_t idx) = 0; ......&#125;;template&lt;typename T&gt;class vector : public IContainer&lt;T&gt; &#123;&#125;; 在C++范型的世界里，并不存在类似这样的语法元素，定义某一个概念靠的是文本描述（C++后续的版本可能会改善这一点，但是目前最新的版本C++17没有）。这段文本描述称之为concept，它定义来范型世界里面的接口。比如说容器的concept如下： 也就是说，标准里面使用这样的文字描述来一个容器应该满足的条件，满足这些条件的就是一个容器。从这一点上来说，concept是一种鸭子模型，会飞、会游泳、会呱呱呱叫的就是一只鸭子，至于你是野鸭子还是橡皮鸭都不重要。 concept这个概念在范型编程中极其重要，用别人的范型类或者范型函数的时候，你需要了解它的参数的concept以保证你的参数输入合法（编译器没办法帮你检查这一点），自己写范型的时候，你需要考虑并标明你的模板参数所需要满足的concept以便别人可以正常的使用，这其实是接口使用者和接口实现者之间的合约，人无信不立这句话放在这里其实也好合适。 为什么不是容器了解了容器的concept之后，我们就可以很清楚的知道为什么std::queue不是容器，因为它不满足容器的concept，比如它没有定义iterator这个成员类型，它也不提供begin、end这样的成员方法，也就谁说你没有办法它不提供迭代器，没有迭代器你就不能使用STL中的算法，你也就失去了STL中的半壁江山。 什么是容器适配器我们说std::queue是一个容器适配器，所谓的适配器从设计模式的角度考虑就是把一个类的接口适配成另外一种接口。std::queue实际上就是拿着容器的接口，适配成队列的所需要的接口。默认情况下，它用来适配的容器是std::deque，这是为什么我们在讲完std::deque之后接着就讲std::queue的原因。我们来看一下标准库中std::queue的定义： 1234template&lt; class T, class Container = std::deque&lt;T&gt;&gt; class queue; 上面这段定义有两个地方值得讨论： 模板参数可以又默认值，就像我们普通的函数参数一样，在C++11之前只有模板类的模板参数可以有默认值在C++11之后，模板函数的模板参数也可以有默认值。 std::queue默认使用的容器是std::deque。也就是说如果你觉得不合适，你完全可以换掉它，只要你提供的类型满足 Container 这个模板参数需要的条件： The type of the underlying container to use to store the elements. The container must satisfy the requirements of SequenceContainer. Additionally, it must provide the following functions with the usual semantics: back() front() push_back() pop_front() 在标准库中除了std::deque之外std::list也满足这个条件。 例子我们用一个例子结束这一部分的讨论 1234567891011121314151617181920#include &lt;queue&gt;#include &lt;list&gt;#include &lt;cassert&gt;int main(int argc, char *argv[])&#123; std::queue&lt;int, std::list&lt;int&gt;&gt; numbers; numbers.push(1); numbers.push(2); numbers.push(3); assert(numbers.front() == 1); assert(numbers.back() == 3); numbers.pop(); assert(numbers.front() == 2); return 0;&#125; 请注意上面std::queue的定义，我提供了第二个参数，也请注意前面的写法是std::list&lt;int&gt;而不是std::list因为list不是类型，list才是。 std::stack说完FIFO的队列，我们顺便说一下FILO的栈，在STL中提供了std::stack用来实现栈的功能，它和std::queue一样是容器适配器而不是容器，而且它同样默认使用std::deque作为默认的容器，和std::queue不同的是，std::stack只需要操作容器的尾部，所以你可以用vector当作来适配std::stack。 std::stack的接口比较直观这里不再赘述，有需要的同学可以自行查看devdocs或者cppreference上面的文档。 std::priority_queue在STL中，优先队列也是一个容器适配器，每次获取的数据都是优先级最大值的值（如何定义优先级可以通过模板参数来控制）。和前面两个容器适配器不同的是，它默认适配的容器是std::vector（std::deque也可以用于适配优先队列）。 堆优先队列和前面两个容器适配器一个重要的区别就是它不仅仅是用底层的容器来存取数据，它会调整存储的数据的顺序，构建一个堆来达到优先队列每次都在常量时间取得优先级最大的数据的功能。 这里说的堆不是堆空间而是一种特殊的数据结构，它是基于数组实现的一颗完全二叉树，有大堆和小堆之分，默认情况下，std::priority_queue是基于大堆实现的，它的特点是父节点比子节点都要大（相反小堆是指它的父节点比子节点都要小）。正是因为堆的这种特点，所以它获取最高优先级的数据可以在常量时间内完成。 堆STL中也是一个非常独特的存在，在传统的数据结构和算法课程中，它属于数据结构部分，经常和队列和栈一起讲。但是在STL中它是放在算法库而不是容器或者容器适配器中实现的，和堆相关的算法有下面这些： std::make_heap std::pop_heap std::push_heap 之所以这样设计是因为堆只需要底层是一个逻辑数组就可以了，把它设计成算法可以让它适用于各种逻辑数组的实现（std::vector，std::deque，std::array，c array）。 逆序如果你需要实现的是每次找到最小值而不是最大值，你可以通过改变默认的模板参数来控制。std::priority_queue的原型如下： 12345template&lt; class T, class Container = std::vector&lt;T&gt;, class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue; 第二个参数可以替换成std::deque，最后一个参数可以替换成你想要的排序算法，比如std::greater，下面是一个具体的例子： 1std::priority_queue&lt;int, std::deque&lt;int&gt;, std::greater&lt;int&gt;&gt; q; std::listSTL中提供了std::list表示链表，通常它的实现是双链表（它支持双向迭代），如果你的代码中需要使用到链表结构可以选择用它做为容器，虽然它的适用场景可能会比我们想象中要低很多。 std::vector vs std::list传统的数据结构的教程中，list通常都是伴随着array而来，通常书上会告诉你 list中元素的插入和删除比array要快，如果你频繁使用插入和删除你应该使用list而不是array 这个说法在学术上是可以认为是正确的，但是实际上大部分情况下，上面的说法是不靠谱的。绝大部分情况下，std::vector的效率都会比std::list要高，原因主要有下面几点： 找到插入点，std::list需要O（N）的时间，而vector只需要O（1）的时间。 std::vector的数据是集中存储的，而std::list的数据是离散存储的，这意味着vector的cache命中率会比std::list的cache命中率要高，内存的读写效率可能会比std::list要高。 std::list存储一个数据需要两个指针（双链表）的额外空间，std::vector不需要，所以std::vector的内存内存使用效率会高于std::list。 std::vector的数据是连续的，可以使用二分查找，快速查找等算法，std::list不行，所以std::vector的查找效率可能会高于std::list。 所以大部分情况下你实际需要的可能都是vector而不是std::list，即使你伴随着数据的删除和插入。那么什么时候应该选用std::list呢？ 什么时候考虑用std::list 容器里面的元素比较大，这种情况下，两个指针的额外开销基本上可以接受，而且如果元素本身比较大，它自身cache的命中率会高。 容器的原始特别多，而且插入删除比较频繁（而且很多在头部插入，如果都是在头部插入可以对比一下deque） 你需要频繁的在迭代的同时删除数据，或者你需要频繁的合并容器。std::list因为本身数据是离散存储的，所以迭代中删除数据不会导致后续的迭代器的失效，做区间插入的时候也可以保证全局的异常安全性。 std::list 中特殊的函数std::list中有一些特殊的成员函数值得我们在这里稍微的讨论一下： size这个函数比较特别的是，它的开销可能是O（N），在C++11之前，标准规定它的开销可能是O（N）也可能是O（1），所以轻易不要调用这个函数。比如 1if (list.size() == 0) 最好写成 1if (list.empty() == 0) remove这个函数之所以特殊是因为std::vector不提供这个函数，而是使用算法std::remove，而remove实际上不删除数据，需要配合std::vector::erase来删除数据。而 std::list 的提供这个成员函数而且会实际删除数据。 insert(iterator pos, InputIt first, InputIt last)这个函数之所以特殊是因为所有的容器中的区间insert，只有std::list的这个方法保证强异常安全性（要么全部插入，要么一个都不插入）【2】 std::forward_list前面提到std::list是一个双向链表，在C++11之后，STL还提供了单链表：forward_list。单链表的开销比双链表要小一些，但是舍弃了双向迭代的功能，而且只支持在头部插入和删除数据。 在你不需要双向迭代的时候，你可以考虑使用单链表替代双链表，比如哈希表的冲突列表就可以使用单链表来实现的。 insert_after、erase_after这两个函数和其实容器不太一样，其他容器是在给定的pos之前（实际上给定的位置，但是因为当前位置的数据往后挪动，相当于插入到来这个位置的元素之前）插入删除，单链表因为不支持双向迭代，只能实现在给定的位置之后插入和删除。 【1】 C++标准只规定了结果，并不规定如何实现，不同的C++编译器对于std::vector的实现可能完全不一样，这里看的源码是来自llvm的libcxx实现。 【2】单链表也支持类似功能，不过它提供的方法是 insert_after，不是insert]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>C++轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++轮子 —— STL 简介]]></title>
    <url>%2F2018%2F02%2F01%2Fstl-part-one%2F</url>
    <content type="text"><![CDATA[大部分人提到 C++ 标准库的时候首先想到的就是STL，STL的全称是Standard Template Library，它背后的技术支撑是模板，由于很多人对于模板本身的不了解，导致很多人对于 STL的理解也非常的片面。有些人把STL等同于容器，有些人把STL等同于标准库。 C++支持非常多的编程范式【1】，C++标准库中用到的基本上是基于对象和泛型这两种（没错，标准库中面向对象其实非常少，没记错的话，只在异常体系中出现过），很明显STL不等同于C++标准库。那是不是说标准库中的泛型部分就属于STL呢？答案也是否定的。C++标准库中的大部分类都是泛型类，但是不是所有的泛型类都是STL，比如 std::string就属于泛型类，但是它不属于STL。 STL 的组成很多人提到STL首先想到的是容器，容器属于STL中非常重要的部分，但是绝对不是唯一的部分，实际上STL由 6 部分组成【2】： 容器（container） 算法（algorithm） 迭代器（iterator） 仿函数（functor） 适配器（adaptor） 配置器（allocator） 这六个部分的关系《STL源码剖析》一书中给了： 这个系列的文章中会介绍Allocator以外的所有组件【3】 反OO的另外一种思维模式有很大一部分人谈论到C++的时候都是在谈论它用于OO编程（也有人只谈论数据抽象这个维度，或者面向过程这个维度），但是C++编程利器STL实际上是一种反OO的实现逻辑。比如说学OO的人大多习惯的一个概念是数据和操作数据的方法封装成一个类。STL的逻辑却可以说是数据和操作数据的方法分离，数据部分放到容器中，数据操作部分放到算法中，这中间使用迭代器连接在一起。 【1】： 在C++之父的《C++编程语言》一书中提到下面几种： 过程式编程（Procedural programming），C 中继承过来的模式 数据抽象（Data abstration），基于类的数据和操作的封装 面向对象编程（Object-oriented programming），基于虚函数的多态 泛型编程（Generic programming），基于模板 【2】：关于 STL 的组成，请参考《STL源码剖析》和《泛型编程与STL》两本书。其中《泛型编程与STL》这本书对于泛型编程的许多概念，解释的非常清楚，非常值得一读。 【3】：不介绍Alloctor主要是两个原因，第一：绝大部分时间，你不需要用到它；第二：《STL源码剖析》一书中讲的比较清楚，有需要的可以查看这本书。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>C++轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 轮子系列]]></title>
    <url>%2F2018%2F01%2F30%2Fcpp-library-usage%2F</url>
    <content type="text"><![CDATA[如果说我看得比别人更远些，那是因为我站在巨人的肩膀上 牛顿这句话非常契合现在的软件开发，因为基本上很少有人写的软件是从零开始。就我而 言，任何一项开发任务的迭代周期的起点都是了解已经存在的巨人。在C++的世界里其实有大量的轮子。这个系列的文章，主要总结一些我用过的比较好用的轮子，当时自己的一个学习笔记吧，我平时学习这些库的时候比较喜欢去翻一翻库的实现源码，所以这个系列的文章在涉及怎么用的同时也会涉及到如何实现。 主要内容包括： C++ 标准库 准标准库 – boost 其他库 C++ 标准库C++ 标准库其实非常庞大，并且在逐年的增长。介绍 C++ 标准库的使用方面的书最好的可能是 Nicolai M·Josuttis 的《C++标准库》第二版。在线文档可以可以通过[devdocs][] 查询。这个系列的文章中无法涵盖 C++ 标准库中的所有内容，只是选取下面一些常用的库做介绍。此外因为 boost 库中有很大一部分都收录到了 11,14,17 的标准库中，11 之后的这些库会放到 boost 中去讲解，一方面是因为 boost 支持 03 标准，另一方面是因为 boost 的源码更容易阅读。因此标准库中这一部分只会介绍下面这些组件： STL string boostboost有准标准库之称，里面包含非常多的好用的库，有很大一部分的库都被 11,14,17 这几个版本的标准陆续的收纳到标准库中。这个系列的文章无法讲解全部的内容，会介绍下面这些我用过的boost库。 asio uuid bind function thread option variant smart ptr 其他库除了上面提到的这些库之外，之前还用过其他一些比较好用的C++库会在也会在这个系列的文章中做简要的介绍。 fmt json spdlog]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 常用库 —— JSON for Modern C++]]></title>
    <url>%2F2017%2F05%2F14%2Fjson-for-modern-cpp-note%2F</url>
    <content type="text"><![CDATA[JSON应该算是目前网络数据交换格式的事实标准，似乎没有那一种语言不存在支持这种数 据格式的库，C++也不例外。不过JSON虽然和语言无关，但是它毕竟源于动态语言，所以 在C++中，很多JSON库接口都不太自然。C++11引入的universal initialization和initializer list让一个拥有自然的接口的JSON库成为可能。这篇文章介绍的就是这样 一个库——JSON for Modern C++。我第一次见到这个库的时候有了使用动态语言的 感觉。 1json array = &#123;"hello", 1, 2.5, false, true, &#123;1, 2&#125;&#125;; 你没有看错，上面写的真的是C++的代码不是Python。这篇文章会介绍关于这个神奇的 JSON库的一些使用和实现上的细节，一起看看吧。 JSON 的基础知识下面这段话来自JSON的官方文档： JSON建构于两种结构： “名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理 解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希 表（hash table），有键列表（keyed list），或者关联数组 （associative array） 。 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（ array）。 另外一个比较重要的点是，JSON中的值可以是下面几种： 1string, number, true, false, object, array, null 结合上面的定义你会发现，这是一种递归的定义，比如数组是值的有序列表，而值又可以是 数组，所以这是一种无穷的结构。 JSON 值在静态语言中的表示 —— nlohmann::json前面提到一个JSON值可以是string, number, true, false, object, array, null中的 任意一种，但是C++是一种静态类型语言，任何值都有它固定的类型，一个值不能既是int又 是double。 解决这个问题的关键点在于抽象，也就是《C++沉思录》中反复提到的一个概念——用类抽象 一个概念。nlohmann::json这个类抽象的概念就是JSON的值。也就是说从静态语言的角 度考虑问题，所有这些值都有同一个类型：nlohmann::json： 12345json string_value = "The quick brown fox jumps over the lazy dog.";json number_value = 1;json boolean_value = true;json array_value = &#123;1, 2, 3, 4&#125;;json object_value = &#123;&#123;"age": 21&#125;&#125;; 当然因为json本身也是一个类型，所以我们可以声明一个存放json的array和object。 12345678910111213json json_array = &#123; json(1), json("The quick brown fox jumps over the lazy dog."), json(true), json(&#123;1, 2, 3, 4&#125;)&#125;;json json_object = &#123; &#123;"object": &#123; &#123;"subobject": 1&#125; &#125; &#125;&#125;; 这样一来就变成了值的递归了，可以扩展成为一个无穷的结构。 需要注意的是，上面例子中显式的构造 json 对象是没有必要的，因为这些构造函数都不 是 explicit 构造函数，支持隐式转化，上面这样写只是为了方便问题的说明。 JSON 值的实际类型当然无论我们如何抽象，它终究无法逃离C++作为一种静态类型语言的核心，我们可以让 json 类即表示number又表示array但是在底层的实现上我们终究无法让一个变量的类 型动态的改变，即便现在 C++11 支持 auto 也是如此。 12auto json_value = 0;json_value = "string"; 上面这种语法在目前的 C++ 中是不合法的。在JSON for Modern C++的底层实现上 ，它为JSON中的每一种value类型都设定了对应的C++类型，其中默认值如下： 123456- object: std::map- array: std::vector- string: std::string- number: std::uint64_t 和 std::int64_t 和 double- true, false: bool- null: nullptr_t 注意上面的 number 使用了三个不同的值是因为在JSON for Modern C++内部 number其实被细分成了number_integer、number_unsigned、number_float三种。 我们看到的nlohmann::json这个类型实际上是一个别名： 1using json = basic_json&lt;&gt;; 也就是说它实际上是模板类basic_json&lt;&gt;使用默认的模板参数时实例化出来的类型。而 basic_json这个模板类的声明如下： 123456789101112template &lt; template&lt;typename U, typename V, typename... Args&gt; class ObjectType = std::map, template&lt;typename U, typename... Args&gt; class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template&lt;typename U&gt; class AllocatorType = std::allocator, template&lt;typename T, typename SFINAE = void&gt; class JSONSerializer = adl_serializer &gt;class basic_json; 这个模板类有9个模板参数，其中前面7个就是用于表示JSON value的实际类型。 ObjectType和ArrayType这两个模板参数的语法叫做模板的模板参数也就是说， ObjectType这个模板参数匹配的实际是另一个模板，这个模板至少有U, V两个模板参数 和Args表示的其他可选模板参数，需要注意的是，U, V, Args对于 basic_json 来说 是没有意义的，因为它 ObjectType 的模板参数，不是 basic_json 的模板参数，语法 上可以省略它们（这和函数的声明可以省略名字相通）。 实际上如果你愿意，你可以替换掉其中的一些类型，比如你想要用std::deque表示 array那么你可以定义你自己的类型JSON类型如下： 1using MyJson = nlohmann::basic_json&lt;std::map, std::deque&gt;; 不过目前来看，我们似乎没有办法使用std::unordered_map作为ObjectType，这好像是 一个库本身的问题std::unorderd_map cannot be used as ObjectType #164， 在 basic_json 中值的实际类型根据模板参数被定义成了下面这几种： 1234567891011using object_t = ObjectType&lt;StringType, basic_json, std::less&lt;StringType&gt;, AllocatorType&lt;std::pair&lt;const StringType, basic_json&gt;&gt;&gt;;using array_t = ArrayType&lt;basic_json, AllocatorType&lt;basic_json&gt;&gt;;using string_t = StringType;using boolean_t = BooleanType;using number_integer_t = NumberIntegerType;using number_unsigned_t = NumberUnsignedType;using number_float_t = NumberFloatType; 类型判断nlohmann::json提供了下列这些借口来判断内部实际的值是什么类型。 123is_primitive , is_structured , is_null , is_boolean , is_number ,is_number_integer , is_number_unsigned , is_number_float , is_object , is_array, is_string 其中 is_structured 是指 is_object() or is_array()，is_primitive 则是指 is_null() or is_string() or is_boolean() or is_number(); 在 basic_json 内部有一个成员变量：m_type，它的类型是一个枚举类： 123456789101112enum class value_t : uint8_t&#123; null, ///&lt; null value object, ///&lt; object (unordered set of name/value pairs) array, ///&lt; array (ordered collection of values) string, ///&lt; string value boolean, ///&lt; boolean value number_integer, ///&lt; number value (signed integer) number_unsigned, ///&lt; number value (unsigned integer) number_float, ///&lt; number value (floating-point) discarded ///&lt; discarded by the the parser callback function&#125;; 其中 discarded 这种类型只存在与解析的过程中，实际的 json 值不会是这种类型。 值的存储在 basic_json 定义了一个成员变量m_value，用于存储实际的值，为了能够让 m_value可以表示多种类型的数据，它的类型被定义成了一个union。 123456789101112union json_value&#123; object_t* object; array_t* array; string_t* string; boolean_t boolean; number_integer_t number_integer; number_unsigned_t number_unsigned; number_float_t number_float; // 其他一些构造函数&#125;; 我们都知道 union 的size是由size最大的那个成员变量决定的，为了能够节省空间 ，object, array, string 这三种类型的之实际上是使用指针来存储的。 类型的自动转换如果单说JSON值的抽象，一个中等水平的程序员都可以做到，JSON for Modern C++真正厉害的地方在于它的自动转换，正是这些自动转换让我们觉得它的API自然 而顺手。 C++ 中的自动类型转换先说一下自动类型转换，在C++中，类型之间的自动转换分为两种： 非 explicit 的单参数构造函数（逻辑上单参即可，多参数但是后面都有默认参数也 可以），它可以用于把其他类型自动转换成本类型，比如我们最常见的 const char* 到 std::string 转换。 1std::string hello = &quot;hello&quot;; operator Type()操作符，这种函数可以用于把本类型自动转换成Type类型。比如下 面这个例子： 1234567891011121314class Widget &#123;public: Widget(const std::string&amp; name) : name_(name) &#123;&#125; operator std::string() &#123; return name_; &#125;private: std::string name_;&#125;;Widget widget = &quot;btn&quot;;std::string btn = widget; 数据自动转换为 nlohmann::json如前所述，这是通过非 explicit 单参构造函数实现的，basic_json 定义了很多这一 类的构造函数，其中最强大的一个莫过于下面这个： 12345678910111213template&lt;typename CompatibleType, typename U = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt;not std::is_base_of&lt;std::istream, U&gt;::value and not std::is_same&lt;U, basic_json_t&gt;::value and not detail::is_basic_json_nested_type&lt; basic_json_t, U&gt;::value and detail::has_to_json&lt;basic_json, U&gt;::value, int&gt; = 0&gt;basic_json(CompatibleType &amp;&amp; val) noexcept(noexcept(JSONSerializer&lt;U&gt;::to_json( std::declval&lt;basic_json_t&amp;&gt;(), std::forward&lt;CompatibleType&gt;(val))))&#123; JSONSerializer&lt;U&gt;::to_json(*this, std::forward&lt;CompatibleType&gt;(val)); assert_invariant();&#125; 这个构造函数体现了作者极强的模板功底，让人叹服，如果去掉各种细节实际上这个函数调 用了JSONSerializer&lt;U&gt;::to_json来完成构造。JSONSerializer是basic_json的一个 模板参数，默认情况下是adl_serializer，ADL是一个非常重要的C++术语，指的是通过 参数的命名空间查看函数的。 对于 nlohmann::json 指定的值类型（或者可以自动转换为指定的类型），都会有一个 to_json 函数的重载，比如对于bool有如下定义： 123456template&lt;typename BasicJsonType, typename T, enable_if_t&lt; std::is_same&lt;T, typename BasicJsonType::boolean_t&gt;::value, int&gt; = 0&gt;void to_json(BasicJsonType&amp; j, T b) noexcept&#123; external_constructor&lt;value_t::boolean&gt;::construct(j, b);&#125; 更厉害的是，对于那些不是指定的类型(std::map, std::vector, std::string 等)，它内 部定义了另一个匿名名字空间中的全局变量to_json 1constexpr const auto&amp; to_json = detail::static_const&lt;detail::to_json_fn&gt;::value; 去掉各种细节，最终他实际上是to_json_fn这个类的一个变量，这个类重载了函数调用操 作符。 12345678910111213141516171819202122232425struct to_json_fn&#123; private: template&lt;typename BasicJsonType, typename T&gt; auto call(BasicJsonType&amp; j, T&amp;&amp; val, priority_tag&lt;1&gt;) const noexcept(noexcept(to_json(j, std::forward&lt;T&gt;(val)))) -&gt; decltype(to_json(j, std::forward&lt;T&gt;(val)), void()) &#123; return to_json(j, std::forward&lt;T&gt;(val)); &#125; template&lt;typename BasicJsonType, typename T&gt; void call(BasicJsonType&amp;, T&amp;&amp;, priority_tag&lt;0&gt;) const noexcept &#123; static_assert(sizeof(BasicJsonType) == 0, "could not find to_json() method in T's namespace"); &#125; public: template&lt;typename BasicJsonType, typename T&gt; void operator()(BasicJsonType&amp; j, T&amp;&amp; val) const noexcept(noexcept(std::declval&lt;to_json_fn&gt;().call(j, std::forward&lt;T&gt;(val), priority_tag&lt;1&gt; &#123;&#125;))) &#123; return call(j, std::forward&lt;T&gt;(val), priority_tag&lt;1&gt; &#123;&#125;); &#125;&#125;; 这个类的设计也是令人拍案叫絕的，首先call这个函数的优先级分派上priority_tag的 设计非常精妙： 12template&lt;unsigned N&gt; struct priority_tag : priority_tag &lt; N - 1 &gt; &#123;&#125;;template&lt;&gt; struct priority_tag&lt;0&gt; &#123;&#125;; 因为子类可以自动转换为父类，所以匹配上priority_tag&lt;1&gt;优先级高，但是如果不成功 会有自动调用priority_tag&lt;0&gt;，这里再通过 static_assert 在编译期间给出可读的错误 信息，实在让人叹为观止。 当然这些都不是重点，第一个 call 函数会通过 ADL 查找到位于 T 类型同一 namespace下面的 to_json 函数。也就是说用户定义的任何类型，只要在同一 namespace下面实现to_json就可以自动转化为 basic_json。每次读到这段代码都会 有一种膜拜之情油然而生，太牛逼了！ 123456789101112131415161718192021222324namespace ns &#123; // a simple struct to model a person struct person &#123; std::string name; std::string address; int age; &#125;; void to_json(json&amp; j, const person&amp; p) &#123; j = json&#123;&#123;"name", p.name&#125;, &#123;"address", p.address&#125;, &#123;"age", p.age&#125;&#125;; &#125; void from_json(const json&amp; j, person&amp; p) &#123; p.name = j.at("name").get&lt;std::string&gt;(); p.address = j.at("address").get&lt;std::string&gt;(); p.age = j.at("age").get&lt;int&gt;(); &#125;&#125;ns::person p &#123;"Ned Flanders", "744 Evergreen Terrace", 60&#125;;json j = p;ns::person copy = j;assert(copy == p); // 当然，这里你需要实现 operator== 有了上面这些构造函数才使得下面这些语句合法合法。 12json number = 1;json str = &quot;number&quot;; 上面这个构造函数基本上是通吃所有值类型的，但是有两个除外，null 和 object， basic_json有一个专门处理null的构造函数如下： 1basic_json(std::nullptr_t = nullptr) noexcept; 对于object则主要是修正问题，正常情况下，在下面这种情况： 1234json value = &#123; &#123;"key1", 1&#125;, &#123;"key2", "2"&#125;,&#125;; 会默认转换成一个array，因为 value 的初始化值其实是一个 std::initializer_list&lt;basic_json&gt;，其中每一个element都是一个array,但是对于 上面这种情况实际上应该解析成一个object才对。为了修正这个问题，basic_json还提 供了另一个构造函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748basic_json(std::initializer_list&lt;basic_json&gt; init, bool type_deduction = true, value_t manual_type = value_t::array)&#123; // check if each element is an array with two elements whose first // element is a string bool is_an_object = std::all_of(init.begin(), init.end(), [](const basic_json &amp; element) &#123; return element.is_array() and element.size() == 2 and element[0].is_string(); &#125;); // adjust type if type deduction is not wanted if (not type_deduction) &#123; // if array is wanted, do not create an object though possible if (manual_type == value_t::array) &#123; is_an_object = false; &#125; // if object is wanted but impossible, throw an exception if (manual_type == value_t::object and not is_an_object) &#123; JSON_THROW(type_error::create(301, "cannot create object from initializer list")); &#125; &#125; if (is_an_object) &#123; // the initializer list is a list of pairs -&gt; create object m_type = value_t::object; m_value = value_t::object; std::for_each(init.begin(), init.end(), [this](const basic_json &amp; element) &#123; m_value.object-&gt;emplace(*(element[0].m_value.string), element[1]); &#125;); &#125; else &#123; // the initializer list describes an array -&gt; create array m_type = value_t::array; m_value.array = create&lt;array_t&gt;(init); &#125; assert_invariant();&#125; 可以看出默认情况下，之前的代码会从 array 修正到 object。当然如果你的本意确实 是创建一个array的话可以使用静态成员函数：json::array 12345static basic_json array(std::initializer_list&lt;basic_json&gt; init = std::initializer_list&lt;basic_json&gt;())&#123; return basic_json(init, false, value_t::array);&#125; 此外，为了接口的对称性，还存在一个静态方法json::object用于创建一个对象。 nlohmann::json 到实际数据类型的自动转换反方向的转换在JSON for Modern C++中同样存在，这个转换主要是通过下面这个 函数来实现的： 123456template &lt; typename ValueType, typename std::enable_if &lt; ...... , int &gt;::type = 0 &gt;operator ValueType() const&#123; // delegate the call to get&lt;&gt;() const return get&lt;ValueType&gt;();&#125; 这个函数存在让下面这样的语法变得合法： 123456789nlohmann::json json = &#123; &#123;"str", "hello"&#125;, &#123;"int", 1&#125;, &#123;"bool", true&#125;,&#125;std::string sval = json["str"];int ival = json["int"];bool bval = json["bool"]; 它实际上上的实现和 to_json 类似，不过使用的是from_json。 从另一个角度看待 nlohmann::json —— 容器其实在设计上来说，nlohmann::json 被设计成了一个容器，你可以想象std::map， std::vector拥有的那些API，nlohmann::json都存在。但是 nlohmann::json 除了表 示 object 和 vector 之外还表示 number，true，false 这些值。对于这些类 型的值来说，容器相关的那些 API 实际上没有真正的意义。从下面这张图可以看出这些相 关的 API 的具体实现情况： 需要注意的地方容器的 API 有 STL 基础的人基本上都非常熟悉，这里不再赘述，有几个和普通容器不对等 的地方需要大家注意： array 的 index 如果超过大小 operator[]，不会出错，中间缺失的那些index会默认 创建成空的 json对象。比如： 123456json arr = json::array();arr[3] = &quot;hello world&quot;;arr[5] = 42;std::cout &lt;&lt; arr &lt;&lt; std::endl; 最终得到的输出是 [null,null,null,&quot;hello world&quot;,null,42] array 的 operator[] 只能用 sizet_t 调用（包括那些可以默认转换的），而 object 的 operator[] 只能用 std::string 调用（也包括那些可以默认转换的 ）。否则会出现运行时异常。这种错误目前似乎无法在编译期间检查出来。 basic_json::valuebasic_json 除了提供容器常用的接口 operator[] 和 at 之外，还提供了 value 成员函数用于取对象中的值，当值不存在的时候提供默认值。这个方法和 Python 中的 or 很像。 1retun x or "default" 123456json j = &#123; &#123;"exist", "hello"&#125;,&#125;;auto exist = j.value("exist", ""); // "hello"auto noexist = j.value("noexist", "world"); // "world" 这个函数对于处理可选参数非常有用。 吐嘈这个库非常强大，实现上也非常的精巧，但是有时候我会觉得，如果把 JSON 的值和 JSON 这两个概念分开表示可能结构上会清晰一些，让 json 单纯是个容器。当然这都 是感觉上的东西，实际上作者为什么没有这样做可能有他自己其他方面考虑。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 高效编程的一些总结]]></title>
    <url>%2F2017%2F05%2F14%2Feffective-cpp-coding%2F</url>
    <content type="text"><![CDATA[这篇文章总结了一些 Linux 下高效C++编程的工具。 专业菜鸟写一天的产出可能高不过高手一个小时，工具神马的都是浮云，自身的专业才是最重要 的。 高效的核心技能——自动化绝大部分时间，你觉得效率不高是因为你在不断的重复，把重复的东西自动化就是效率。 自动化的关键——脚本语言脚本语言非常适合自动化的工作，可以大大的提供效率，比如说我有一个专门用于创建新的 项目的 cpds（cpp project directory structure），它可以用来初始化一个可以新项目的 完整目录结构和基本的配置文件 动静结合，动态语言 + 静态语言 = 编程效率 + 程序的效率 我个人使用 Python，非常棒的一门语言，我用它写脚本，写爬虫，写VIM插件等等 高效的 VIMC++编程在 Linux 下没有太多好用的IDE，编辑器 + GCC + automake（或者 clang + cmake ）可能是最高效的开发方式，编程的绝大部分时间都是在和编辑器打交道，善用好使用编辑 器可以极大的提高效率。编辑器无好坏之分，个人使用VIM，这里介绍高效使用VIM的一些 TIPS。 VIM 从入门到不放弃很多人耐不住寂寞，熬不到入门的那一天就放弃了 VIM。学习曲线没有想象中的那么高，入 门只需要看 vimtutor 就够了。坚持用 VIM 两个礼拜，基本上都能入门。很多人没有办法 习惯 HJKL 的操作习惯，对自己狠一点，置之死地而后生，直接把方向键全部屏蔽掉。 1234noremap &lt;Up&gt; &lt;Nop&gt;noremap &lt;Down&gt; &lt;Nop&gt;noremap &lt;Left&gt; &lt;Nop&gt;noremap &lt;Right&gt; &lt;Nop&gt; 学会高效的使用VIM的核心功能斧子需要磨才会锋利，但是千万不要磨错了边。急于求成是很多人死在VIM进阶路上的绊脚 石，欲速则不达，先看看《Vim实用技巧》这本书，在考虑去配置的各种各样的插件。不要 做一个无插件不能用的VIM党。 好用的插件的推荐YouCompleteMe需要注意的地方： 这个插件需要编译，记得在编译的时候加上 –clang-completer 选项 这个插件需要你提供 .ycm_extra_conf.py 文件，每个项目都应该单独在根目录下放 一个这样的文件。关键部分在于配置开头的 flags 选项中的中头文件路径。 这个配置文件不用手动生成，可以使用YCM-Generator自动生成，安装完成之后，在你 的编译目录下（包含 Makefile 的那个目录）运行 YcmGenerateConfig 命令即可生成 配置文件，然后调整配置文件中的相对路径（编译目录可能不是根目录）即可。 这个插件超级难以安装，因为下载 clang 需要很长时间，耐心一点，欲速则不达。 UltiSnippet + vim-snippet代码自动生成的另外一个神器，前者是引擎，后者是脚本，他们的关系在xxx一文中有提及 ，不再赘述。 需要注意的地方： 你可以自己编辑代码块儿生成规则！你可以用它来插入你自己定制常用代码，相关教程 参考xxx NERDTree强大的目录树，工程管理必备 ctrlp快速的查找文件，这个功能来自 sublime，sublime 的用户应该会非常顺手。 需要注意的地方： 你可以配置搜索程序，目前最快是不是 grep，也不是 ack，是 ag。 你可以配置 ag，来忽略掉其中的某些你不想要的文件，只要在 HOME 目录下放一个 .agignore用力配置你想要忽略的文件即可 它是一个框架有大量基于它的插件，比如 buffer，funky，mru，我自己基于它写过一个 用于引入头文件的 ctrlp-header vim-fswitch快速的交换头文件和实现文件 vim-multiple-cursors来自 sublime 的功能，多行同时编辑，重命名的得力助手 ctrlsf.vim同样是来自 sublime 的功能，配置前面的 vim-multiple-cursors 可以同时修改多个文件 中的名字。 vim-autoformat代码格式化的工具 Ack.vim需要注意的地方： 它只是名字脚本 Ack，但是可以配置使用 ag 来进行搜索 不要再退出vim，使用 grep 搜索之后按照行号来打开文件，你完全可以在 Vim 中完成这项 工作。 fugitive你不要退出 vim 进行 git 操作，它的强大超乎你的想象。 高效的终端高效的另一个关键点个人认为是：专注，心无旁骛。如果电脑只有一个终端，一个键盘，你 可能会成为最高效的程序员。 tmux一个 tmux 顶 N 个显示屏，丢掉鼠标，你的效率会直线上升。 zsh + oh-my-zsh + antigen需要注意的地方： zsh 是可以配置插件的，它的插件管理器有很多，比如 antigen。 非常好用的一些插件： zsh-syntax-highlighting zsh-autosuggestions fzf把模糊匹配带到你的终端上来，好用到爆]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名命名空间和 static 声明的区别]]></title>
    <url>%2F2017%2F03%2F19%2Funnamed-namespace-vs-static%2F</url>
    <content type="text"><![CDATA[在C语言中，如果我们想要一个符号只在文件内部（严格来说是编译单元内部，也就是经 过预处理之后得到的源文件）可用，我们需要把它声明成static，比如： 123// widget.cppstatic void internal_function() &#123; &#125;static int internal_value = 10; 在C++中有一种推荐的等效做法——匿名的名字空间： 1234567// widget.cppnamespace &#123;void internal_function() &#123;&#125;int internal_value = 10;&#125; // namespace 之所以推荐在C++使用匿名名字空间来取代static的这种用法的原因主要有下面三个： static的这个关键词的用途过多，比如你还可以用它声明静态成员，用它声明函数内 部的静态变量。 static没有办法修饰一个类型，所以下面的代码不合法： 1static struct Widget &#123;&#125;; // 不合法 但是匿名命名空间可以： 123namespace &#123;struct Widget &#123;&#125;; // 合法&#125; // namespace 某些模板的参数必须具有外部链接熟悉，比如下面的代码是不合法的 12345678template &lt;typename T, const int&amp; N&gt;struct Array &#123; T data[N];&#125;;static const int kMaxSize = 10;Array&lt;int, kMaxSize&gt; data; // 不合法，报错说 kMaxSize 没有外部的链接属性 虽然static关键字和匿名命名空间完成了类似是事情，但是这两者之间到底有什么本质 的区别呢？这篇文章的剩余部分会详细说明这个问题。 本质区别我想这两者的本质区别应该在于，他们声明出来的符号的链接属性不同。static关键字声 明的符号有内部链接属性而，匿名命名空间中声明的符号有外部链接属性。 staticC和C++中每一个源文件（.c, .cpp）都可以单独编译成一个目标文件(.o)，之后通过链 接器把这些目标文件链接起来，形成最后的可执行文件或者库文件。也就是说某个源文件 a.cpp中用到的符号s（函数，全局变量等）可能是在另一个源文件b.cpp中定义的， 在 a.cpp中只要给出相应的声明就可以了。为了让链接器可以找到符号s的定义，b.o 必须提供它定义的所有可链接的符号。b.o只会提供具有外部链接熟悉的符号给链接器使 用，如果一个符号在声明中加了static 关键字，那么它的链接属性变成了内部链接，也 就不会暴露给链接器进行链接，这样一来它也就只能被文件内部看见了。 匿名名字空间匿名名字空间并不是真的没有名字，只不过这个名字只有编译器知道而已，下面的代码 123namespace &#123;struct Widget &#123;&#125;;&#125; // namespace 实际上经过编译器的处理之后可能是下面这个样子： 123456namespace some_unique_name_compiler_generated &#123;&#125; // 编译器生成一个唯一的名字using namespace some_unique_name_compiler_generated;namespace some_unique_name_compiler_generated &#123;struct Widget &#123;&#125;;&#125; 所以实际上 Widget 类完整的修饰应该是： 1some_unique_name_compiler_generated::Widget; 因为它没有 static 的修饰，所以它具有外部连接，但是因为命名空间的名字是编译器生 成的，外部无从知晓，所以Widget这个符号只有编译单元的内部才能看见。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捉妖记之——成员变量的析构顺序]]></title>
    <url>%2F2017%2F02%2F19%2Fbug-hunt-future-auto-get%2F</url>
    <content type="text"><![CDATA[受RAII思想影响比较深的我，一直认为如果程序组织的好，你通常是不需要编写析构函数的 （析构通常用于资源的释放，如果你的类使用的资源都是RAII管理的话，通常也就不需要自 己编写析构函数了）。但是因为过于迷恋这一点，2017-02-15我写出了一个坑了很久的BUG 。 场景我需要在Linux平台下录制桌面，我使用了ffmpeg的x11grab_xcb，我需要渲染出我录制的数 据，我使用了SDL2进行渲染。 我单独测试了ffmpeg的代码，和SDL2的代码，一切运行起来都比较正常，但是当我把这 两个模块的代码，组合起来之后，程序崩溃了。代码结构很简单，大致如下图： 1234567+-----------+ +------------+| Sender | | Receiver ||-----------| |------------|| | network | || x11grab +----------&gt; SDL2 || | | |+-----------+ +------------+ 崩溃的消息很明确： 1234[xcb] Unknown request in queue while appending request[xcb] Most likely this is a multi-threaded client and XInitThreads has not been called[xcb] Aborting, sorry about that.lt-catch: ../../src/xcb_io.c:165: append_pending_request: Assertion `!xcb_xlib_unknown_req_pending&apos; failed. 问题分析从错误消息来看，很明显是 xcb 内部出了问题，当时我想都没有像，就直接去查 sender相关的代码，因为它使用了x11grabe_xcb进行屏幕的录制，我用了我知道的各种 调试方法：google，gdb，coredump，log，二分。调试的过程非常的漫长，此处省略一万字 。然而我最终还是一无所获，直到我开始怀疑人生，开始怀疑我调试的方向就是错的。 南辕北辙武行四大忌：道士和尚女人小孩，DEBUG的第一大忌我觉得是南辕北辙。这个BUG我解了大半 天之后才开始怀疑自己的最开始的方向是错的。sender很明显使用了x11grab_xcb，但 是实际上的BUG却不见得一定是它引起的。意识到这一点之后，我把目光转向了Receiver ，也就是SDL2上。 后来我发现，其实SDL2这个库在Linux平台下也是依赖于xcb的，而问题也正是处在 SDL2这个库的使用上！ 自动析构的顺序SDL2中的大部分数据结构都有一个create和一个对应的destroy，也就是说你必须在 合适的时候调用destroy来释放你分配的资源，为了自动化管理这些资源的生命周期，我 使用了std::shared_ptr 1234567class SDLRenderer &#123;...private: std::shared_ptr&lt;SDL_Texture&gt; texture_; std::shared_ptr&lt;SDL_Renderer&gt; texture_; std::shared_ptr&lt;SDL_Windows&gt; texture_;&#125;; 此外为了执行SDL2的事件，我单独起了一个线程，听取了《Effective Modern C++》的建 议我使用了std::future&lt;void&gt;也就是task-base的std::async来创建线程。 12345678910111213141516class SDLRenderer &#123;private: std::future&lt;void&gt; mainloop_; std::atomic_bool running_; ...&#125;;SDLRenderer::SDLRenderer() &#123; running_ = true; mainloop_ = std::async(std::launch::async, [this] &#123; while(running_) &#123; SDL_PollEvent(nullptr); std::this_thread::sleep_for(std::chrono::seconds(1)); &#125; &#125;);&#125; 为了能够，让mainloop_停下来，我需要在析构函数中把running_设置成false。也就 是说我需要手动写一个析构函数： 123SDLRenderer::~SDLRenderer() &#123; running_ = false;&#125; 我并没有在析构函数中处理其他的数据成员，因为其他的成员默认析构行为都是符合预期的 ：std::shared_ptr会自动释放我分配的资源，std::future在这种情况下会自动调用 get（std::future什么情况下会自动调用get可以参考《Effective Modern C++》一书 ）。 上面的代码还无法正常的运行，因为我们没有调用SDL_Init，和SDL_Quit，这两个函数 必须在SDL2的其他函数调用的首尾调用（SDL_Init在其他SDL2函数之前，而 SDL_Quit在其他SDL2函数之后，当然这种说法不是很准确，文档中没有直接这么说，但 是应该是一种使用惯例）。很显然最合适的调用点就是在构造和析构函数中，所以有了下面 的代码： 123456789SDLRenderer::SDLRenderer() &#123; SDL_Init(); ... // 初始化 mainloop_ 的代码同上&#125;SDLRenderer::~SDLRenderer() &#123; running_ = false; SDL_Quit();&#125; BUG上面的代码正是引起程序崩溃的原因，问题出在析构函数里面。这个函数实际上的代码并不 是我们看到的这个样子，因为编译器会自动插入成员变量的析构函数的调用，这些析构函数 里面实际上会调用相关的资源释放函数，也就是说实际上的析构函数代码，大概是这个样子 的： 123456789SDLRenderer::~SDLRenderer() &#123; running_ = false; SDL_Quit(); SDL_DestroyWindow(window_.get()); SDL_DestroyRenderer(renderer_.get()); SDL_DestroyTexture(texture_.get()); SDL_PollEvent(nullptr);&#125; 上面这段代码一看就知道函数的调用顺序应该是有问题的。所以解决方式也比较简单，我们 有两种方式可以解决这个问题，第一种就是手动调整成员变量的析构顺序： 12345678910SDLRenderer::~SDLRenderer() &#123; running_ = false; mainloop_.get(); texture_.reset(nullptr); renderer_.reset(nullptr); window_.reset(nullptr); SDL_Quit();&#125; 这样一来，SDL2相关的函数调用顺序就得以解决，另外一个方式是，将RAII进行到底， 写一个RAII管理SDL_Init()和SDL_Quit()，然后直接省略析构函数。这里就不罗列相 关的代码了。 反思 确认成员函数的析构顺序，即使你使用了RAII，RAII确实可以自动化管理你的成员变量的 生命周期，但是这并不代表它可以自动化你的成员变量的析构顺序。 要开自动挡的车！老司机习惯自动挡的车，因为喜欢控制一切的快感；马路杀手还是开自 动挡的车靠谱些；无论你是老司机还是马路杀手都不要来回在自动挡和手动挡之间切换， 迟早要出事儿的，资源管理也是这个道理。]]></content>
      <tags>
        <tag>捉妖记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捉妖记之——参数求值顺序]]></title>
    <url>%2F2017%2F02%2F11%2Fbug-hunt-std-move-argument%2F</url>
    <content type="text"><![CDATA[2017-02-10 碰到一个参数求值顺序导致的程序崩溃问题，花了几个小时去解这个问题，觉 得非常有意思，记录在此。 场景为了完成一个网络传输数据的功能，我定义了一个类表示数据包，包含包头和数据两个 字段（忽略这里的 public 成员变量，我只是想让这篇文章写起来简短些）： 12345class Packet &#123;public: PacketHeader header; std::vector&lt;uint8_t&gt; data;&#125; 因为数据有不同的类型，所以我在类的内部定义了一个枚举： 12345678910class Packet &#123;public: enum class Type &#123; kHeartBit, kBitStream &#125;;private: PacketHeader header; std::vector&lt;uint8_t&gt; data;&#125; 数据包头包含类型和数据长度两个字段： 123456789struct PacketHeader &#123; using VideoType = Packet::Type: using SizeType = std::vector&lt;uint8_t&gt;::size_type; PacketHeader(VideoType type, SizeType len); VideoType type; SizeType len;&#125;; 为了方便数据包，我提供了N个重载的构造函数： 12345678class Packet &#123;public: Packet(Type type, const std::vector&lt;uint8_t&gt;&amp; data); Packet(const PacketHeader&amp; header, const std::vector&lt;uint8_t&gt;&amp; data);private: PacketHeader header; std::vector&lt;uint8_t&gt; data;&#125; 为了能够尽可能的减少重复代码，我使用了委托构造函数来实现第一个构造函数。 12Packet::Packet(Type type, const std::vector&lt;uint8_t&gt;&amp; data) : Packet(PacketHeader(type, data.size()), data) &#123;&#125; 最后为了传输，我定义了一个函数用于Packet的序列化： 123456789101112131415std::vector&lt;uint8_t&gt; Serialize(const Packet&amp; packet) &#123; if (IllegalPacket(packet)) &#123; return vector&lt;uint8_t&gt;(); &#125; std::vector&lt;uint8_t&gt; bitstream(sizeof(PacketHeader) + packet.header.len); // 拷贝头部 ... // 拷贝数据 auto data = std::begin(bitstream); std::advance(data, sizeof(PacketHeader)); std::copy(std::begin(packet.data), std::end(packet.data), data);&#125; 上面这段代码起初工作的很不错，单元测试正常的运行，一切看上去都很顺利，直到我觉得 我需要支持指针形式和右值形式的数据构造，于是我添加了下面这两个Packet构造函数： 12345678910111213class Packet &#123;public: Packet(Type type, const std::vector&lt;uint8_t&gt;&amp; data); Packet(Type type, uint8_t*data, int len); Packet(Type type, std::vector&lt;uint8_t&gt;&amp;&amp; data); Packet(const PacketHeader&amp; header, const std::vector&lt;uint8_t&gt;&amp; data); Packet(const PacketHeader&amp; header, uint8_t*data, int len); Packet(const PacketHeader&amp; header, std::vector&lt;uint8_t&gt;&amp;&amp; data);private: PacketHeader header; std::vector&lt;uint8_t&gt; data;&#125; 按照《Effective Modern C++》中的建议，上面这些构造函数可以统一成值传递的形式，然 后以 move 的形式完成数据的构造，因此我把代码实现成了下面这个样子： 1234567891011class Packet &#123;public: Packet(Type type, std::vector&lt;uint8_t&gt; data) : Packet(PacketHeader(type, data.size()), std::move(data)) &#123; &#125; packet(const packetheader&amp; header_, std::vector&lt;uint8_t&gt; data_) : header(header_), data(std::move(data_))&#123;&#125;private: PacketHeader header; std::vector&lt;uint8_t&gt; data;&#125; 正在我暗自欣喜能学以致用的时候，我运行了一下单元测试，很遗憾的是，程序崩溃了。因 为了我使用了GUN STL的DEBUG模式，运行时报错说我的vector迭代器越界了。 问题分析当时项目比现在看到的复杂的多，很多地方都使用了vector，可惜DEBUG模式的越界输 出中并说到底是迭代器越界了，更坑爹的是它不会输出coredump。我通过人工追踪调用栈 ，最终定位到问题出现在序列化函数Serialize函数中。我们再看看这个函数： 123456789101112131415std::vector&lt;uint8_t&gt; Serialize(const Packet&amp; packet) &#123; if (IllegalPacket(packet)) &#123; return vector&lt;uint8_t&gt;(); &#125; std::vector&lt;uint8_t&gt; bitstream(sizeof(PacketHeader) + packet.header.len); // 拷贝头部 ... // 拷贝数据 auto data = std::begin(bitstream); std::advance(data, sizeof(PacketHeader)); std::copy(std::begin(packet.data), std::end(packet.data), data);&#125; 这个函数中唯一可能出现迭代器越界可能的就是std::copy中的data参数写入越界了！ 但是为什么会越界呢？bitstream的长度是头部数据加上数据长度啊，而且我在操作之前已 经确保了这是一个合法的包！而且为什么只是把参数改成了move之后就不行了呢？到底什么 地方出了问题，我想了又想，我猜了又猜，这个问题还真奇怪。 我花了将近半个小时的时候去纠结这个问题始终找不到问题的答案，最后我决定把整个数据 包的信息打印出来，这才发现了问题的所在，我得到了下面的数据： 1type: bitsteam, len: 0, data_size: 1 第一个 BUG没错，我的包头中的数据长度和实际的数据大小是不一致的。也就是说，我的 IllegalPacket函数写的有问题。因为数据包可能是序列化之前的数据包也可能是序列化 之后网络传输的数据包。说以对于这个函数我有两种形式的重载： 12bool IllegalPacket(const std::vector&lt;uint8_t&gt;&amp; bitstream);bool IllegalPacket(const Packet&amp; packet); 因为网络传输的数据包可能并不完整，所以对于第一个函数我的写法如下： 123456789101112bool IllegalPacket(const PacketHeader&amp; header, int len) &#123; if (IllegalPacketHeader(header)) &#123; return true; &#125; return header.len &gt; len;&#125;bool IllegalPacket(const std::vector&lt;uint8_t&gt;&amp; bitstream) &#123; PacketHeader hader = GetHeader(bitsrteam); return IllegalPacket(header, bitsrteam.size() - sizeof(PacketHeader));&#125; 也就是说只要数据的包头合法而且bitstream中的长度不小于包的实际长度（包头长度+包 头中的数据长度）我就判断为合法。 为了尽可能的复用代码，我把第二个函数写成了下面这个样子： 123bool IllegalPacket(const Packet&amp; packet) &#123; return IllegalPacket(packet.header, packet.data.size());&#125; 我确实尽我最大的努力复用了代码，而且起初这些代码初看上去没什么问题。但是我终究还 是坑死在自己的手上，我忘记了编码的基本原则之一：“clean code that works”，这段代 码虽然 clean，但是它不 work。因为std::vector&lt;uint8_t&gt;形式的包和Packet形式的 包的合法性判断条件并不相同，它们的本来就不应该复用同一个判定逻辑！对于一个 Packet形式的包来说，只要header.len != data.size() 那么它就不是一个合法的包。 所以第一个应该改的地方是 1234567bool IllegalPacket(const Packet&amp; packet) &#123; if (IllegalPacketHeader(packet.header)) &#123; return true; &#125; return packet.header.len != packet.data.size();&#125; 所以其实上面两个同名为IllegalPacket的函数本身的语义就不太一样，为了代码阅读的 便利性，我把第一个函数重命名为ContainLegalPacket 12345678bool ContainLegalPacket(const std::vector&lt;uint8_t&gt;&amp; bitstream) &#123; PacketHeader hader = GetHeader(bitsrteam); if (IllegalPacketHeader(header)) &#123; return false; &#125; return header.len &lt;= len;&#125; 第二个BUG解决了上面这个BUG之后，重新编译运行单元测试，程序没有崩溃了，但是单元测试依旧没 有通过，因为Serialize函数的函数输出和我的预期不相符了。 下面这段单元测试无法通过： 123std::vector&lt;uint8_t&gt; data = &#123;1&#125;;Packet packet(Packet::Type::kBitStream, std::move(data));REQUIRE(!Serialize(packet).empty()); 日志显示，我传入的包是非法的包，也就是说我用构造函数构建的包是非法的包。这说明构 造函数有问题，这就回到了最初改动之后引发崩溃的地方，也就是下面这个构造函数。 12Packet(Type type, std::vector&lt;uint8_t&gt; data) : Packet(PacketHeader(type, data.size()), std::move(data)) &#123; &#125; 它实际调用就的是这个构造函数： 1Packet(const PacketHeader&amp; header_, std::vector&lt;uint8_t&gt; data_); 给你三秒钟，想想上面的代码有什么问题。这是一段为了代码复用+效率最大化而编写的代 码，出发点是没有问题的，但是它的实际效果和你预想的并不一致。 时间到了，答案是参数有问题，更确切的说是参数的求值顺序的问题。C++并规定参数的求 值顺序，但是GCC通常是使用从右往左的构造顺序。它先求值了第二个参数，然后是第一个 参数，如果你展开了这个求值过程，伪代码大概如下： 123std::vector&lt;uint8_t&gt; data_ = std::move(data);PacketHeader temp(type, data.size());const PacketHeader&amp; header_ = temp; 现在BUG应该是一目了然的，move了data，随后却调用了它的size()成员函数，理论 上这是一段未定义行为的代码，因为move之后的对象处于可析构的状态，但是你不应该在 调用它的任何成员函数。 解决这个问题的办法很简单：放弃委托构造。 12Packet(Type type, std::vector&lt;uint8_t&gt; data_) : header(type, data.size()), data(std::move(data_)) &#123; &#125; 额外的一个问题其实如果我们回头看最初崩溃的地方你就会发现，这里的代码有一个前后逻辑不一致的地方 123456std::vector&lt;uint8_t&gt; Serialize(const Packet&amp; packet) &#123; ... std::vector&lt;uint8_t&gt; bitstream(sizeof(PacketHeader) + packet.header.len); ... std::copy(std::begin(packet.data), std::end(packet.data), data);&#125; 这里我构造 bitstream 的时候用的是packet.header.len但是实际拷贝数据的时候使用的 长度是std::distance(std::begin(data), std::end(packet.data)) 也就是 packet.data.size()。这段代码能正常工作的前提就是packet.header.len = packet.data.size() 但是这个前提条件却没有在代码中做额外的检查，所有更合理的方式 应该是： 1234567std::vector&lt;uint8_t&gt; Serialize(const Packet&amp; packet) &#123; ... assert(packet.header.len == packet.data.size()); std::vector&lt;uint8_t&gt; bitstream(sizeof(PacketHeader) + packet.header.len); ... std::copy(std::begin(packet.data), std::end(packet.data), data);&#125; 或者在构造的时候干脆就直接使用：sizeof(PacketHeader) + packet.data.size() 123456std::vector&lt;uint8_t&gt; Serialize(const Packet&amp; packet) &#123; ... std::vector&lt;uint8_t&gt; bitstream(sizeof(PacketHeader) + packet.data.size()); ... std::copy(std::begin(packet.data), std::end(packet.data), data);&#125; 我更加趋向于第一种做法，因为从输出的角度考虑，序列化函数输出的数据长度本来就应该 是包头长度加上包头中len字段的长度，因为这是解序列化函数的内在逻辑。 反思这是一个非常有趣的BUG，我从中得到下面这教训： 正确的使用函数的重载，IllegalPacket 就是应该例子，两个重载函数的内在逻辑并不一 致，但是同样的名字误导我认为它们一致，并且重用判断逻辑 先保证代码的正确，再考虑代码的效率。让正确的代码提高效率，比让高效率的代码正确 难很多。比如 std::move 小心非法的迭代器访问，比如 std::copy 想清楚你写的函数的合约（前后置条件，不变量等），多使用 assert 表示你的合约]]></content>
      <tags>
        <tag>捉妖记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[捉妖记]]></title>
    <url>%2F2017%2F02%2F11%2Fbug-hunt-list%2F</url>
    <content type="text"><![CDATA[DEBUG是程序员的日常生活，有些BUG看到现象的瞬间你就知道问题出在哪里，而有些BUG则 隐藏的极深，让人百思不得其解，这些BUG我称之为妖，解这种BUG则美其名为捉妖，这 个系列的文章里面记录了自己曾经遇到过的各种妖，起名捉妖记。 捉妖记之——参数求值顺序]]></content>
      <tags>
        <tag>捉妖记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之——《Effective Modern C++》]]></title>
    <url>%2F2017%2F02%2F05%2Feffective-modern-cpp-note%2F</url>
    <content type="text"><![CDATA[光看作者Scott Meyers就知道这会是一本好书，可惜的是目前在国内只有影印版。还是梅 耶熟悉的味道——唠唠叨叨，但是问题讲的很详细，有条有理。关于C++11之前读过《深入理 解C++11 : C++ 11新特性解析与应用》一书，大概了解了新的特性，于是就开始疯狂的迷恋 新的语法特性，看完梅耶的书之后，感觉一直以来很多东西我都是门外汉，不懂装懂到处宣 扬，也就难免误人子弟了。 讲了什么这本书对C++11/C++14中的很多特性做了比较详细的讨论，主要讲解的内容包括auto类型 推导，智能指针的使用，移动语义的使用，lambda 表达式的使用等等。这本书让我理解了 很多之前一直困惑的概念，梅耶也许不是对知识理解最透彻的人，但他很可能是讲解最清晰 的人，只要你能忍受他偶尔的唠叨。 没讲什么一直以来我都觉得梅耶对于C++语言的阐述更加偏向于OO，这本书关于泛型的内容有所增加 ，但是我依旧觉得少了一些泛型编程的ITEM，比如如何使用可变参数模板等等。此外这本书 对于标准库的讲解偏少，只是简单的提了一下并发的内容。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[std::bind 的实现原理]]></title>
    <url>%2F2017%2F01%2F27%2Fbind-implementation%2F</url>
    <content type="text"><![CDATA[C++11 中有一个非常神奇的函数std::bind，它让你可以对函数进行适配，动态的绑定参 数。比如你有一个函数接收两个参数，一个算法接收单参数的callable object，那么通 过std::bind我们可以让两者协同工作。 12345678void Foo(int a, int b);template&lt; class InputIt, class UnaryFunction &gt;UnaryFunction for_each( InputIt first, InputIt last, UnaryFunction f );std::vector&lt;int&gt; v;int b = 10;for_each(v.begin(), v.end(), std::bind(Foo, _1, b)) 那么这个神奇的 bind 函数和神奇的占位符到底是怎么实现的呢，它们的工作原理是什么 ？这个问题困扰我很久，最近在网上找到一篇讲解非常清晰的文章，这里对其中的 内容做简单的摘要和翻译，希望对于大家理解背后的工作原理会有帮助。 bind 是一个工厂方法很显然 bind 是一个工厂方法，因为我们传递给 for_each 的是 bind 的返回值而不是 bind 本身。bind 创建的对象在 boost 实现中叫做 bind_t。因为 bind 要做的事情是适配 器，所以它返回的对象必然和它接受的对象是一样的—— callable object。因此，bind_t 中必然重载了函数调用符。 12345class bind_t &#123;public: template&lt;typename A&gt; operator()(A a);&#125;; 此外，bind_t 需要以用户给定的参数调用原本的函数，所以它的内部实际还存储了另外两 个成员，也就是原本的函数和用户已经确定的参数。 12345678910template &lt;typename F, typename L&gt;class bind_t &#123; F f_; L l_;public: bind_t(F f, L l) : f_(f), l_(l) &#123;&#125; template&lt;typename A&gt; operator()(A a);&#125;; 参数对于std::bind来说，参数分为两种，一种是用户创建bind_t的时候提供的，另一种是 调用 bind_t 的operator()()的时候提供的，前者在创建 bind_t 的时候就已经知道，而 后者是在调用bind_t的operator()()的时候才知道，为了方便描述我们把它们分别叫做 L 和 A 。 很显然，L 和 A 都可能有多个，多个 A 可以通过重载不同版本的 operator() 来解决，比 如： 12345678910111213template &lt;typename F, typename L&gt;class bind_t &#123; F f_; L l_;public: template&lt;typename A&gt; operator()(A a); // 单个参数 template&lt;typename A1, typename A2&gt; operator()(A1 a1, A2 a2); // 两个参数 ...&#125;; 但是多个 L 却不行，因为类是没有办法重载的，你不能既定义 bind_t 有两个模板参 数又定义它有三个模板参数。而且就算你可以这么做，你可以以相同的方式处理L， 使用模板的偏特化定义多个不同版本的 bind_t，这种方式是一种不太合理的做法，因为 这样会导致 L 和 A 进行排列组合，实现起来将会极其复杂。boost 内部解决办法是归一， 增加一层间接性，使用 List 而不是使用单个元素。 123456789101112template&lt;typename A1&gt;class List1 &#123; // 省略了构造函数 A1 a1;&#125;;template&lt;typename A1, typename A2&gt;class List2 &#123; // 省略了构造函数 A1 a1; A2 a2;&#125; 这样一来我们就可以使用 List1 和 List2 作为 bind_t 的参数从而解决 L 有多个的问题 。所以实际上，bind 这个函数的工作就是做 List 的封装以及对应 bind_t 的创建。 12345template &lt;typename F, A1, A2&gt;bind_t&lt;F, List2&gt; bind(F f, A1 a1, A2 a2) &#123; List2 list(a1, a2); return bind_t&lt;F, List2&gt;(f, list);&#125; 当然为了能够支持多个参数，实际上 bind 是一个系列的模板函数的重载。 bind_t 的 operator() 的实现有了上面的基础之后，我们来看operator()的具体实现，首先我们需要知道的是，在 bind_t中，我们并不知道 L 到底是几个参数（就像你在 vector 的定义中不可能知道你存 储的到底是什么类型）。所以我们没有办法在 bind_t 中去处理参数绑定的问题，相反我们 需要让 L 去处理参数的绑定问题。 123456789101112template&lt;typename F, typename L&gt;class bind_t &#123; F f_; L l_;public: template&lt;typename A&gt; operator()(A a) &#123; l_(f, a); &#125;&#125;; 也就是说，List 也必须提供函数调用操作符。 12345678910template&lt;typename A1, typename A2&gt;class List2 &#123;public: template&lt;typename F, typename A&gt; operator()(F f, A a);private: A1 a1; A2 a2;&#125; 我们之前说过，bind_t 为了能够支持多个参数的调用，重载了多个 operator() 而这些 重载的函数如果按照前面的实现方式——调用 List 对应的operator()的话就会导致 List 也需要重载多个 operator，而这无疑是非常繁琐的事情。为了解决这个问题，同样可以 用列表替代单个参数。也就是像下面这样实现 bind_t 的函数调用操作符。 1234567891011121314151617template&lt;typename F, typename L&gt;class bind_t &#123; F f_; L l_;public: template&lt;typename A&gt; operator()(A a) &#123; List1 list(a); l_(f, list); &#125; template&lt;typename A1, typename A2&gt; operator()(A1 a1, A2 a2) &#123; List2 list(a1, a2); l_(f, list); &#125;&#125;; ListN 的 operator() 的实现ListN 表示 List1，List2，List3 中的任何一个，这里一 List2 为例 List2 需要完成两件事情，完成参数的绑定和调用实际的函数 f。所以 operator() 最终看 起来应该是这个样子。 123456789101112template&lt;typename A1, typename A2&gt;class List2 &#123;public: template&lt;typename F, typename L&gt; operator()(F f, L l) &#123; f(l1, l2); // 这里的 l1，l2 是根据 L 推导出来的 &#125;private: A1 a1; A2 a2&#125; 所以我们剩下的问题是如何根据 l，a1，a2 最终推导出 f 的实际调用参数 l1，l2。其实 这个算法很简单。以 A1 为例，如果 A1 是普通的值，那么 l1 == a1。如果 A1 是一个占 位符，那么 l1 就等于 l 中对应的值。boost 在实现这个逻辑的时候使用了一个非常巧妙 的方式——函数重载。它重载了 List 的 [] 操作符，然后根据参数的类型来判断返回什么 值。 1234567891011121314151617181920212223template&lt;typename A1, typename A2&gt;class List2 &#123;public: template&lt;typename F, typename L&gt; operator()(F f, L l) &#123; f(l[a1], l[a2]); // 这里的根据 a1，a2 的类型得到实际的值 &#125;private: A1 a1; A2 a2&#125;template&lt;typename A1&gt;class List1 &#123;public: A1 operator[](placeholder&lt;1&gt;) const &#123; return a1; &#125; // 如果是占位符 template &lt;typename T&gt; T operator[](T v) const &#123; return v; &#125; // 如果是普通的类型private: A1 a1;&#125;; 这里的实现使用了一个C++比较偏门的特性，在重载解析的时候，普通函数的优先级高于模 板函数，也就是说当遇到类型为 placeholder&lt;1&gt; 的参数时候，虽然模板函数也可以实例 化出正确的函数，但是因为有一个不需要要实例化的普通函数存在，重载解析会选择调用普 通的函数，也就是调用返回占位符对应的值的那个函数。 placeholder 的作用从上面的代码我们可以看出，实际上，placeholder 只是用来做重载解析的分派用的， 我们需要的是它的类型而不是它的值，所以你会发现前面 operator[] 甚至没有给出参数 名称。placeholder 的定义非常简单： 12345template&lt;int I&gt;class placeholder&#123;&#125;;placeholder&lt;1&gt; _1;placeholder&lt;2&gt; _2;placeholder&lt;3&gt; _3; 这种把数值当类型的技巧可以参考《C++设计新思维》一书。相信现在你应该很清楚 std::placeholder::_1 是什么东西了吧。 实际例子为了方便理解这个参数绑定的过程，我们以文章开头的例子来详细分析一下： 123void Foo(int a, int b);for_each(v.begin(), v.end(), std::bind(Foo, _1, b)); 这个例子中，std::bind 返回的 bind_t 类型是 1234bind_t&lt;void(int, int), List2&lt;placeholder&lt;1&gt;, int&gt;&gt; binder = &#123; Foo, // f_ &#123;_1, 10&#125; // l_&#125; 现在我们用单参数调用 binder： 1binder(5); 那么实际上调用的代码是 binder 的 operator()(int a) 函数： 1234567class bind_t&lt;void(int, int), List2&lt;placeholder&lt;1&gt;, int&gt;&gt; &#123;public: operator()(int a) &#123; List1&lt;int&gt; list(5); l_(f_, list) &#125;&#125;; 然后调用了 List2&lt;std::placeholder, int&gt; 的 operator()(List1 list) 函数： 123456789class List2&lt;std::placeholder&lt;1&gt;, int&gt; &#123; // binder 中的成员变量 l_public: operator()(void(*f)(int, int), List1 list) &#123; f(list[a1], list[a2]) &#125;private: placeholder&lt;1&gt; a1; // 占位符 _1 int a2 // 创建 binder 的时候提供的参数 10&#125;; 最终调用了List1的operator[](placeholder&lt;1&gt;)函数和operator[](int a) 函数 ： 123456789101112class List1&lt;int&gt; &#123; // bind_t 的 operator()(int) 中创建的 local 变量 operator[](placeholder&lt;1&gt;) &#123; return a1; // 返回 5 &#125; operator[](int a) &#123; return a; // 返回 10 &#125;private: int a1; // 这个是函数调用的实参也就是 binder(5) 调用中的 `5`&#125;; 如果实际调用的参数比绑定的参数多会怎么样？std::bind 有一个非常有意思的特性那就是你可以提供比绑定的参数更多的实际参数，多 出来的这些参数会被自动忽略掉。 12345678int foo(int a) &#123; return a;&#125;auto binder = std::bind(foo, std::placeholder::_1);binder(1);binder(1, 2); // 这个调用是合法的！ 为什么呢？因为binder根本不知道2这个参数的存在。如前所述，binder的L是 List1（因为绑定的时候只有 std::placeholder::_1 这个参数）： 所以当我们调用binder(1, 2)的时候调用的是List1的operator()(F f, A a)成员函 数，这里的f是foo，而a是我们提供的实际调用参数List2（1, 2）。 实际上 List1 的 operator()() 实现如下： 1234template&lt;typename F, typename L&gt;operator()(F f, L l) &#123; f(l[a1]); // a1 就是 std::placeholder::_1&#125; 上面这个调用最终变成了foo(1)，也就是说 2 这个参数默默的被吞掉了。 作用这种看似诡异的行为其实有它独特的作用，那就是选择性的忽略掉你不想处理参数，比如你 有一个回调函数的原型如下： 1std::function&lt;void(int, double)&gt;; 那么你在设置这个回调的时候可以使用下面这个binder： 12void foo(int);std::bind(foo, std::placeholder::_1); 也可以使用下面这个binder： 12void bar(int, double);std::bind(bar, std::placeholder::_1, std::placeholder::_2); 这种灵活性使用lambda好像没有办法实现。 结束语实际上std::bind的实现方式和这里提到的有些许出入，比如说为了提高效率，很多地方 都是使用引用而不是值，再不然这里没有处理函数的返回值的问题，实际上的实现中处理了 。但是实现原理上应该八九不离十了，boost的实现放在 boost/bind/bind.hpp 中，读 者可以参考一下。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[enable_shared_from_this 的使用及实现原理]]></title>
    <url>%2F2017%2F01%2F25%2Fenbale-shared-from-this-implementaion%2F</url>
    <content type="text"><![CDATA[本文除 boost 源码以外，大部分源码都是伪代码，为了能够更清晰的理解问题，去掉了 模板相关的内容。文中很多地方直接使用了 sp 一词表示 shared_ptr 使用智能指针难以避免的场景之一就是需要把 this 当成一个 shared_ptr 传递到其他函数 中去。比如你的类实现了某个接口，而你需要把自己注册为该接口的实现。你不能简单粗暴 的用 this 指针构造一个 shared_ptr，因为那样做会导致两个独立的 shared_ptr 指向同 一份资源，这对于基于引用计数的 shared_ptr 来说是致命的。比如下面的代码。 12345678910class Widget &#123; std::shared_ptr&lt;Widget&gt; GetPtr() &#123; return shared_ptr&lt;Widget&gt;(this); // 错误 &#125;&#125;;int main() &#123; auto widget = std::make_shared&lt;Widget&gt;(); widget-&gt;GetPtr();&#125; 正确的打开方式是继承来自 std::enable_shared_from_this，然后调用它的 shared_from_this 成员函数 12345678910class Widget : public std::enable_shared_from_this&lt;Widget&gt; &#123; std::shared_ptr&lt;Widget&gt; GetPtr() &#123; return shared_from_this(); &#125;&#125;;int main() &#123; auto widget = std::make_shared&lt;Widget&gt;(); btn-&gt;GetPtr();&#125; 把自己作为基类的模板参数看起来非常诡异，它有一个更诡异的名字——奇异递归模板模式。 关于它的使用这里不过多的介绍，有兴趣的同学可以参考《More Effective C++》，《C++ Templates》等书籍。这里主要探讨的是它是如何实现返回自身的智能指针的。 避免多个独立的 shared_ptr 指向同一份资源在之前的错误代码中，有两个独立的 shared_ptr 指向同一块空间 12shared_ptr&lt;Widget&gt;(this); // 成员函数中std::make_shared&lt;Widget&gt;(); // main 函数中 很显然 main 函数中这这个 shared_ptr 必不可少，所以我们只能去掉 shared_ptr&lt;Widget&gt;(this) 而让它共享 main 函数中创建的这个 shared_ptr。 如何共享 make_shared 的返回的资源实际上，抛开一切来讲，我们想要的不是基于 this 去创建一个 shared_ptr，而 是希望 this 的类型就是 shared_ptr。想通了这一点你就会发现，其实我们应该 从 shared_ptr 类入手，而不是 Widget 类，因为只有 shared_ptr 类中 this 的类型才是 shared_ptr。 make_shared 会调用 shared_ptr 的构造函数，在 shared_ptr 的构造函数中，this 的类 型就是 shared_ptr，所以从逻辑上分析，我们甚至可以这样去实现 shared_from_this 函数 123456789101112131415161718192021222324// 下面所有的代码省去模板相关的代码，以便阅读。class shared_ptr&lt;Widget&gt; &#123;public: explicit shared_ptr&lt;Widget&gt;(Widget* w) &#123; // 其他初始化，可能在初始化列表中而不是构造函数内部 RegisterSharedPtr(w, this); &#125;&#125;;void RegisterSharedPtr(Widget* w, shared_ptr&lt;Widget&gt;* sp) &#123; // 建立 w 到 sp 的映射关系&#125;void GetSharedPtr(Widget* w) &#123; // 查找 w 对应的 sp&#125;class Widget &#123;public: shared_ptr&lt;Widget&gt; shared_from_this() &#123; GetSharedPtr(this); &#125;&#125;; 建立 w 和 sp 之间的映射关系建立 w 和 sp 的关系最直接的方式是使用一个 map 来集中管理，另一种方式就是采用分布 式的管理方式，也就是让 w 直接存储这个 sp，而不用借助额外的 map。 1234567891011121314151617181920212223class shared_ptr&lt;Widget&gt; &#123;public: explicit shared_ptr&lt;Widget&gt;(Widget* w) &#123; // 其他初始化 if (w) &#123; w-&gt;SetSharedPtr(this); &#125; &#125;&#125;;class Widget &#123;public: void SetSharedPtr(shared_ptr&lt;Widget&gt;* sp) &#123; sp_ = *sp; &#125; shared_ptr&lt;Widget&gt; GetPtr() &#123; return sp_; &#125;private: shared_ptr&lt;Widget&gt; sp_;&#125;; 抽象公共基类上面的设计的最大的问题是，你需要在自己的内部定义一个 shared_ptr 类型的成员变量以 及提供一个 GetPtr 和 SetSharedPtr 成员方法，这些代码和 Widget 类的业务逻辑可能没 有太大的关系，而且不适合重用。为了抽象并重用这些代码，我们可以抽象出一个公共的基 类，这也就是 std::enable_shared_from_this 实际上做的事情 1234567891011121314151617181920212223class enable_shared_from_this &#123;public: void SetSharedPtr(shared_ptr&lt;Widget&gt;* sp) &#123; sp_ = *sp; &#125; shared_ptr&lt;Widget&gt; GetPtr() &#123; return sp_; &#125;private: shared_ptr&lt;Widget&gt; sp_;&#125;;class Widget : public enable_shared_from_this &#123;&#125;;class shared_ptr&lt;Widget&gt; &#123;public: explicit shared_ptr&lt;Widget&gt;(Widget* w) &#123; w-&gt;SetSharedPtr(this); &#125;&#125;; 上面这段代码最大的漏洞在于，shared_ptr 是一个模板，它并不知道 Widget 类是否继承 自 enable_shared_from_this，所以 w-&gt;SetSharedPtr(this) 这一句的调用不完全正确 。boost 中解决这个问题使用了一个非常巧妙的方法——重载，通过重载我们可以让编译器自 动选择是否调用 SetSharedPtr。 1234567891011121314class shared_ptr&lt;Widget&gt; &#123;public: explicit shared_ptr&lt;Widget&gt;(Widget* w) &#123; SetSharedPtr(this, w); &#125;&#125;;void SetSharedPtr(shared_ptr&lt;Widget&gt;* sp, enable_shared_from_this* w) &#123; w-&gt;SetSharedPtr(sp);&#125;void SetSharedPtr(...) &#123; // 什么也不做&#125; 这段代码的精妙，让人叹为观止。 最后一个问题上面这些代码的逻辑上是正确的，但是实际上还有一个巨大的BUG，那就是 Widget 的内部 存在一个指向它自己的 shared_ptr，这意味着你永远无法销毁掉 Widget。销毁 Widget 的前提是没有 shared_ptr 指向它了，而销毁 Widget 必然需要销毁它的成员变量 ，包括指向自身的那个 shared_ptr，而它的存在又否定了我们能销毁 Widget 的前提——没 有 shared_ptr 指向它。这就像是你在画了一个指向自身的箭头，它让你自身形成了循环依 赖，永远没有办法跳出来。 普通的 shared_ptr 循环依赖的问题的处理通常使用的是 weak_ptr，这一次也不例外。我 们需要存储一个 weak_ptr 作为成员变量，而不是 shared_ptr，然后在需要的时候通过 weak_ptr 构建出 shared_ptr，所以正确的打开方式是： 12345678910111213class enable_shared_from_this &#123;public: SetSharedPtr(shared_ptr* sp) &#123; wp = sp &#125; shared_ptr shared_from_this() &#123; return shared_ptr(wp); &#125;private: weak_ptr wp;&#125; 这是一个接近正确答案的写法，也是一个比较容易理解的方法，但和实际上的写法还一些细 微的差别，比如实际上 SetSharedPtr 中并没有把 sp 直接赋值给 wp，而是使用了 shared_ptr 的别名构造函数，为什么这么写，个人能力有限，还没弄清楚，弄懂了再回 来补充。 boost 的源码片段上面的所有代码都是个人按照自己的理解写出来的，为了方便理解，这里给出 boost 的相 关源码片段，以供对比参考（需要注意的是 pn 和引用技术有关，但是和这里讨论的 enable_shared_from_this 没有太大的关联，你可以忽略它）： 12345678template&lt;class T&gt; class shared_ptr&#123; template&lt;class Y&gt; explicit shared_ptr( Y * p ): px( p ), pn() // Y must be complete &#123; boost::detail::sp_pointer_construct( this, p, pn ); &#125;&#125;; 12345template&lt; class T, class Y &gt; inline void sp_pointer_construct( boost::shared_ptr&lt; T &gt; * ppx, Y * p, boost::detail::shared_count &amp; pn )&#123; boost::detail::shared_count( p ).swap( pn ); boost::detail::sp_enable_shared_from_this( ppx, p, p );&#125; 1234567891011template&lt; class X, class Y, class T &gt; inline void sp_enable_shared_from_this( boost::shared_ptr&lt;X&gt; const * ppx, Y const * py, boost::enable_shared_from_this&lt; T &gt; const * pe )&#123; if( pe != 0 ) &#123; pe-&gt;_internal_accept_owner( ppx, const_cast&lt; Y* &gt;( py ) ); &#125;&#125;inline void sp_enable_shared_from_this( ... )&#123;&#125; 12345678910111213141516171819202122232425template&lt;class T&gt; class enable_shared_from_this&#123;public: shared_ptr&lt;T&gt; shared_from_this() &#123; shared_ptr&lt;T&gt; p( weak_this_ ); BOOST_ASSERT( p.get() == this ); return p; &#125;public: // actually private, but avoids compiler template friendship issues // Note: invoked automatically by shared_ptr; do not call template&lt;class X, class Y&gt; void _internal_accept_owner( shared_ptr&lt;X&gt; const * ppx, Y * py ) const &#123; if( weak_this_.expired() ) &#123; weak_this_ = shared_ptr&lt;T&gt;( *ppx, py ); &#125; &#125;private: mutable weak_ptr&lt;T&gt; weak_this_;&#125;;]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android JNI 使用总结]]></title>
    <url>%2F2017%2F01%2F24%2Fandroid-jni-tips-md%2F</url>
    <content type="text"><![CDATA[最近使用JNI封装项目的接口，遇到一些坑，在这里总结一下。文中提到的各种结构的定义 都是C++的定义和它们对应的C定义有些许不同。 获取 JavaVMJavaVM 是JNI定义的两大核心数据接口之一，理论上你可以为每个进程创建多个 JavaVM的实例，但是安卓只允许一个。获取这个实例的方式比较简单，你需要在Java代码 中像下面这样加载动态库： 123static &#123; System.loadLibrary("your-native-lib");&#125; 在库加载的时候，下面这个函数会被调用： 1jint JNI_OnLoad(JavaVM* vm, void* reserved); 你可以在这个函数中把参数vm缓存下来，因为每个进程只允许有一个JavaVM的实例，所 以把它当成全局变量cache下来应该是安全的。 获取 JNIEnvJNI定义的另一个核心的数据结构是JNIEnv，这个数据结构的实例的获取方式分为两种情况 。 你的代码是 Java 代码的 native 方法的实现比如如下代码： 123public class Widget &#123;private native void nativeMethod();&#125; nativeMethod的实现可能是下面这个样子： 12JNIEXPORT void JNICALLJava_xxxxx_nativeMethod(JNIEnv *env, jobject instance); 这种情况下，JNI 会把 JNIEnv 当成参数传递到 native 层的 C/C++ 代码，你直接使用 就可以了。 如果你想要从 native 层直接调用 Java 代码很多时候，你的native代码建立自己的线程（比如建立线程监听），并在合适的时候回调 Java 代码，我们没有办法像上面那样直接获得 JNIEnv，获取它的实例需要把你的线程 Attach到JavaVM上去，调用的方法是 JavaVM::AttachCurrentThread 12JNIEnv* env;GetJVM()-&gt;AttachCurrentThread(&amp;env, nullptr); 这里你需要用到JavaVM的实例，这个实例的获取方式可以参考上一个小节。使用完之后你 需要调用 JavaVM::DetachCurrentThread函数解绑线程。 1GetJVM()-&gt;DetachCurrentThread(); 需要注意的是对于一个已经绑定到JavaVM上的线程调用AttachCurrentThread不会有任 何影响。如果你的线程已经绑定到了JavaVM上，你还可以通过调用JavaVM::GetEnv获取 JNIEnv，如果你的线程没有绑定，这个函数返回JNI_EDETACHED。我的习惯是封装一个 智能指针类自动完成这些操作。 12345678910111213141516171819202122232425262728class JNIEnvPtr &#123;public: JNIEnvPtr() : env_&#123;nullptr&#125;, need_detach_&#123;false&#125; &#123; if (GetJVM()-&gt;GetEnv((void**) &amp;env_, JNI_VERSION_1_6) == JNI_EDETACHED) &#123; GetJVM()-&gt;AttachCurrentThread(&amp;env_, nullptr); need_detach_ = true; &#125; &#125; ~JNIEnvPtr() &#123; if (need_detach_) &#123; GetJVM()-&gt;DetachCurrentThread(); &#125; &#125; JNIEnv* operator-&gt;() &#123; return env_; &#125;private: JNIEnvPtr(const JNIEnvPtr&amp;) = delete; JNIEnvPtr&amp; operator=(const JNIEnvPtr&amp;) = delete;private: JNIEnv* env_; bool need_detach_;&#125;; 这个类在构造函数中调用AttachCurrentThread在析构中调用DetachCurrentThread，然 后重载-&gt;操作符。你可以像下面这样使用这个工具类。 123456// native 代码需要回调 Java 代码NativeClass::NativeMethod() &#123; JNIEnvPtr env; env-&gt;CallVoidMethod(instance, method, args...);&#125; 获取 jclass, jmethodID, jfieldID如果你想要调用Java层的代码，你需要使用 JNIEnv（如何获取它的实例在上一小节中已经 提到），比如你想要调用一个无返回值无参数的成员函数，语法大概如下： 1env-&gt;CallVoidMethod(instance, method); 这里你最少需要两个参数instance和method，因为你要调用一个方法你至少需要有一 个对象以及一个成员函数名称。关于instance如何获取，我们放在下一个小节，这里主要 讨论如何获取method。 在 Java 中所有的方法必然属于某一个类，所以获取 method 之前你需要获取 class， 它们类型分别为jclass,jmethod。 获取类的引用调用JNIEnv::FindClass可以获取对于的 class 的实例。 1jclass clazz = env-&gt;FindClass("full/name/of/your/class"); 获取成员函数的引用获取一个方法的引用需要调用JNIEnv::GetMethodID方法。 1jmethodID = env-&gt;GetMethodID(clazz, "method", "()V"); 第一个参数是上面获取的类引用，第二个参数是方法名称，第三个参数是方法的签名。关于 签名的写法，请参考官方文档的Type Signatures一小节 需要额外注意的地方是，构造函数的函数名称为&lt;init&gt; 获取成员变量的引用获取成员变量的引用和获取成员函数的引用是类似的，调用JNIEnv::GetFieldID即可，这 里不再赘述。 失效问题特别需要注意的地方是，jclass, methodID 和 fieldID 在类 unload 之前都是有效，虽然 一个类会 unload 的情况非常少见，但是并不是没有可能。所以如果你想要保证你的这些引 用有效的话，可以通过下面这种方式对你用到的类，方法，成员变量进行缓存： 12345private static native void nativeInit();static &#123; nativeInit();&#125; 然后在你的 native 方法中获取并缓存你用到的 entity。 123Java_xxxx_nativeInit(JNIEnv *env, jobject instance) &#123; // 查找并且缓存你需要用到的上述对象&#125; 当然如果你使用 System.loadLibrary 你也可以在 JNI_OnLoad 函数中缓存这些东西。 辅助工具下面这两个宏定义来自 libvlc-android 可以用来方便的获取 jclass，jmetod，jfield 123456789101112131415161718192021#define GET_CLASS(clazz, str, b_globlal) \ do &#123; \ (clazz) = env-&gt;FindClass((str)); \ if (!(clazz)) &#123; \ return -1; \ &#125; \ if (b_globlal) &#123; \ (clazz) = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef((clazz))); \ if (!(clazz)) &#123; \ return -1; \ &#125; \ &#125; \ &#125; while (0)#define GET_ID(get, id, clazz, str, args) \ do &#123; \ (id) = env-&gt;get((clazz), (str), (args)); \ if (!(id)) &#123; \ return -1; \ &#125; \ &#125; while (0) 使用方式如下： 123GET_CLASS(clazz, "full/class/name", false); // 第三个参数后面解释GET_ID(GetMethodID, method, clazz, "method", "()V");GET_ID(GetFieldID, field, clazz, "filed", "I"); 此外这些 class, methodID， filedID 是不会变的东西（从逻辑上理解，类名，方法名， 成员名都不会在运行是更改），你可以缓存你查找好的引用作为全局变量，一方面可以提升 效率，另一方面也方便使用，因为你不需要每次都重新查找。个人的习惯是写一个结构体的 单例，在 JNI_OnLoad中查找并缓存这些实体，然后在JNI_OnUnload中清理缓存。 获取 instance前面提到，如果想要在 native 层调用 java 层的函数，你至少一个对象和一个成员方法， 上一小节讲述了如何获取成员方法，这一小节主要讲述如获取一个Java对象也就是 instance。获取的它通常是通过一下三种途径： native 代码参数instance的获取和JNIEnv的获取是类似的，如果你的方法是Java代码的native实现，那 么JNI会自动把调用该对象的实例传递给你。 12JNIEXPORT void JNICALLJava_xxxxx_nativeMethod(JNIEnv *env, jobject instance); 上面函数的第二个参数就是你需要的对象。你可以直接在这个函数中使用这个对象，比如： 12345JNIEXPORT void JNICALLJava_xxxxx_nativeMethod(JNIEnv *env, jobject instance) &#123; auto&amp; cached_fields = CachedFields::GetInstance(); // 参考上一小节 env-&gt;CallVoidMethod(instance, cached_fields.methodID)&#125; CallObjectMethod在instance存在的情况下，你也可以调用这个instance返回对象的方法来获取另一个 instance，比如： 1jobject obj_ = env-&gt;CallObjectMethod(instance, methodID, args); NewObject如果你没有这样的 instance 存在，你也可以直接创建一个java对象，调用 JNIEnv::NewObject即可。 1jobject obj_ = env-&gt;NewObject(fields.clazz, fields.ctrID); 这个函数需要 jclass 和构造函数的 jmethod（关于如何获取构造函数的引用可以查看上一 小节）。 引用的局部性和全局性所有传递到native函数中的参数和从JNI函数中返回的对象都是局部引用，比如： 1234JNIEXPORT void JNICALLJava_xxxxx_nativeMethod(JNIEnv *env, jobject instance) &#123; jobject obj_ = env-&gt;CallObjectMethod(instance, methodID, args);&#125; instance 和 obj_ 都是局部引用，这种引用一旦函数返回就会失效，即使你保存它们 也不会延长它们的生命周期。 123456789101112jobject instance_backup;JNIEXPORT void JNICALLJava_xxxxx_nativeMethod(JNIEnv *env, jobject instance) &#123; instance_backup = instance;&#125;NativeClass::NativeMethod() &#123; JNIEnvPtr env; env-&gt;CallVoidMethod(instance_backup, methodID); // 错误！！！！！&#125; 这条规则对于所有的 jobject 的子类（包括 jclas， jstring，jarray）都是适用的，如 果你想要引用保持有效，你需要调用JNIEnv::NewGlobalRef来获取一个全局的引用。 12jclass localClass = env-&gt;FindClass(&quot;MyClass&quot;);jclass globalClass = reinterpret_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(localClass)); 在你调用 DeleteGlobalRef 之前，这个引用都会有效。所以如果你想要保存一个局部引用 ，你可以像下面这样组织你的代码： 12345678910111213141516171819class Widget &#123;public: Widget(jobject instance) &#123; JNIEnvPtr env; instance_ = env-&gt;NewGlobalRef(instance); &#125; ~Widget() &#123; JNIEnvPtr env; env-&gt;DeleteGlobalRef(instance_); &#125; void Function() &#123; // 使用 instance_; &#125;private: jobject instance_;&#125;; 全局和局部引用的删除全局引用需要你手动调用 DeleteGlobalRef 来删除，但是局部的引用通常不需要。但是 需要注意的是，如果你使用了 AttachCurrentThread 绑定线程，那么在你调用 DetachCurrentThread 之前，你的局部引用都不会自动回收，这意味着如果你在一个循环中 创建了局部引用，你通常需要在循环内部删除掉它，因为系统通常只保证了 16 个局部引用 的 slot 。如果你需要超过 16 个，你就必须删除一些local引用，或者使用 EnsureLocalCapacity/PushLocalFrame 为局部引用预留更多的slot。 成对的使用函数JNI中有一些函数是需要成对的使用的，否则会有内存泄露，常用的有以下这些。 12345const char * GetStringUTFChars(jstring string, jboolean *isCopy);void ReleaseStringUTFChars(jstring string, const char *utf);NativeType *Get&lt;PrimitiveType&gt;ArrayElements(ArrayType array, jboolean *isCopy);void Release&lt;PrimitiveType&gt;ArrayElements(ArrayType array, NativeType *elems, jint mode); 前面这一组用来操作字符串，后面这一组用来操作数组。 参考本文中的内容主要参考： JNI Tips Java Native Interface Specification Contents]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 的业余时间安排]]></title>
    <url>%2F2017%2F01%2F02%2Fthings-todo-2017%2F</url>
    <content type="text"><![CDATA[要做的事情- 学会 Python，JavaScript， C我打算用周末的时间学习这些语言，每周一天半的假期，可以用于学习的时间是一天，53 周也就是 53 天的时间。如果算上国家法定假期 11 天，大概有 60 天左右的时间可以用来 学习这些语言。从紧迫性上来说， Python 和 JavaScript 优先与 C#，个人的规划大概是 25，25，10。 - 看完12本技术书籍这些书打算列在了书单里面。如果每天花费一个小时读书，大概一个月可以读一本。 - 学会欣赏音乐看完《聆听音乐》这门公开课。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之——《GNU Autoconf, Automake and Libtool》]]></title>
    <url>%2F2017%2F01%2F01%2Fautobook-note%2F</url>
    <content type="text"><![CDATA[之前看过Alexandre Duret-Lutz的《Using GNU Autotools》，对于 autotools 的使用并 不陌生，但是总是觉得自己对于这些工具的理解非常的模糊，很多时候都只是停留在知其然 不知其所以然的层面。这是我为什么读《GNU Autoconf, Automake and Libtool》这本书的 原因。这本书是我无意间在 google 上漫游的时候搜索到的，这本书我只看了前面几个章节 ，后面的内容过于索然无味，弃之。 autotool 的由来autotool 主要包含三个工具，autoconf、automake、libtool。这些工具之所以会出现和 unix 的发展有很大的关系。unix发展初期因为授权问题出现了大量的版本，而这些版 本中提供的库函数各不相同，却又大同小异。想要编写在各个版本中都可移植的程序非常困 难。为了解决这个问题才出现了autoconf这一类的软件，它们的本质实际上是帮你探测不 同的系统的属性，也就是告诉你哪个功能有，哪个功能没有之类的。这一点让我想起 JavaScript发展初期的时候遇到的同样的问题，各种浏览器支持的特性各不相同，想要写一 个跨浏览器的脚本同样非常困难。这从一个侧面反映出一个标准的重要性。 autoconf 可以帮助你写出款平台编译的程序，而automake则主要是帮你更好的完成跨 平台编译这件事情。编译需要用到各种编译器命令，因为不想手动的执行这些命名出现了 Makefile，又因为不想手动的编写Makefile出现了automake这类的工具，它让你可以 只提供源文件的名称便替你生成 Makefile，这也着实省下不少的麻烦。 程序库的发展过程中首先出现的是静态库，实际上只是.o的打包而已。后来出现了更高级 的动态库，可惜的是和之前一样，这些动态库在不同的系统上实现是不一样的，为了能够跨 平台的生成这些程序库，也就有了libtool这类的工具。 前面的介绍中，我使用的词语都是这类的，因为这种工具其实上出现过很多种，只是到了 最后慢慢的统一成了目前我们看到的这几个，他们最终合起来被称为autotools。 做一个实用主义者不要尝试去写一个可以运行在一切平台的configure脚本，实用为主，如果你只需要在 Linux上运行，又何苦去测试Windows才有的功能呢？ configure.in，configure.ac 结构通常应该按照下面的顺序编程一个configure.ac文件： 引用 AC_INIT，AM_INIT_AUTOMAKE，AC_CONFIG_HEADER 等等 选项，比如：AC_ARG_ENABLE 程序检测，比如：AC_CHECK_PROG 库的检测 头文件检测 typedefs 和 结构体的检测 函数的检测 输出：AC_OUTPUT]]></content>
      <tags>
        <tag>读书札记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年书单]]></title>
    <url>%2F2017%2F01%2F01%2Fbooklist-of-2017%2F</url>
    <content type="text"><![CDATA[去年这个时候，我给自己列了一份书单，可惜的是其中超过半数的书籍我都没有看完，尤其 是非技术类的书籍。参加工作后的自己少了很多的阅读时间，但是我还是希望自己可以坚持 看书的习惯。所以依旧打算给你开一份新年的书单，新年的书单以务实为主，只打算列出每 月一本的量，希望年底的时候，这些书籍都已经读完。 技术书籍 autobook Effective Morden C++ 像计算机科学家一样思考Python C++ 沉思录 编写可读代码的艺术 泛型编程与STL 代码整洁之道 STL源码剖析 高级 C/C++ 编译技术 重构 计算机程序的构造和解释 敏捷软件开发(原则模式与实践) 高效程序员的45个习惯:敏捷开发修炼之道 编程人生 UNIX 编程艺术 代码大全 图解TCP/IP 图解HTTP 非技术书籍 冰与火之歌：群鸦的盛宴 冰与火之歌：魔龙的狂舞]]></content>
  </entry>
  <entry>
    <title><![CDATA[读书札记之——《C++设计新思维》]]></title>
    <url>%2F2016%2F12%2F09%2Fmodern-cpp-design-note%2F</url>
    <content type="text"><![CDATA[这本书写于2001年，在国内这本书已经绝版了，非常可惜。15年后看这本书，我依旧惊叹于 作者的技巧，同时也更加深刻的理解什么叫做你永远都走在精通C++的路上。用火吻的话来 说就是，你什么都不懂。 递归之美这本书里面的大部分的内容设计模板元编程，而它的基石就是递归。很久以前看到过别人说 能用递归写出的来的程序尽量用递归来写，那时候还沉迷于C语言的高效性的我对这种观点 嗤之以鼻，现在想想是自己无知。 数学中非常伟大的一种概念叫做归纳，因为它可以用有限来表达无限，而在计算机的世界， 这种概念对应的就是递归，虽然递归无法无限下去。递归写出的来的算法通常是比较容易证 明它的正确性的，因为你有数学的基石。 这本书里面大量的用到了递归的思维，让编译器自动替我们生成代码，让我们能够兼得高效 和优雅。 设计模式我之前认真的读过《GoF》，自以为对于设计模式的理解应该比较到位，但是读完这本书之 后发现，原来我很多东西还是一知半解。这不仅仅是一本模板魔法书，它也是一本设计模式 的进阶指南。 以前我一直认为设计模式只能用指针来实现，现在想想自己真的什么都不懂。 总结如果你想了解C++11中的黑魔法的实现方式，请看这本书。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记只——《C++编程规范》]]></title>
    <url>%2F2016%2F12%2F08%2Fcpp-code-standards-note%2F</url>
    <content type="text"><![CDATA[有人说这本书很鸡肋，因为里面提到的很多东西深度不够的人看不懂，深度够了的人不看也 懂，所以没必要有单独出这样一本书。这种观点的可取之处在于，这本书确实需要一定的深 度才能体会作者的意思。我去年开始学C++，在看过《C++ Primer（评注版）》之后依陈硕 大大的建议买了这本书来看，结果一知半解，读到一半放弃了。那时候我以为是因为这本书 的中文翻译不好，读起来晦涩的缘故。后来我买了一本英文版回来，但是因为上班一直没时 间看，近来早起，抽空看完这本书。现在想来，中文版其实翻译的还是很不错的，作者的行 文风格偏莎士比亚，英文功底不够读起来其实很费劲。 作者是段子手编码规范本是比较枯燥的内容，但是作者非常幽默。 内部状态暴露给别人就像给门上锁却把钥匙留在了锁上面。 使用static_cast来而不是dynamic_cast来强转指针，就像为了每年省下9毛钱电费， 甘愿冒摔断腿的风险关着灯上楼梯。 这一类的比喻比比皆是。所以即使这里面的内容你都清楚，你也该读一读这本书，看看同一 个概念，不同的人是怎么解释的。 最佳实践的汇总的确，如果你读过所有的Effective系列的书，也读过所有Exceptional系列的书，了解设计 模式，那么这本书里面的很多内容你的确都是知道的。这本书的特点在于它的短小，像是一 个备忘录或者是是一个小抄，放在手边随时翻一翻。这本书的另一种用法如作者所言是作为 代码审查的 check list。 重点设计这本书和很多其他书不同的地方在于，其实它讲了很多关于设计的内容。比如：职责规范， 继承与组合，模块划分，错误处理机制等等。和google cpp coding style[GCCS]最大的 区别估计就在于此。[GCCS] 重点讲代码编写的规范，而本书重点讲代码设计的规范。 个人认为两者都必不可少，但是后者重要一些。 最有价值的一条作者对于每一章节都会自己推荐一条最有价值的条款。一千个人眼中一千个哈姆雷特，对我 来说本书最有价值的条款是第32条，因为它解决了困扰我已久的问题，一个类到底应该怎么 去设计，答案老生常谈：it depends。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 智能指针的常见问题]]></title>
    <url>%2F2016%2F12%2F05%2Fcpp-smartptr-faq%2F</url>
    <content type="text"><![CDATA[C++ 之父说 C++11 像是一门新的语言，很大一部分得益于标准库在 C++11 中的重要扩充， 而新的智能指针属于其中至关重要的一点。新的智能指针shared_ptr和unique_ptr比起 auto_ptr要好用很多，但是依旧存在一些比较容易踩坑的地方，本文罗列了 stackoverflow 上关于智能指针的一些常见问题。 使用 shared_ptr 还是 unique_ptr多继承和智能指针Using shared_ptr with multi inheritance class 指向 this 的智能指针[std::shared_ptr of this][this] [this]: http://stackoverflow.com/questions/11711034/stdshared-ptr-of-this 为什么库中比较少用智能指针[Why do C++ libraries and frameworks never use smart pointers?][not-in-lib] [not-in-lib]: http://stackoverflow.com/questions/10334511/why-do-c-libraries-and-frameworks-never-use-smart-pointers unique_ptr 无法使用类的前缀声明]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 vim 的 UltiSnips 插件生成符合 google 规范的头文件保护宏]]></title>
    <url>%2F2016%2F12%2F03%2Fvim-ultisnipt-google-c-cpp-header-gurad%2F</url>
    <content type="text"><![CDATA[google 的 cpp style guide 中推荐把头文件保护宏定义成如下格式 1&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ 目前大部分的头文件保护宏生成工具都没有办法按照路径来生成这个宏。在 Vim 的 UltiSnips 插件的默认 Snippet 代码中可以使用 once 来生成类似于下面这样的头文件 保护宏： 1&lt;FILE&gt;_&lt;RANDOM_CHARS&gt;_H 这种默认的行为已经能非常好的避免头文件多重包含问题了，但是从美观性和规范性上来说 ，google 的标准写法略胜一筹。幸运的是 UltiSnips 允许你定义自己的 snippet。本文介 绍一种通过自己编写 snippet 的方式生成符合 google 规范的头文件保护宏。 思路总的来说，算法非常简单，能够生成这种保护宏的前提是你必须有一个项目的根目录（我的 实现中使用了git的根目录，因为日常开发中大部分项目都是使用git作为版本控制器），然 后得到当前工作目录和文件名，之后通过字符串的处理得到基于项目路径的头文件保护宏。 总的来说，你需要： 项目根目录 当前工作目录 当前文件名 基础知识要得到这三个名字，单靠 UltiSnips 本身会比较困难，幸运的是 UltiSnips 支持使用 Python 编写 snippet，本文介绍 snippet 使用了 Python 进行编写。关于如何编写 snippet 以及如何在 snippet 中嵌入 Python 代码 Vimcasts 中有三个非常 棒的视频，这里不再重复。 Meet UltiSnips Using Python interpolation in UltiSnips snippets Using selected text in UltiSnips snippets 获取项目根目录你可以通过执行 git rev-parse --show-toplevel 这条命令得到 git 项目的根目录。在 Python 中我们可以使用 subprocess 的 check_output 方法执行系统命令。 1234import subprocesscmd = 'git rev-parse --show-toplevel'root = subprocess.check_output(cmd, shell=True) 当然如果你不在一个 git 目录中，执行 git rev-parse --show-toplevel 会出错，而使 用 check_output 会抛 CalledProcessError 异常。处理异常后代码如下： 123456789import subprocessdef get_project_root(): """Find the git root of project.""" cmd = "git rev-parse --show-toplevel" try: return subprocess.check_output(cmd, shell=True) except subprocess.CalledProcessError: return None 获取当前的工作目录和上面的方式一样可以通过 subprocess 执行 pwd 命令得到结果。 12def get_pwd(): return subprocess.check_output("pwd", shell=True) subprocess 返回值的处理需要注意的是，subprocess 返回的并不是 str，而是 byte string 为了能够得到 unicode string 我们需要对返回值做一个额外的转换。 123root = get_project_root()if root: root = root.decode('utf-8').rstrip() 上面做了一个额外的 rstrip 操作用来移除返回值末尾的 \n 当前目录相对于项目根目录的路径1path = pwd[len(root) + 1:] 当前文件名UltiSnips 本身提供了这个名称，所以不需要我们做额外的处理，直接使用 snip.fn 就可以了。 把路径转换成宏定义直接把路径中的 / 转换成 _ 之后拼接，转大写即可。 12345678import redef replace_nonalphnum(token, replacement): return re.sub(r'[^A-Za-z0-9]+', replacement, token)tokens = [replace_nonalphnum(token, '_') for token in (path, snip.fn)]snip.rv = '_'.join(tokens).upper() + '_' 完整代码你可以在我的配置文件仓库中找到完整的代码。仓库中的代码，对于找到项目根目 录的情况做了兼容，回退到之前使用随机数后缀的方式。 参考 Ultisnips Convert bytes to a Python string Find the root of the git repository where the file lives]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Doxygen 生成文档注释]]></title>
    <url>%2F2016%2F11%2F20%2Fdoxygen-usage%2F</url>
    <content type="text"><![CDATA[全文是个人关于注释的观点，很可能有误，不想误人子弟，请慎重考虑其中的任何一个观点 ，欢迎拍砖。 注释不是越多越好刚开始学编程的时候，总是会有一些老鸟程序员告诉我，优秀的程序员都习惯给自己的代码 加上大量的注释，这一点甚至有很多的老师都是这么教的，以至于有很长一段时间我都对这 个观点深信不疑。 第一个让我这个观点产生怀疑的人是“林纳斯·托瓦兹”，有一段时间疯狂的迷恋操作系统的 内核，而我尝试读一些源码的时候发现，大神们写的代码其实并不会有太多的注释，但是他 们的代码依旧很漂亮。 第二个让我对于注释越多越好的观点产生怀疑的人是C++之父，忘记在他的那一本书中看到 ，注释如果和源码不同步比没有注释更糟糕。 注释是你的源码的一部分，只要你选择写下一行注释，你就需要担负起维护它的责任。我们 经常会在重构一段源码的时候忘记给更改的地方的注释加上相应的修改。最后留给源码的阅 读者无尽的苦恼这段代码怎么就能实现注释里面说的这个功能呢。 代码的可读性远远比注释更重要所有的程序员都应该像白居易学习，把你的代码写得简单明了，逻辑清晰。写一段清晰易懂 的代码，远比写一段晦涩难懂的代码加上一段晦涩难懂的注释要好的多。所以在你打算写下 一段注释之前先看看你的代码，命名是否规范啊？逻辑是否清晰呢？嵌套层次是否合理呢？ 函数是否够精简呢？ 如果以上的问题你的答案都是“是”，而你依然觉得代码相对难懂，那就加上一些简洁的注释 吧，同时记得在更新代码的时候，更新你的注释。 接口的注释本文提到的接口指的函数签名，包括普通函数、成员函数等 以上这些论述只是针对了源码的注释，个人认为接口的注释还是需要尽可能详细的，因为接 口本身通常都是比较稳定的，此外接口本身能够提供的信息也相对较少，而接口作为模块之 间交互的协议规范，不应该有任何模棱两可的东西，需要详细、准确。 接口的文档中应该包括哪些内容个人认为以下信息是需要出现接口的文档中的： 接口的功能。 接口的前置条件，通常是指输入的参数需要遵循的条件。 接口的后置条件，通常是指接口的返回值，或者说接口的side effect。 接口的注意事项，如果有的话，应该说清楚调用该接口需要特别注意的地方。比如会抛些 什么异常。 使用 Doxygen 生成 C++ 代码文档Doxygen可以用来从C++的源码注释中抽取文档，目前可以说是C/C++的文档注释的实际标准 。它的使用非常简单，只需要你按照特定格式编写注释，便可以通过一条命令生成各种格式 的文档（html, rtf, latex, xml, man等）。所以关于它的使用我们需要知道两件事情：第 一，怎么编写注释；第二，怎么生成文档。 怎么编写注释嗯，我不是怀疑你不会使用//或者/**/，我们这里关心的是编写Doxygen能够识别的 注释。 注释块你可以有多种方式编写一个Doxygen注释块，我只使用其中的 JavaDoc 风格的注释块儿： 123/** * comment text here */ 标记（命令）在一个注释块中，你除了可以写一些文字之外，还可以使用一些特殊的标记，比如最常用的 param标记。这种特殊标记，官方称为Special Commands，你可以在这里 中查到相关的信息，如果你英文不够好，可以参考这个简单的翻译，只可 惜这篇翻译烂尾，只有一部分翻译。网上另有有一份《Doxygen 中文手册》可以参考。 一个标记，你可以有两种书写方式 \param 或者 @param 个人比较喜欢使用后一种，因 为它和 JavaDoc 的方式一样，比较统一。 1234/** * @param url the media location to play */bool Play(const std::string&amp; url) Doxygen给我们提供了大量的特殊标记，让我们可以给注释加上语法本身无法传达的一些 信息。 个人认为这些标记最有效的学习方式是看别人是怎么使用的，目前为止我见过最好 的注释文档是FFMPEG的注释文档，这也是我平常学习的时候参考的最多的一份 文档。它的在线版Doxygen文档在墙内访问比较慢，建议下载源码自行生成（在源码的根目 录下执行 doxygen doc/Doxyfile）。下面总结了一些个人认为比较重要的标记。 @brief标注用来作为简单的功能描述，这个标记其实可以不写。比如： 1234/** * @brief Play the media at url. */bool Play(const std::string&amp; url) 可以直接写成 1234/** * Play the media at url. */bool Play(const std::string&amp; url) @param标注参数，比如上文中的例子： 这个命令可以有[in]、[out] 两个属性，表示该参数是输 入参数还是输出参数。 123456/** * @param[out] dest The memory area to copy to. * @param[in] src The memory area to copy from. * @param[in] n The number of bytes to copy */void memcpy(void *dest, const void *src, size_t n); @return标注返回值。返回值是一个接口非常重要的内容，很多人会忽略它的文档说明。 1234/** * @return true on success, false otherwise */bool Play(const std::string&amp; url) @throw @throws @exception异常属于接口的一部分，Java 语言通过异常说明符把这一点内置到了语言当中，C++曾经也 有异常说明符，但是后来被废弃（因为没有办法高效的实现，可参考《C++编程规范》一书 的Item75）。无论语言本身是否支持，异常都应该是接口的一部分，没有人愿意调用一个不 知道会抛什么异常的函数。 1234/** * @throw std::out_of_range if idx &gt;= vector.size() */bool vector::at(size_t idx) @warning接口容易出错的地方。 1234/** * @warning application may crash if dest or src is null */void memcpy(void *dest, const void *src, size_t n); 使用这个标记标注的文字会以一个红色的标记出现最终的文档中，起到非常好的警告作用。 @note标注需要特别注意的地方，可以用来标注接口的前置条件： 1234/** * @note do nothing if url is invalidate */bool Play(const std::string&amp; url) @deprecated这个标记对于C/C++来说是非常有用的，因为语言本身没有提供这样的特性，所以文档中的 说明就显得非常重要了。 12345/** * @deprecated this function is deprecated, since it has the same effect of callling SeekTo(from) after Play(url). */bool Play(const std::string&amp; url, size_t from) @see @sa相当于 JavaDoc 的 see also 功能。 @since标记接口的版本号，Android 中有大量的接口是在不同的版本中逐渐添加进去的，对于库来 说这个比较比较重要。 工具推荐这些标记如果要纯手写的话胡非常麻烦，通常你都可以在你喜欢的编辑器或者IDE中找到相 应的插件。比如Vim的插件vim-scripts/DoxygenToolkit.vim，用的工具不重要，重要的 使用同一种编写风格。 如何生成文档使用特定的格式编写完注释之后，你可以使用doxygen命令生成特定格式的文档（前提是 你已经安装了Doxygen，它是开源跨平台的，所以你急本上可以在任何一个平台使用它）。 生成文档分成三个步骤： 生成配置文件 修改配置文件 生成文档 生成配置文件这个步骤很简单： 1doxygen -g &lt;config-file&gt; 如果你不提供文件名字（config-file），你会得到一个叫做Doxyfile的配置文件。通过 修改配置文件，你可以控制doxygen的最终输出接口。 所有的选项都是以键值对的形式配置的，你直接使用你最喜欢的文件编辑器修改 Doxygenfile即可，当然你可以使用图形界面工具Doxywizard来完成编辑。Doxygen提供 了非常多的可配置选项，通常大部分的值你直接使用默认值就可以了，下面这里列出了其中 比较重要的一些配置选项以及它们的含义。 修改配置文件Doxyfile中的的配置选项非常的多，大部分情况下使用默认值就可以了，每一个配置选项 中之前会有一段注释，有时间可以通读一遍了解各个选项的作用。这些选项中有一些需要特 别注意的在学习用doxygen生成源码文档一文中已经提到了这里就不再重复了，这里 补充几个没有提到的。 EXAMPLE_PATH例子代码的位置，你可以为你的API提供一些demo例子，指定这个配置会让你的接口描述下 面多出一栏 Example，Doxygen会自动查找这个接口在demo中出现的位置，给出链接，方便 用户学习^1。 REFERENCED_BY_RELATION REFERENCES_LINK_SOURCE如果你想要Doxygen生成的文档能够方便的跳转，把这两个选项设置为YES. 如果不想自己动手配置这些选项，你可以考虑下载一份FFMPEG的配置选项，在它的基础上去 掉你不需要的功能就可以了。 #### 配置文档的输出位置 生成文档修改完成配置文件之后，你就可以使用下面的命令生成文档： 1doxygen /path/to/Doxyfile 如果你配置了html输出，你最终会得到一个html文件夹（在todo配置的文件夹下面），打 开里面的 index.html 就可以开始浏览文档了。 参考 Doxygen Document 学习用 doxygen 生成源码文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[在 MSVC 中使用 MinGW 编译的 C++ 库的方式]]></title>
    <url>%2F2016%2F11%2F20%2Fmingw-with-msvc-cpp%2F</url>
    <content type="text"><![CDATA[这篇文章介绍一种能让 MSVC 使用 MinGW 编译的 C++ 库的方式。（这里只讨论C++库的共 享，MinGW编译出来的C库好像使用可以直接在MSVC中使用的。） 为什么使用这种方式有时候你需要编写跨平台的back-end程序，由不同的系统平台去实现fore-end。如果使 用 GCC，你可以通过交叉编译得到适用于不同平台的back-end 库。为了实现 Windows 的 GCC 交叉编译你需要用到 MinGW，而 Windows 上很多人使用 MSVC 编写程序，包括你的 fore-end 程序。这样依赖你就面临了需要让 MSVC 使用 MinGW 编译的库的问题了。 MinGW 输出的文件类型静态库如果你编译的是静态库，你会得到 libxxx.a 如果你编译的是动态库，你会得到 libxxx.dll.a libxxx.dll .dll.a 是动态库的导出库，在链接过程中会使用到，所以你需要使用 #pragma comment(lib, &quot;libxxx.dll.a&quot;) 这种方式在fore-end中使用它完成编译， libxxx.dll 在运行中需要使用，你可以把他放到输出的bin文件的同一目录或者系统动 态库查找路径的目录中。 使用方式libxxx.a这种类型的 C++ 库是没有办法使用的，因为 MSVC 使用静态库格式是 libxxx.lib。 .a 和 .lib 格式的C++库内部结构不一样，直接使用会报错说格式不 对。 libxxx.dll这种类型的动态库也没有办法直接使用。MinGW使用GCC编译器，而MSVC 使用 的是微软的编译器 CL。这两种方式对于 C++ 的 name mangling 的实现方式不一样。所 以你没有办法直接在 MSVC 上使用 MinGW 编译的库文件，因为在最终链接在一起的时候， 同一个名字会因为不同的name mangling 而变成不同的名字，最终导致无法链接成功。 幸运的是，C++兼容C代码，而C的名称是可以不进行name mangling的，所以为了能够使得 MSVC能够使用MinGW编译的C++库，你需要给你的库添加一层C接口，并给这些C接口加上： extern &quot;C&quot;修饰使得这些库拥有C链接属性。可参考stack ovferflow上的一些答案 ^1^3 参考]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 的单元测试工具 —— Catch]]></title>
    <url>%2F2016%2F08%2F22%2Fcpp-unit-test-catch%2F</url>
    <content type="text"><![CDATA[如果你平常使用 Java 语言做开发，当你听到单元测试工具的时候，你很可能马上会想起 JUnit。作为一名C++软件工程师，当我第一次打算给我的程序做单元测试的时候，我的第一 想法是：有这样的工具吗？经过一段时间的搜索之后，我的反应变成了：我该用哪一个？ 我在学校的时候，很少听说C++的单元测试工具，以至于我一直认为这样的工具是不存在。 后来慢慢的发现我们可以选择的远比你想象中的要多得多：Catch, Boost.Test, UnitTest++, lest, bandit, igloo, xUnit++, CppTest, CppUnit, CxxTest, cpputest, googletest, cute。 那我们应该使用哪一个呢？如果你在 Google 里面搜索：best c++ unit testing framework。头两条，一条是 stackoverflow 的问答，另一条是 reddit 的问答 。这两个问题都指向同一个单元测试框架：Catch。 为什么使用 Catch在 Catch 的官方文档中有一篇：Why do we need yet another C++ test framework? 有兴趣的可以去看看。对我来说，它最吸引我的地方主要是： 几乎不用配置，它是一个单头文件的测试框架，压根不要什么额外的配置就可以使用 语法非常简单明了，用它写的测试代码和自然语言一样易懂。 如何使用它Catch 是单头文件库，你直接 #include “catch.hpp” 它就可以了。然后你就可以像下面 这样写测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142SCENARIO( &quot;vectors can be sized and resized&quot;, &quot;[vector]&quot; ) &#123; GIVEN( &quot;A vector with some items&quot; ) &#123; std::vector&lt;int&gt; v( 5 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); WHEN( &quot;the size is increased&quot; ) &#123; v.resize( 10 ); THEN( &quot;the size and capacity change&quot; ) &#123; REQUIRE( v.size() == 10 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; &#125; WHEN( &quot;the size is reduced&quot; ) &#123; v.resize( 0 ); THEN( &quot;the size changes but not capacity&quot; ) &#123; REQUIRE( v.size() == 0 ); REQUIRE( v.capacity() &gt;= 5 ); &#125; &#125; WHEN( &quot;more capacity is reserved&quot; ) &#123; v.reserve( 10 ); THEN( &quot;the capacity changes but not the size&quot; ) &#123; REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; &#125; WHEN( &quot;less capacity is reserved&quot; ) &#123; v.reserve( 0 ); THEN( &quot;neither size nor capacity are changed&quot; ) &#123; REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); &#125; &#125; &#125;&#125; 这几乎是不需要解释就可以理解的读懂的代码。这种测试方式称为 BDD（Behaviour Driven Development），是最新的一种测试方式，它强调的是“行为”而不是“测试”，有兴趣可以看 看这篇文章。 如果你习惯传统的TDD测试，你可以像下面这样写测试代码： 1234567891011121314151617181920212223242526272829303132TEST_CASE( &quot;vectors can be sized and resized&quot;, &quot;[vector]&quot; ) &#123; std::vector&lt;int&gt; v( 5 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); SECTION( &quot;resizing bigger changes size and capacity&quot; ) &#123; v.resize( 10 ); REQUIRE( v.size() == 10 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; SECTION( &quot;resizing smaller changes size but not capacity&quot; ) &#123; v.resize( 0 ); REQUIRE( v.size() == 0 ); REQUIRE( v.capacity() &gt;= 5 ); &#125; SECTION( &quot;reserving bigger changes capacity but not size&quot; ) &#123; v.reserve( 10 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; SECTION( &quot;reserving smaller does not change size or capacity&quot; ) &#123; v.reserve( 0 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); &#125;&#125; 实际上这两种方式是等价，SCENARIO 只是 TEST_CASE 的别名，GIVEN、WHEN、THEN 最终 也是 map 到 SECTION 上面的。这其中的差异只是存在于测试的思维不同而已，你完全可以 根据自己的喜好使用你最喜欢的方式即可。 SECTION 的执行顺序上面的代码很清晰易懂，不过有一个地方需要注意，那就是 SECTION 的执行方式。在上一 小节的代码中，TEST_CASE 中有 4 个 SECTION，它们并不是单纯的顺序执行关系。在第 一个 SECTION 执行完成之后，会重头开始执行并跳过已经执行过的 SECTION。也就是说上 面的代码的执行路径大概是这样的（去掉了 SECTION 宏之后）： 12345678910111213141516171819202122232425262728293031323334353637383940414243// SECTION 1std::vector&lt;int&gt; v( 5 );REQUIRE( v.size() == 5 );REQUIRE( v.capacity() &gt;= 5 );v.resize( 10 );REQUIRE( v.size() == 10 );REQUIRE( v.capacity() &gt;= 10 );// SECTION 2std::vector&lt;int&gt; v( 5 );REQUIRE( v.size() == 5 );REQUIRE( v.capacity() &gt;= 5 );v.resize( 0 );REQUIRE( v.size() == 0 );REQUIRE( v.capacity() &gt;= 5 );// SECTION 3std::vector&lt;int&gt; v( 5 );REQUIRE( v.size() == 5 );REQUIRE( v.capacity() &gt;= 5 );v.reserve( 10 );REQUIRE( v.size() == 5 );REQUIRE( v.capacity() &gt;= 10 );// SECTION 4std::vector&lt;int&gt; v( 5 );REQUIRE( v.size() == 5 );REQUIRE( v.capacity() &gt;= 5 );v.reserve( 0 );REQUIRE( v.size() == 5 );REQUIRE( v.capacity() &gt;= 5 ); 测试代码的执行入口在C++中任何代码需要执行，都需要通过 main 函数这个入口，测试代码也不例外。Catch 不需要我们自己编写 main 函数去调用这些测试代码。它提供了默认的 main 函数入口，你 只需要在（而且仅在）一个文件中加入下面的配置宏： 12#define CATCH_CONFIG_MAIN#include &quot;catch.hpp&quot; 最佳实践最佳实践是单独用一个文件放这两行代码，把测试代码写在其他的文件中。 之所以这样做是因为Catch是单头文件库，这意味着它里面的内容会最终出现在所有的包含 这个头文件的编译单元中。如果我们把测试代码和上面两行代码放在一起会导致每次编译测 试代码的时候都需要编译 Catch 的内核，这会导致编译速度非常非常的慢。如果把两者分 开，Catch 的内核只需要在一个文件中编译一次（因为 Catch 内部做了判断，如果内核编 译过了是不需要再次编译的，即使你在多个文件中使用了 #include “catch.hpp”）。这个 文件的编译速度相对较慢，但是这个文件不会改动所以整个开发周期中它只需要编译一次， 而不断更新的测试代码的编译速度会因此快很多。 命令行参数Catch 提供的这个 main 函数实现的另一个强大的功能是丰富的命令行参数，你可以选择执 行其中的某些 TEST_CASE，也可以选择不执行其中的某些 TEST_CASE，你可以用它调整 输出到 xml 文件，也可以用它从文件中读取需要测试的用例。这些命令的具体使用请参考 Catch 的官方文档Command line一节。 TAG需要注意的是，这些强大的命令行大多数是基于 TAG 的，也就是 TEST_CASE 定义中的第 二个参数。 1TEST_CASE( &quot;vectors can be sized and resized&quot;, &quot;[vector]&quot; ) 上面的定义中 “[vector]” 就是一个 TAG，你可以提供多个 TAG： 1TEST_CASE( &quot;D&quot;, &quot;[widget][gadget]&quot; ) &#123; /* ... */ &#125; 这样的话你可以在命令行中根据 TAG 去选择是否需要执行该 TEST_CASE。比如： 1./catch &quot;[vector]&quot; // 只执行那些标记为 vector 的测试用例 此外你还可以使用一些特殊的字符，比如 [.] 表示隐藏。[.integration] 则表示默认 隐藏，但是可以在命令行中使用 [.integration] 这个 TAG 执行。其他的一些特殊的字符 请参考官方文档的Test cases and sections一节 123./catch // 默认不执行 integration./catch &quot;[.integration]&quot; // 使用 TAG 执行 integration 提供自己的 main 函数入口如果你不喜欢上面的处理方式，想要自己提供 main 函数，你可以使用 CATCH_CONFIG_RUNNER，具体的细节请查看官方文档中的 Supplying main() yourself一节。 其他内容其实 Catch 本身相对来说比较简单，不需要太多其他的学习，大部分的用法是非常的直观 的，看完它的官方教程之后基本上可以上手了，然后有时间慢慢的读一读它的官方文 档集合]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GNU 的自动构建工具 autotools 小结]]></title>
    <url>%2F2016%2F07%2F31%2Fgnu-autotools-note%2F</url>
    <content type="text"><![CDATA[自动构建工具由来已久，使用的最为广泛的有两种，GNU 的 autotools 和 llvm 的 cmake 。这篇文章主要对于 autotools 做一个简单的小结，有机会升入学习 cmake 的 话，再补 充。 书籍推荐这方面的书籍，我只看过一本，Alexandre Duret-Lutz 的《Using GNU Autotools》。严 格来说这不能算是一本书，它是一个PPT，内容非常浅显易懂，推荐给有兴趣深入了解该技 术的人。 最主要对两个工具autotools 并不是一个软件的名称，它是多个软件对集合，其中最重要对两个软件是 autoconf 和 automake。 我们可以得到什么通过自动构建工具，我们最终会得到两种东西：config.h 和 Makefile 前者是编译环境相 关的宏定义，而后者是完成软件编译的编译脚本。 如何得到这些这两种文件这两种文件都是通过固定的模板加上具体的配置得到，config.h 的模板是 config.h.in 而 Makefile 的模板文件是 Makefile.in。而从模板到具体文件输出要做的就是我们熟悉 的 ./configure。 12config.h.in + configure ==&gt; config.hMakefile.in + configure ==&gt; Makefile 那么这两个模板和 config.h.in 和 Makefile.in 又是如何得来的呢？自动构建的神奇之 处就在于自动生成，而这两个模板文件正是自动生成而来。完成这一操作的命令是 autoreconfig。 autoreconfigautoreconfig 是一条非常神奇的命令，它是整个 autotools 中最为重要的命令之一 。大 多数的情况下，你只需要简单的 autoreconfig –install 就可以完成大部分的工 作。 当然 autoreconfig 再强大也不可能强大的到无中生有，它依旧需要一些输入，这也就是 需要我们自己编写的两个文件：configure.ac 和 Makefile.am。实际上，configure.ac 这个文件会产生两个输出，configure 和 config.h.in 而 Makefile.am 则会产生 Makefile.am.in 12configure.ac + autoreconfig ==&gt; config.h.in, configureMakefile.am + autoreconfig ==&gt; Makefile.in configure.ac 与 宏我们写在 configure.ac 里面的东西，大部分都是大写字母，之所以这样写是因为其实其 中的大部分内容都是宏，而宏的命名规范通常都是使用大写字母。 实际上Autoconfig 的核心是 autom4te, 它是 M4 宏处理器的驱动。所以实际上我们 写在 configure.ac 中的宏最终的处理者是 M4，我们可以在 configure.ac 中使用 为M4编写的 宏代码。比如你可以在Autoconfig Archive 下载 ax_cxx_compile_stdcxx_11.m4和 ax_cxx_compile_stdcxx.m4代码，放到项目根目 录下的m4子目录下面，然后在 configure.ac中使用AC_CONFIG_MACRO_DIR([m4])引入该文件。这样就可以在你的 configure.ac 中使用 1AX_CXX_COMPILE_STDCXX_11() 来检测你的编译器是否支持 C++11，并在支持 C++11 的时候给你的编译器加上类似 -std=c++11 这样的编译选项]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 的装机必备软件]]></title>
    <url>%2F2016%2F05%2F17%2Flinux-toolset%2F</url>
    <content type="text"><![CDATA[使用Linux的一大乐趣在于尝试各种发行版本，所以我总是会不断的重装系统，伴随重载 系统而来的是系统的配置。在日常使用中，我积累了很多装机必备的工具，罗列在下面， 推荐给大家。 autojump你可以做一个有趣的实验，使用下面这条命令找出你用的最多的 10 条命令： 123history | awk '&#123;CMD[$2]++;count++;&#125; END &#123; for (a in CMD )print CMD[ a ]" "CMD[ a ]/count*100 "% " a &#125;' | grep -v "./" | column -c3 -s " " -t |sort -nr |nl | head -n10 在我最新安装的系统上，我得到的结果是： 12345678910 1 137 23.8261% ls 2 117 20.3478% vim 3 94 16.3478% cd 4 43 7.47826% git 5 34 5.91304% sudo 6 27 4.69565% hexo 7 10 1.73913% clear 8 8 1.3913% tmux 9 8 1.3913% cp10 6 1.04348% rm cd 命令是我使用频率排名第三的命令。但是 cd 命令的使用并不是非常的方便，尤其 是在切换到层次相对较深的目录中的时候，你需要进行大量的输入工作。但是在大部分的 时候，你会发现自己常用的目录其实就那么几个。在 bash 中你可以使用 cd - 切换 到你最近使用那个目录，在 zsh 中你可以使用 cd - 补全出你最近使用过的目录，但 是这些目录在你关闭终端之后会清除。 autojump 这款神器的口号是 A cd command that learns，它会记录你最近去过的那 些目录，然后通过简单的输入就可以跳转到你的历史路径，极大的提高你的效率。 build-essential大部分做开发的人会需要安装这个包，其中包含了做开发时编译所必须的软件包。使用下 面命令安装： 1sudo apt-get install build-essential clang-format代码格式化的神器，支持各种各样的代码规范，个人使用它完成 Google C++ Coding Style 规范的代码格式化。在 Ubuntu 中你可以安装多个版本的 clang-format 我通 常使用最高版本。安装完成之后，推荐在 /usr/bin/ 下面建立一个名为 clang-format 的软连接。 12cd /usr/binln -s clang-format clang-format-3.6 你可以使用 -dump-config 选项结合 -style 选项得到一个符合某种规范的配置文件 。 1clang-format -style=google -dump-config &gt; .clang-format 你可根据得到的 .clang-formt 文件进行修改得到你自己喜欢的格式。此外，推荐在你 熟悉的编辑器中安装这个软件的额外插件（如果你使用的编辑器不支持插件，赶紧换！！ ！），我使用的 vim 插件是 google/vim-codefmt。 cmake非常出色的代码自动构建工具，你可能不用，但是很多项目使用到了它，你通常总会在某 个时候用到它。 ctags使用 vim 浏览代码，查找函数，生成 outline 的时候都会用到它。 fzf如果你经常使用 find 这样的工具查找文件，我推荐你使用 fzf，这是一个文件查找 的模糊匹配工具，如果你使用过 vim-ctrlp 或者 sublime 中的相关功能，你一定会爱 上这个工具。你可以用它过滤文件，过滤历史记录，过滤目录文件等等，非常好用。 安装完成之后，你可以试试 Ctrl-T，Ctrl-R， Alt-C 这些快捷键来感受一下它的 强大。 此外 fzf 是一个可扩展的框架，你可以编写自己的想要的功能。 git不解释 hexo当你在为知笔记、evernot和有道云笔记之间纠结的时候，我推荐你使用 hexo + github pages 搭建自己的博客网站，把你的点点滴滴都记录下来，我的这篇博客这就是 这样记录下来的。 oh-my-zsh安装完 zsh 之后做的第一件事情是安卓 oh-my-zsh，它是 zsh 配置的终结者。 silversearcher-ag《人月神话》的作者告诉我们：没有银弹。嗯，虽然我不知道ag取名silversearcher 是否有充当银弹的自信，但是它确实很快。 tmux常年和终端打交道的用户，最需要的功能之一就是分屏。tmux 这款软件一定会让你爱不 释手。 tmux 和 vim 的组合可以说是天下无双的。如果你把 zsh 也组合进来，它们还有另 一个名字叫做文本三剑客。 vim我不想争论它是不是世界上最好的编辑器，至少对我来说，它是最好的，没有之一。 zealdoc当你需要在不同的开发语言中切换，当你需要在不同的库见徘徊，当你生活在墙内的时候 ，你一定会需要这款软件 zealdoc，一个离线的文档查看器，你用到的大部分文档在其 中都有收录。这个软件是 Mac 中的 dash 的克隆版本。 zsh从操作系统出现到现在，命令行解释器这个软件被一次又一次的重写，各种版本的shell 层出不穷。目前大部分发行版本默认安装的是 bash，但是它在只能补全方面确实做的不 够好。近些年出现了专注于高用户友好度的 fish，我也用过，确实非常不错，但是个人 认为在成熟度上还有待提高，估计再发展一段时间，它会成为 zsh 最强大的对手。 目前来说，在兼容性、成熟稳定性、易用性上面都达到很好的平衡的是 zsh，它的成功 估计主要归功于 oh-my-zsh 这个社区驱动的配置项目。zsh + oh-my-zsh 可以说是 短期内无法超越的高峰。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一个Vim插件 —— ctrlp-header]]></title>
    <url>%2F2016%2F04%2F28%2Fvim-plugin-ctrlp-header%2F</url>
    <content type="text"><![CDATA[这是我自己编写的第一个Vim插件，写这个插件的原因是在编写 C++ 程序的时候，引入 头文件需要离开当前位置，跳到文件头部，找到合适位置插入 #include &lt;xxxx&gt; 这样的 语句，然后返回到原本编辑的位置继续编辑。这是一个重复性非常强的操作，所以我想尝 试编写一个插件来完成这个操作。jetbrains系列的IDE中有一个 Alt-Enter自动引 入头文件的功能，我最终想要实现的效果就是这个样子。 本人平时是 CtrlP 这个插件的重度用户，也知道它可以进行扩展，所以自己参照 ctrlp-funky 中的代码写了这个 ctrlp-header 插件。 目前的功能非常简单，效果图如下： C++ 文件 C 文件 基本原理这个插件非常简单，目前的功能非常粗糙，只是从 en.cppreference 中获取标准库中的 头文件列表，提供给 ctrlp，当用户选择了某一个头文件的时候，在当前的 buffer 中 找到合适的位置插入 #include &lt;header_user_selected&gt; 就可以了。 后续工作这个插件还有很多工作没有完成： [ ] 支持用户编写的头文件 [ ] 通过记录用户曾经的操作来提供最佳的候选项目 [ ] 支持语义解析，准确的提供头文件]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《Exceptional C++ Style》]]></title>
    <url>%2F2016%2F04%2F25%2Fexceptional-cpp-style%2F</url>
    <content type="text"><![CDATA[这本书的中文名叫做《C++编程剖析》，从中文名字中你很难发现这本书和《Exceptional C++》以及《More Exceptional C++》是同一个系列的书（萨特的《Exceptional》系列） 。这本书和前两本是一脉相承的，只是感觉作者的写作风格（或者是译者的翻译风格）和 前两本有略微的不同。三本书依次读下来会发现作者的写作风格越来越幽默。 这三本书是萨特的Guru of the Week的打印版本，基本上的内容似乎都可以在 GOTW 上面找到，其中#1 - #30基本上出现在《Exceptional C++》一书中，#31 - #62出现 在《More Exceptional C++》一书中，剩余的大部分则出现在这本书里面。如果你对于原 文比较感兴趣可以通过上面的连接去找找看。 正如其名《EXceptional C++ Style》一书中花了大量的篇幅去讨论编码的风格问题，这也 难怪作者会在这本书之后去写一本《C++ Coding Standards》专门讨论C++的编程风格。此 外萨特还和C++语言之父在github上起草编写了 CppCoreGuidelines 。 这本书一共 40 个条款，我直接跳过了其中的9-10两条和26-27两条，不看前者是因为 export这个特性很多的编译器不支持，而且在新的标准中已经废弃；至于后面两条涉及的 是优化问题，作者的核心理念是对于优化专业知识非常的重要，但是我没有关于国际象棋 方面的专业知识。 函数重载这本书没有专门的条款去说明重载决议方面的问题，但是看完只会留下最深的印象的估计 就是它了。重载决议发生在查找模板特化之前，所以如果你特化一个函数模板，它很可能 根本起不了任何的作用，因为它很可能在重载决议阶段就已经被PASS掉了。同样的问题在 new operator中也存在，如果你为你的类重载了三种形式之一而不重载其他两种，那么 其他两种形式无法正常工作，因为在重载决议的时候，编译器只能找到你定制的那一个版 本的new operator从而导致参数不匹配的问题而调用失败。 123456789class Widget &#123;public: static void* operator new(std::size_t);&#125;;int main() &#123; Wdiget* w = new Widget; // OK，调用自己定制的版本 Wdiget* w = new(std::nothrow) Widget; // ERROR，无法找到对应的版本&#125; 此外，对于同一个成员函数的重载版本，如果分属不同的访问权限，同样很可能会出现这 种尴尬的问题。 12345678910111213141516171819#include &lt;string&gt;#include &lt;iostream&gt;class Widget &#123; public: void Print(const std::string &amp;str) &#123; // 1 std::cout &lt;&lt; str &lt;&lt; '\n'; &#125; private: void Print(const char *str) &#123; // 2 Print(std::string(str)); &#125;&#125;;int main() &#123; Widget w; w.Print("hello world");&#125; 上面这段代码是没有办法通过编译的，因为重载决议发生在权限判断之前。而重载决议发 现2是最合适的版本，而权限判定发现它没有权限访问，即使存在1这样的可行版本， 它也依旧无法使用。 private 到底意味着什么private 意味者名字的可访问性，但是并不意味着名字可见性。所以才会出现上面提到的 错误。当然这里还涉及到的另一位关键字是名字，如果我们通过函数指针绕过名字的可 见性，private的成员函数依旧是可以被外界调用的，详见我的另外一篇博文《C++中访 问私有成员的方法》的第三种方法。 异常说明符不要使用异常说明符，在C++11中这东西被废弃了，这本书中详细的讨论了为什么它会被废 弃。主要的原因就是，理想很丰满，但是现实很骨感。 虚函数第一次听到 NVI 是在《Effective C++》中，梅耶轻描淡写的说这是很多人推崇的一种 很有意思的观点，很显然萨特就是这样的人。 通过模板方法模式，固定类的接口，把定制内容封装在 private 下的虚函数中，同时也 可以做一些额外的检测操作。我第一次发现NVI的强大是在看完《程序员修炼之道》的按合约编程之后，而这种风格的编程目前似乎被很多人推崇。 如果想要达到更好的接口和实现的分离，可以使用PImpl手法，或者进一步通过使用策略 模式达到更大的灵活性。 内存模型四个层次，三种形式。 内存管理有四个层次 操作系统接口 编译器的默认运行时库 标准库和标准分配器 用户自定义的容器或用户自定义的分配器 new operator() 有三种形式嗯，刚学C++那会儿只知道new operator的最基本的形式，后来读《深度探索C++对象模 型》一书的时候发现有placement new operator的存在。读完这本书才知道原来 nothrow new是它的第三种形式。 内联《More Exceptional C++》一书中已经对于内联做了讨论，本书对讨论进行拓展。总的来 说还是那句老话，内联是一种优化，而过早的优化是一件愚蠢的事情。 我觉得迟早会有一天 inline 关键字会像 register 关键字一样形同虚设。 宏宏是封装的天敌，它无视作用域，无视类型，悄无声息，形同鬼魅。所以珍爱生命，远离 宏（真的，因为宏造成的BUG会一点点的耗尽你的生命）。 远离生僻特性，知道，但是当他们不存在双字符，三字符之类的东西，大部分情况下成事不足败事有余，所以不要去动他们。 尽量把函数写成非成员非友元第一次接受这个观点在《Effective C++》一书，而对它的进一步的认识则来自《 Exceptional C++》中关于接口规则的讨论，《Exceptional C++ Style》透侧的分析了 std::string 也就是 basic_string&lt;char&gt; 没有遵守这个建议而存在的问题。我开始 也不敢相信，臃肿的它会有103个成员函数（现在估计是只多不少）。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么很多人禁用拷贝（复制）构造函数]]></title>
    <url>%2F2016%2F04%2F24%2Fwhy-delete-copy-constructor%2F</url>
    <content type="text"><![CDATA[关于C++的拷贝构造函数，很多的建议是直接禁用。为什么大家会这么建议呢？没有拷贝构 造函数会有什么限制呢？如何禁用拷贝构造呢？这篇文章对这些问题做一个简单的总结。 这里讨论的问题以拷贝构造函数为例子，但是通常赋值操作符是通过拷贝构造函数来实现 的（ copy-and-swap 技术，详见《Exceptional C++》一书），所以这里讨论也适用于赋 值操作符，通常来说禁用拷贝构造函数的同时也会禁用赋值操作符。 为什么禁用拷贝构造函数关于拷贝构造函数的禁用原因，我目前了解的主要是两个原因。第一是浅拷贝问题，第二 个则是基类拷贝问题。 浅拷贝问题编译器默认生成的构造函数，是memberwise拷贝^1，也就是逐个拷贝成员变量，对于 下面这个类的定义^2： 123456789class Widget &#123; public: Widget(const std::string &amp;name) : name_(name), buf_(new char[10]) &#123;&#125; ~Widget() &#123; delete buf_; &#125; private: std::string name_; char *buf_;&#125;; 默认生成的拷贝构造函数，会直接拷贝buf_的值，导致两个Widget对象指向同一个缓 冲区，这会导致析构的时候两次删除同一片区域的问题（这个问题又叫双杀问题）。 解决这个问题的方式有很多： 自己编写拷贝构造函数，然后在拷贝构造函数中创建新的buf_，不过拷贝构造函数的 编写需要考虑异常安全的问题，所以编写起来有一定的难度。 使用 shared_ptr 这样的智能指针，让所有的 Widget 对象共享一片 buf_，并 让 shared_ptr 的引用计数机制帮你智能的处理删除问题。 禁用拷贝构造函数和赋值操作符。如果你根本没有打算让Widget支持拷贝，你完全可 以直接禁用这两操作，这样一来，前面提到的这些问题就都不是问题了。 基类拷贝构造问题如果我们不去自己编写拷贝构造函数，编译器默认生成的版本会自动调用基类的拷贝构造 函数完成基类的拷贝： 123456789101112131415class Base &#123; public: Base() &#123; cout &lt;&lt; "Base Default Constructor" &lt;&lt; endl; &#125; Base(const Base &amp;) &#123; cout &lt;&lt; "Base Copy Constructor" &lt;&lt; endl; &#125;&#125;;class Drived : public Base &#123; public: Drived() &#123; cout &lt;&lt; "Drived Default Constructor" &lt;&lt; endl; &#125;&#125;;int main(void) &#123; Drived d1; Drived d2(d1);&#125; 上面这段代码的输出如下： 1234Base Default ConstructorDrived Default ConstructorBase Copy Constructor // 自动调用了基类的拷贝构造函数 但是如果我们出于某种原因编写了，自己编写了拷贝构造函数（比如因为上文中提到的浅 拷贝问题），编译器不会帮我们安插基类的拷贝构造函数，它只会在必要的时候帮我们安 插基类的默认构造函数： 123456789101112131415161718class Base &#123; public: Base() &#123; cout &lt;&lt; "Base Default Constructor" &lt;&lt; endl; &#125; Base(const Base &amp;) &#123; cout &lt;&lt; "Base Copy Constructor" &lt;&lt; endl; &#125;&#125;;class Drived : public Base &#123; public: Drived() &#123; cout &lt;&lt; "Drived Default Constructor" &lt;&lt; endl; &#125; Drived(const Drived&amp; d) &#123; cout &lt;&lt; "Drived Copy Constructor" &lt;&lt; endl; &#125;&#125;;int main(void) &#123; Drived d1; Drived d2(d1);&#125; 上面这段代码的输出如下： 12345Base Default ConstructorDrived Default ConstructorBase Default Constructor // 调用了基类的默认构造函数Drived Copy Constructor 这当然不是我们想要看到的结果，为了能够得到正确的结果，我们需要自己手动调用基类 的对应版本拷贝基类对象。 123Drived(const Drived&amp; d) : Base(d) &#123; cout &lt;&lt; "Drived Copy Constructor" &lt;&lt; endl;&#125; 这本来不是什么问题，只不过有些人编写拷贝构造函数的时候会忘记这一点，所以导致基 类子对象没有正常复制，造成很难察觉的BUG。所以为了一劳永逸的解决这些蛋疼的问题， 干脆就直接禁用拷贝构造和赋值操作符。 没有拷贝构造的限制在C++11之前对象必须有正常的拷贝语义才能放入容器中，禁用拷贝构造的对象无法直接放 入容器中，当然你可以使用指针来规避这一点，但是你又落入了自己管理指针的困境之中 （或许使用智能指针可以缓解这一问题）。 C++11中存在移动语义，你可以通过移动而不是拷贝把数据放入容器中。 拷贝构造函数的另一个应用在于设计模式中的原型模式，在C++中没有拷贝构造函数，这 个模式实现可能比较困难。 如何禁用拷贝构造 如果你的编译器支持 C++11，直接使用 delete 否则你可以把拷贝构造函数和赋值操作符声明成private同时不提供实现。 你可以通过一个基类来封装第二步，因为默认生成的拷贝构造函数会自动调用基类的拷 贝构造函数，如果基类的拷贝构造函数是 private，那么它无法访问，也就无法正常 生成拷贝构造函数。 12345678910111213class NonCopyable &#123;protected: ~NonCopyable() &#123;&#125; // 关于为什么声明成为 protected，参考 // 《Exceptional C++ Style》private: NonCopyable(const NonCopyable&amp;);&#125;class Widget : private NonCopyable &#123; // 关于为什么使用 private 继承 // 参考《Effective C++》第三版&#125;Widget widget(Widget()); // 错误 上不会生成memberwise的拷贝构造函数，详细内容可以参考《深度探索C++对象模型》一 书]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中访问私有成员的方法]]></title>
    <url>%2F2016%2F04%2F23%2Fcpp-access-private-member%2F</url>
    <content type="text"><![CDATA[今天读《Exceptional C++ Style》一书的时候，发现在C++中竟然存在一种合法的方式去 访问对象的私有成员，想起以前和嘉伟讨论过了调用私有函数的问题，猛然发现方法不止 原来一种，这里做一个总结。 这三种方法都是使用一个间接层，现在想来果然还是那句老话，没有什么问题是通过间接 层无法解决的。 当然，这里说的所有内容，基本上纯属个人找乐子而已，你在实际编码中不到万不得已千 万不要去使用这些方法，它们给程序的安全和耦合性上都有非常大的危害。 方法一 —— 使用模板函数的特化通过模板成员函数的特化，我们可以访问类的私有成员，这基本上可以说是语言的一个漏 洞。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;class Widget &#123; public: template &lt;typename T = void&gt; void AccessPrivateFunc() &#123; cout &lt;&lt; "Default —— Do Nothing" &lt;&lt; endl; &#125; private: void PrivateFunc() &#123; cout &lt;&lt; "Call Private Function" &lt;&lt; endl; &#125;&#125;;struct PrivateAccessor &#123;&#125;;template &lt;&gt;void Widget::AccessPrivateFunc&lt;PrivateAccessor&gt;() &#123; PrivateFunc();&#125;int main(void) &#123; Widget widget; widget.AccessPrivateFunc(); widget.AccessPrivateFunc&lt;PrivateAccessor&gt;(); return 0;&#125; 这段程序是输出如下： 12Default —— Do NothingCall Private Function 为了确保PrivateAccessor的唯一性，你可以把它放入到匿名命名空间中。此外要注意的 就是这段代码使用了函数模板的默认参数，这个特性只存在于C++11中。当然你可以通过控 制PrivateAccessor的可见性来控制哪些函数可以访问private成员。 方法二 —— 通过额外的友元类这种方式通过增加一个间接的基类AccessController来完成私有函数的访问，通过控制 这个基类你可以控制哪些私有成员可以访问哪些不行。 12345678910111213141516171819202122class Widget &#123; private: void PrivateFunc() &#123; cout &lt;&lt; "Call Private Function" &lt;&lt; endl; &#125; friend class AccessController;&#125;;class AccessController &#123; protected: void AccessPrivateFunc(Widget&amp; w) &#123; return w.PrivateFunc(); &#125;&#125;;class Client : private AccessController &#123; public: using AccessController::AccessPrivateFunc;&#125;;int main(void) &#123; Client client; Widget widget; client.AccessPrivateFunc(widget); return 0;&#125; 上面这段代码的输出是： 1Call Private Function 方法三 —— 使用成员函数指针private 限制了名字的可见性，使用函数指针规避名字可见性，我们一样可以访问私有 方法。 123456789101112131415161718class Widget;typedef void (Widget::*PMember)();class Widget &#123;public: PMember AccessPrivateFunc() &#123; return &amp;Widget::PrivateFunc(); &#125;private: void PrivateFunc();&#125;;int main() &#123; Widget widget; PMember p = widget.AccessPrivateFunc(); (widget.*p)(); // call private function&#125;]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《More Exceptional C++》]]></title>
    <url>%2F2016%2F04%2F22%2Fmore-exceptional-cpp-note%2F</url>
    <content type="text"><![CDATA[和《More Effective C++》中的more不一样的是，这本书的more体现在广度上而不是 深度上。《Exceptional C++》一书的已经是非常有深度的一本书了（或者说是比较难的一 本书了），这本书是前者在其他内容上的扩展。 这本书涉及到很多内容，包括范型模板、性能调优等等方面。个认识收获最多的是 traits类的使用。 traits 类在作者的观点中，获得多态行为的方式有四种，虚函数、模板、重载、转换。但是大部分 人提到多态的时候只会想到第一种方式。转换是一种不太建议使用的机制，没有太多讨论 的必要，而重载更多的人喜欢把它当成一个单独的特性而不是多态的一种形式。 剩下两种其实都可以算是大家都普遍接受的观点，虚函数提供运行期多态而模板提供编译 期多态。单从效率上来说，编译器多态也可以算是一种非常值得学习的技术。依我个人观 点来看，虚函数的关键在于override，模板的关键则在于特化。这也是traits类强 大之所在。比如为了多态的实现一个Create，虚函数的写法可能是这样的： 12345678910111213141516171819202122class WidgetCreator &#123;public: virtual Widget* Create() &#123; return new Widget(); &#125;&#125;;class PrototypeWidgetCreator : public WidgetCreator &#123; // 继承public: // 其他代码初始化 prototype_ virtual Widget* Create() &#123; return prototype_-&gt;Clone(); &#125;private: Widget *prototype_;&#125;;WidgetCreator createor;Widget* widget = createor.Create();PrototypeWidgetCreator prototype;Widget* special_widget = prototype.Create(); 使用traits类是写法可能是下面这样的： 12345678910111213141516171819202122template &lt;typename T&gt;class WidgetCreator &#123;public: static T* Create() &#123; return new T(); &#125;&#125;;template&lt;&gt;class WidgetCreator&lt;SpecialWidget&gt; &#123; // 特化public: // 其他代码初始化 prototype_ static Widget* Create() &#123; return prototype_-&gt;Clone(); &#125;private: Widget *prototype_;&#125;;Widget* widget = WidgetCreator&lt;Widget&gt;::Create();Widget* special_widget = WidgetCreator&lt;SpecialWidget&gt;::Create(); 这两种写法在效果上并不会有太多的区别，真正能够区分两者的地方在于扩展性。虚函数 需要使用继承而traits并不需要，要知道继承是一种非常强的耦合关系，所以从代码的 耦合度上来说，traits要略胜一筹，而且从效率上来说因为traits使用的是编译时多 态，所以理论上（我没有做个实现，所以说理论上）速度应该会更快。 构造函数的异常安全《Exceptional C++》一书中讨论了很多异常安全的内容，主要涉及到拷贝构造函数和赋值 操作符。本书中添加了额外的异常安全内容，包括普通的构造函数、参数求值、pimpl、 继承等对于异常安全的影响。 构造函数第一个需要记住的是，永远不要在初始化列表中获取未管理的资源，比如： 1234567class Widget &#123;public: Widget() : t_(new T()), z_(new Z()) &#123; &#125;private: T* t_; Z* z_;&#125; 这种方式不是异常安全的，即使我们使用 function try block，我们依旧没有办法在 z_ 创建抛出异常的时候释放掉已经分配的 t_。正确的方式是： 1234567891011121314151617class Widget &#123; public: Widget() &#123; t_ = new T(); try &#123; z_ = new Z(); &#125; catch (...) &#123; delete t_; cout &lt;&lt; "widget error" &lt;&lt; endl; throw; &#125; &#125; private: T* t_; Z* z_;&#125;; 或者更好的使用智能指针取代原来的裸指针。 参数求值顺序永远不要写： 1f (new T1, new T2) 这样的代码，你应该写成： 123uniuqe_ptr&lt;T1&gt; t1(new T1);uniuqe_ptr&lt;T2&gt; t2(new T2);f(move(t1), move(t2)); Pimpl 和异常安全Pimpl 的强大在 《Exceptional C++》一书中有详细的介绍，本书中介绍了Pimpl的另 一个功能，那就是异常安全。当然这不是Pimpl的功能，是指针的功能。普通的值没有办 法达到异常安全所需要的不抛异常的Swap，但是指针可以，所以Pimpl可以达到很好的 异常安全性。 继承和异常安全继承是一种很强的关系，实际上的派生类中包含基类的子对象，伪代码如下： 1234class Drived &#123;private: Base base_;&#125;; 这样一来，只要base_无法异常安全的拷贝的话，Drived的对象就无法异常安全的拷贝 。如果不是只用继承，改用组合的话，你可以得到类似下面的 伪代码。 1234class Drived &#123;private: Base* base_;&#125;; 这样一来，由于指针的异常安全性，你可以轻松的实现异常安全的Drived拷贝。这里指 出了用组合强于private的另一方面。 优化优化的第一原则永远都是： 不要做优化 内联是一种优化，所以除非你有十足的证据显示内联可以很大的提升你的程序的性能，否 则，你不需要把函数声明成内联。 cow是一种优化，但是在多线程的环境下，这种优化是得不偿失的，这也是为什么在 C++11标准中不允许使用引用计数来实现std::string的原因。 分解 MI 带来的连体婴儿本书中提供了一种非常优化的方式解决下面的问题： 1234567891011121314class BaseA &#123;public: virtual void foo(); // A 功能&#125;class BaseB &#123;public: virtual void foo(); // B 功能&#125;class Drived : public BaseA, public BaseB &#123;public: virtual void foo(); // 一个函数完成两个功能？？？？&#125; ValuePtr关于智能指针，这本书对于ValuePtr的讨论是非常值得学习，其中使用到的traits技 术和模板构造函数技术，也让这个设计变得非常的有吸引了。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《从晚晴到民国》]]></title>
    <url>%2F2016%2F04%2F18%2Fwanqin-minguo-note%2F</url>
    <content type="text"><![CDATA[这是一部有趣的“野史”，让我了解到正史（教科书）之外的各种史料和观点，给我的感觉 是醍醐灌顶，耳目一新。我高中学文科，对这一段的历史还算了解，书中提到的大事基本 熟悉，只是作者站在一个全新的角度去看待这些事情，给人的体会自然也就不一样了。 《从晚晴到民国》这本书是《晚期七十年》一书的删减版本，至于删减了什么东西我不太 清楚，不过剩下的东西很值得一读。本书覆盖了鸦片战争（1840）年到辛亥革命（1911） 这七十年左右的历史，按照作者的历史转型观点，这段时期十几年发生一次巨变，应该也 就是所谓穷则变，变则通，不通再变，循环往复。这段时期大概是200年，我们目前还处于 这样一个时期，也许不久的将来还会大变。 这段历史是我们的国难史，这段历史当中的国人身处水火之中，人命如蝼蚁，惨不堪言。 在内忧外患之中，我们能够保持领土完整、主权独立可以说是不幸中的万幸。我们之所以 没有沦落为殖民地很大一部分的原因在于那些在民族危亡之际挺身而出的民族英雄。我读 这本书，最吸引我的内容也就是这些人的英雄事迹，他们理当名垂青史，流芳百世。 鸦片战争 海纳百川，有容乃大；壁立千仞，无欲则刚 中国传统小农经济，自给自足，英商的货物在中国卖不出去，长期处于逆差状态。印度沦 为英国殖民地之后，东印度洋公司发现了鸦片这种东西。为了扭转贸易逆差他们竟然公开 向中国贩毒，可以说是丧尽天良。鸦片荼毒我华夏大地，中国匆匆就沦落为东亚病夫了。 中国近代历史上第一位民族英雄林则徐就是在这种情况下进行的虎门销烟。当然关于虎门 销烟很多人把功劳全给了林则徐，其实公正一点来说道光皇帝下定决心禁烟，任命林则徐 为钦差大臣进行禁烟，他同样也是功不可没的。只不过道光皇帝签定了历史上第一个不平 等条约《南京条约》才使得它在历史上背上了丧权辱国之名。 禁烟之后，英国瞬间从贩卖鸦片而来的贸易顺差回到原来的逆差，这也就直接导致了鸦片 战争。英国无耻之处就在于明知是毒品依旧贩卖，回头看看本国商人又何尝不是明知对人 体有害还依旧销售各种毒奶粉、毒大米、地沟油呢？这些人惟利是图和那时候无耻的英商 没有什么区别，这些人是真正的民族败类，窃国之贼。当面毒品泛滥，道光尚且知道禁烟 ，现在食品安全问题横生，当权者却无所作为，我们在骂清廷无能的时候应该反思自己其 实更加的无能。 鸦片战争之后，为洋人所迫，林则徐被贬新疆。很多人知道林则徐是因为它虎门硝烟，不 知道的是它为守护边陲做出的贡献。林则徐在新疆待了八年，对于边疆的安危十分担心， 它告老还乡的时候遇到了另一位英雄人物左宗棠，很多人认为左宗棠执意收复新疆可能有 一部分原因是受林则徐所托。 收复新疆 大将筹边尚未还，湖湘子弟满天山。新栽杨柳三千里，引得春风度玉关。 左宗棠是一代豪杰，光绪年间，清廷内争，李鸿章主张海防，左宗棠主张边防，最后李鸿 章建了北洋海军，在甲午中日战争中片甲不存；而左宗棠挺近边疆，最终收复了新疆。 新疆边陲，沙俄扶植浩罕汗国阿古柏占我疆土，左宗棠击败阿古柏收复新疆。后来左宗棠 抬棺西征，率军挺近伊犁以示沙俄决一死战，为《中俄伊犁条约》提供了军事后盾。正是 左宗棠这种大丈夫死当马革裹尸还的气魄，才保我中华一百六十万疆土安然无恙不至于被 沙俄吞并。 太平天国正史当中对于太平天国的评价特别高，但是大部分的史学大师对它都是嗤之以鼻的。太平 天国又称为“洪杨之乱”，这个名字或许更加适合它。很多人都知道日军攻破南京的时候进 行了屠城，其实太平天国时期南京同样被屠城，而且有三次。第一次屠城在太平军攻破南 京之后，第二次在太平军内乱之时，第三次是湘军破城之后。南京这个金粉小天堂，虎据 龙蟠之地，帝王之都，百年之内屡遭屠城，可以说是国之大难，万民同悲。太平军屠城不 仅仅限于南京，它们在沿路攻伐的时候在全州、沧州都有屠城。 太平天国说白了就是“内乱”，所谓的天朝田亩制度压根就没有执行过，一群愚昧无知的屠 夫到处烧杀抢掠，比杀人八百万的黄巢也好不了太多。 当然太平军中也有人才，石达开可以说是首屈一指的豪杰。洪秀全占领南京已然成为孙权 ，石达开被排挤之后兵败大渡河其实是想要由此道去天府之国的关中当刘备，这样三足鼎 力估计中国又要合久必分了。石达开没有成功，在大渡河被围，他为了保全他手下的将士 ，主动投降，后来被押往成都凌迟处死。他算是条汉子，只不过清廷背信弃义，并没有放 过他手下的将士，尽数屠杀。 甲午中日战争甲午中日战争是中国的洋务运动和日本的维新变法的成果检验厂。最终北洋水师全军覆没 ，朝野大惊，李鸿章成为千夫所指的大汉奸。教科书上总是会看到我们的李中堂签订各种 丧权辱国的条约，大汉奸的形象跃然纸上。但是历史上的李鸿章完全不是这样的形象，他 化解我国被瓜分的危机，保我主权完整可以说居功至伟，它最终被沙俄逼死在病榻之上也 可以算鞠躬尽瘁死而后已了。 黄海海战，李鸿章一再避让是因为他知道北洋水师根本不是日军的对手，所以他极力主和 一再避让。清廷内部自身沉溺在天朝上国的梦中，认为敌不过英法，但是打弹丸小国日本 绰绰有余。事实上李鸿章对于这一切看的清清楚楚，甲午惨败，李鸿章背黑锅被千夫所指 和背黑锅的秦桧是一个道理。 北洋水师敌不过日本海军不输在军人素质，输在武器装备的落后。慈禧老太后为了修建颐 和园挪用北洋水师的军费，北洋舰队的船慢炮钝根本不是日军的对手。 黄海大战中邓世昌企图用致远号撞毁日军吉野好，不幸被鱼雷击中，他落水之后不愿接收 随从给的救生圈，与爱犬同沉大海，壮烈殉国。一年后威海卫海战中，北洋水师惨败，刘 步蟾、丁汝昌先后自杀，自古艰难维一死，他们不愿投降以死报国，可歌可泣。 戊戌变法大部分人提到戊戌变法都会想到康、梁师徒，其实在变法中同样重要的人物是年轻的光绪 皇帝。他不愿做亡国之君，决心变法，变法失败之后被幽禁，比起康、梁二人他是个更加 悲剧的人物。 戊戌变法失败谭嗣同不愿避难，甘愿为变法献身，留下“我自横刀向天笑，去留肝胆两昆仑 ”的绝句，浩气长存，中华民族能够躲过浩劫，免遭瓜分正是因为有这样的好男儿的存在。 八国联军侵华也许大部分人都不知道，八国联军侵华，首先宣战的是慈禧太后。首都沦陷，生灵涂炭是 国人自己引起的。义和团攻打使馆，八国才有接口进军北京。 很多人知道李鸿章代表清廷签订这个不平等条约，说他卖国，其实没有李鸿章，以当时的 形式，中国很可能被瓜分。李鸿章最高明的地方在于他把围攻使馆说成是“拳乱”，宣战诏 书是伪造，这样中国从参战国变成受害国，八国联军入京是助剿拳匪。如此以来列强没有 瓜分接口，最后只是赔款没有割地。 《辛丑条约》之所以赔款4.5亿，是表示要中国的四万万五千人每人赔一两白银。 很多人不知道李鸿章在签订这个条约之后就逝世了，俄国妄图侵占我国东北，逼李鸿章和 他们签订不平等条约，李鸿章死的时候，俄国公使还在病榻之侧紧逼。李鸿章这个宰相合 肥天下瘦的李宰相也许有一些个人作风问题，但是说他是汉奸，说他卖国就真的有失偏颇 了。 此外，李鸿章死前推荐袁世凯担任北洋大臣，这样袁世凯才会扶摇直上成为大清王朝的顶 梁柱。 辛亥革命国父中山先生其实并不光鲜，当然不是说他有什么不光彩的事情，只是说他为了革命，四 处筹款，其实是灰头土脸的，为了生计他曾经在美国端盘子。正是中山先生这种不屈不挠 ，屡败屡战的精神才会有我们名族的今天。]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《Exceptional C++》]]></title>
    <url>%2F2016%2F04%2F10%2Fexceptional-cpp-not%2F</url>
    <content type="text"><![CDATA[萨特是 ISO C++标准委员会主席， C++/CLI首席架构师，久负盛名之人，书的质量自然不 用怀疑。这本书是Exceptional系列书籍的第一本，很多人觉得这个系列可以和梅耶的 Effective系列相媲美，虽然名气上它似乎不如后者。梅耶的书读起来很有趣，像一个逗 比给你讲故事，萨特的书读起来相对沉重一些，更像一个老教授在你身边耳提面命。 对比 Effective C++在《Effective STL》的参考数目中，梅耶提到了 Exceptional 系列的书籍，他说这本 书是对于 Effective 系列的模范补充。起初我看到这个评论的时候，小人之心的认为梅 耶吹牛，弦外之意是这套书只是Effective系列的注脚，没他的书好。 看完这本书之后我理解梅耶想要表达的意思是这本书的很多内容对于Effective系列中的 内容进行更深层次的讨论，所以说是一个模范补充。这本书中提到的很多东西在 Effective系列中都有涉及，但是通常都更加的详细。比如《ESTL》中提到如何编写大小 写不敏感字符串比较函数，这本书中讨论了使用函数和使用类之间的区别以及如何选择。 在Effective C++中提到了异常安全问题，但是没有这本书中讨论的这么详细。这样的例 子还有很多，看过这些书自己就会慢慢的发现。 当然这并不是说Effective系列的书没有这个系列的书好。梅耶最让人佩服的地方在于他 可以从浩瀚的C++特性中找出那些新手最容易出错的地方，他的书相对来说面向的是初级学 者（目标就是成为C++程序员的第二本书）。萨特的书是面向中级水平的C++程序员的，所 以讨论的力度也相对会深一些。 用你熟悉的特性，理解你自己写的代码萨特在这本书中不断的提到的一点是使用你熟悉的特性去编写代码，同时要理解你自己编 写的代码。千万不要为了炫技去写一些华而不实的代码。 这种思想让我想起《程序员修炼之道》中的名言：关心你的技艺，在你的作品上签名。编 写C++代码不是一个想当然的过程，它需要你足够的细心和耐性，特别是在编写异常安全代 码的时候。我们应该很用心的思考我们自己的写的代码，对自己写的代码负责。 永远都走在精通C++的路上我看完effective系列的几本书之后觉得自己的C++的小学生水平，看完这本我觉得自己 是幼儿园的水平。这本书不仅仅讨论了C++语言的特性，同时也讨论这些特性怎样的影响着 软件的开发过程。这本书的很多内容都涉及到软件工程方面的问题，比如书中不断提到的 解耦问题在任何一种编程语言中都是需要考虑的。 对我来说获益最大的内容是：异常安全、类关系的讨论、编译防火墙、接口规则。 异常安全性关于异常安全性的讨论，估计没有哪一本书有这本书这么完整而透侧。C++的异常饱受诟病 ，很多人甚至直接建议不用，比如Google公司的C++编码规范中就直接禁用异常。其中很 大一个原因是异常安全代码很难完成，特别是对于范型编码来说更是如此。Tom Cargill 的文章让很多人对于异常敬而远之，以至于很多书籍中对于异常给出的建议都不是很乐观 ，比如《深度探索C++对象模型》、《More Effective C++》。 Tom Cargill的那篇文章在梅耶的书中也有提到过，借着看这本书的机会我也就认认真真 的把这篇文章好好的读了一读。看完这篇文章之后明白，很多人不用异常是有它的道理的 ，异常的出现对于代码安全的破坏可以说防不胜防，尤其是在编写范型程序的时候更是如 此。 这本书贡献了一章十二个条款专门讨论异常安全的问题，萨特无非想要告诉我们异常安全 代码没有想象中那么难写。你需要记住的是： 异常安全不是风格问题，他会严重的影响到你的代码，你应该在设计的时候就考虑这个 问题。 不要让一个函数完成两个完全不相关的功能，因为它很难做到异常安全要求的原子性。 千万不要在析构、operator delete() 和 operator delete 中抛出异常。 使用 RAII 单独管理资源。 把会抛出异常的代码单独放置在一块儿，确保没有问题之后在调用那些不会有异常抛出 的代码。 编译防火墙其实编译防火期不仅仅是防止编译依赖的一种方式，它同样也是实现和接口分离的一种方 式，因为它把私有的东西全部隐藏在pimpl_之后。在effective c++一书中提到两种降 低编译依赖的方式纯虚接口类和pimpl。之前我一直比较倾向于使用纯虚接口类的方 式，因为它的代码更加漂亮一些（原谅我的代码洁癖），但是按照我现在的理解，我更倾 向于使用pimpl的方式，因为它使用的是组合而前者使用的是继承，组合的灵活性要远高 于继承，耦合度也要小很多。 类关系这部分内容给我最大的感触就是，继承不是OO的基础。并不是说没有继承就算不上OO ，OO 的强大在于使用类关系降低依赖，而关系不仅仅只有继承一种（这是一种很强的关 系，组合是一种相对弱的关系）。 接口规则Effective C++中提到一个反直觉的建议，尽量使用非成员函数而不是成员函数。这本书 提到的接口规则告诉我们，并不是只有成员函数才能算的上是类的一部分，非成员函数同 样也是。而非成员函数和类之间的依赖要小于成员函数，扩展性要强于成员函数，这也是 优先使用它的原因。 其他内容当然书中还有许多其他的内容，同样值得大家认真的思考，包括临时变量，模板构造函数 ，STL组件的用法等等。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《Effective STL》]]></title>
    <url>%2F2016%2F04%2F01%2Feffective-stl-note%2F</url>
    <content type="text"><![CDATA[Scott Meyers 的书，似乎每一本都值得一读再读，这本书我是第二次读。上次读这本书 基本上是在车上读完的，那时候在公司实习，上下班的路上读完这本书，不厚，但是很值 得人回味。 那时候对于STL并不理解，至少比现在理解的要少一些，所以很快就忘了书里说了些什么 。以至于后来看到《深入理解C++11》这本书引用《Effective STL》一书的内容的时候没 有半点印象，这也是我打算重读这本书的原因。 看这本书之前，我看了《C++ 标准库》这本砖头书，对于标准库中的各个组件有了更加深 刻的理解，所以再次看这本书的时候，感悟和第一次读的时候有很大的区别。 书中有一些信息已经过时了虽然我是作者的脑残粉，不过我还是得承认，这本书中有些信息真的已经过时了。我简单 的罗列了一下： 容器中的数据必须能够正常拷贝，C++11 中 move 语义的出现，去掉了这一限制。（ item 3） string 的引用计数。C++11 中不再允许使用引用计数的方式实现 string。（item 15） 不要修改 set 或 multiset 中的键。C++11 中不允许我们直接修改 set 的键，书 中提到是做法现在来说不合法。（item 22） 优先使用 iterator。在 C++11 中由于 cbegin，cend 的出现，你应该优先使用 const_iterator，这一点在作者的新书 《Effective Modern C++》中有提到。（item 26） ptr_fun, mem_fun, mem_fun_ref, functor 适配等。在新的标准中，这些东西已经被废 弃了。我们应该优先考虑使用 binder，function，它解决了上面这些组件原本解决 的问题，并且是以一种更加优雅的方法。（item 41） 还有一些信息，没有过时，不过有更优雅的方式完成。 使用括号来修正下面代码被解析成函数声明（item 6） 12list&lt;int&gt; data(istream_iterator&lt;int&gt;(dataFile), istream_iterator&lt;int&gt;()) 在C++11中可以直接使用{}作为第二个参数，从而避免这个问题。 使用 swap 技术去掉容器中多余的元素。C++11中，vector，string，deque都提 供了shrink_to_fit函数完成这一功能。（item 17） 很有深度的一本书不，虽然我说这本书有些信息过时了，但我没有说这本书不值得一读。这仍然是我见过最 有深度的STL的书（当然，你可以鄙视我，因为我一共也没有看过几本），非常值得每一个 C++程序员去读一读。 STL 的坑这本书提到了很多STL的坑，下面是你需要重点注意的一些大坑。 确保目标区间足够大（item 30） 123transform(v.begin(), v.end(), result.end(), transmogrify) 这段代码无法工作，因为 result.end() 不是一个合法的插入地址，你应该考虑使用 back_inserter remove 不会删除元素（item 33） 1remove(v.begin(), v.end(), 99); 这段代码不会从容器中伤处任何的东西。你需要对返回值调用erase。 不要在判别式（有是书中翻译成谓词）改变状态（item 39） 12345678910class BadPredicate &#123;public: BadPredicate() : timeCalled(0) &#123;&#125; bool operator(const Widget&amp;) &#123; return ++timeCalled == 3; &#125;private: int timeCalled;&#125; 上面这段代码是一段很拙劣的代码。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《Vim 实用技巧》]]></title>
    <url>%2F2016%2F04%2F01%2Fpractical-vim-note%2F</url>
    <content type="text"><![CDATA[Tips1 你应该从今天就开始阅读这是我第三次尝试读完这本书，也是第一次成功读完它。前两次读这本书的时候总是各种 原因读了几章之后就放弃了，不是书不好，只是那时候没有足够的时间和耐性。Tips性 质的书籍总会让我觉得，嗯，明天再读下一条Tips也可以，反正前后也没有太大的联系 ，于是明天之后的明天的明天我还是没有把这本书看完。也许我早些读完这本书，我不会 自不量力的写那些关于Vim的文章，因为那些文章看上去有些误人子弟了。 Tips2 理解快捷键的内在逻辑毋庸置疑的是这是一本非常好的Vim书籍，我用Vim已经有两年左右的历史了，但是看完之 后还是觉得自己是小学生的水平。Vim的使用不是简简单单的记住几个快捷键就可以的，很 多时候，我们需要知道这些快捷键的内在逻辑。 Tips3 慢点开始，因为你可能走错了方向我从一开始用Vim的时候就可以使用各种vimrc的配置，使用自定义的一些快捷键完成自己 更高效的一些操作。现在想来一开始就是错的。我们需要花时间去把锯子磨利，而一开始 胡乱的配置只会让我们把锯子越磨越钝，作者说的对，其实很可能我们磨错了边。 Tips4 不要太过于依赖插件我之前学习Vim，最先想到的是它的插件，因为我一直认为Vim核心功能很少，功能不够强 大。实际上，Vim的核心功能已经非常强大，只是我一直不知道。在使用插件之前先考虑一 下你的功能是否可以使用核心功能完成。 之所以这么说，是因为核心功能的适用性要比插件广泛太多，你可以使用IDE中安装Vim模 拟器来使用Vim的核心功能，但是你没有办法在IDE的Vim模拟器中使用Vim的插件。Vim的核 心功能是放之四海而皆准的东西，这些东西相当于是一个人的内功，插件通常只是招式。 Tips5 移动光标的方式不只有 hjkl对于初学Vim的人来说，它最奇怪的地方估计是使用hjkl来替代方向键。之所以使用这四 个键是一个历史遗留问题，原因可以参考之前写过编辑利器 Vim 之快捷键配置 一文。 这四个按键的效率比方向键效率高很多，因为你不用偏离键盘的关键行（也就是hjkl一 行）。因为这种诡异性和便捷性，我一度以为移动光标最快的方式是 hjkl 这四个键。 然而实际上，这是大错特错。 对于同一行的移动，hl是最慢的方式，因为它们的移动是以字符为单位的。w,e,b,ge 这四个键比前面两个要快很多，因为它们是基于单词的（当然还有大写的W和E等对应版本 ）。可是最快的方式是f, F, t, T结合;和,，因为它们很多时候可以直达你想要到 达的地方。比如： 1#include &lt;iostream&gt; 光标在#的时候，想要把 iostream 替换成 string，使用l移动到目标位置，你需 要按10次，使用w你需要3次，使用f你只需要1次fo就可以了（然后使用 ciw 进 行替换）。 如果你想要在行之间移动，jk这两个按键同样不是最快的方式，因为它们一次只能移动 一行，使用/这种方式通常会快很多。没错就是搜索，你可以通过搜索快速的到达你想要 的位置，对我来说，这是一种思维方式的转变。Vj可以选择两行代码，V/}可以通常可 以选择一块代码。当然最快的还不是这个，使用 vi} 你可以以最快的方式选择代码块中 的内容，对我来说，这是神技。 Tips6 正则表达式很重要最近总是和正则表达式打交道，从使用Python的正则表达式写爬虫开始，到后来从《程 序设计实践》一书中了解grep的实现，再到后来看C++11的正则表达式库。现在发现 Vim中无处不在的正则表达式。搜索可以用正则，替换可以用正则，global命令还是可以用 正则。 Tips7 Vim 自带自动补全功能很多人不用文本编辑器的原因很简单，因为他们认为只有IDE才有自动补全功能。实际上， Vim自动自动补全功能，而且非常强大。即使不用 YouCompleteMe这一类的插件你也可以 得到非常好的补全功能。]]></content>
      <tags>
        <tag>Vim</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《C++ 标准库（第二版）》]]></title>
    <url>%2F2016%2F03%2F26%2Fcppx-stdlib-note%2F</url>
    <content type="text"><![CDATA[呼……这本书总算是看完了，前前后后看这本书大概花了二十来天，总算看完了（更准确的 说是翻完了）这本砖头一样厚（还是块加厚版的砖）的书。 你要是问我记住了些什么，我只能说啥也没记住，C++标准库的内容终究还是太多，细节太 多，能装在脑子里的东西真的很少。其实我在看这本书之前就知道会是这个结果，所以也 没有觉得自己白读了这本书，留在脑海中不是也不应该是具体的细节，而是关于标准库的 一些感悟，前面读这本书的时候陆陆续续也有写一些文章来记录这些东西。 我为什么读这本书这本书是关于C++标准库的一个权威的指南，其实读这本书的原因和学标准库的原因是一样 的。目前的任何一门语言都是语言的核心+语言的标准库，没有掌握标准库之前，我们都 不能说自己掌握了这门语言。我希望自己能够掌握这门语言，所以我在了解了基本的语法 之后读了这本书。如果你想掌握这门语言，我也推荐你看这本书。 我曾经在知乎上看到过一个观点： 一门语言要么是语言核心语法难，要么是它的库很难 对于C++来说，是这两者都很难，C++之所以会这么难学原因估计就在于此。 最大的体会读完这本书，突然发现其实自己对于C++的了解非常的有限。过去的自己对于C++的理解仅 仅停留在C++ OOP的角度，C++标准库让我体会到C++范型编程的强大之处。我自己对于 范型只停留在会用（甚至都不太会用）的级别，自己动手进行范型编程的能力基本为零， 而这种能力的缺失可以说让我丧失了C++威力的半壁江山。 在OOP的世界里，我们一直提倡面向接口编程，而对于C++来说，类型就是接口，所以整 个系统都在和类型打交道，强大的静态类型系统也被认为是C++的一项法宝。当然C++并没 有把接口和实现区分的非常清楚[^1]，这也是很多人指责C++的一个原因。 范型编程完全是另外一种思维的存在，范型的关键思维在于像什么就是什么而不去在乎 它真正到底是什么。所以指针可以当成迭代器用，函数指针和函数对象在范型角度看来并 没有区别，类型在范型编程中并没有太大的作用。这种思维的背后的逻辑才是真正纯粹的 面向接口编程，只要你提供正确的接口，你就可以正确的运行，至于你到底是什么类型对 于我来说根本不重要。从这个角度来说，Python编程就是范型编程，因为Python中你 只需要确定一个对象有某个接口，至于对象的类型你可以完全不管。 C++标准库中的核心武器：STL的设计就是这种逻辑，我渐渐的明白，为什么很多大师级 的人物更倾向于使用namespace中定义普通函数而不是类的内部定义成员函数。那些嘲笑 C++并自诩完全面向对象的Java程序员是多么的可笑。 这些理解不一定正确，它是我看完STL迭代器和算法之后最大的一种体会，其实范型真的不 仅仅是把容器类型参数化而已。 最容易忽视的东西对我来说，整个库中最容易被我忽视的东西是STL算法，其实其中的算法包罗万象，远远 超过我原来了解的范围。也许我们不应该使用： 123for (auto beg = v.begin(); beg != v.end(); ++beg) &#123; // do something&#125; 而是考虑： 123for_each(v.begin(), v.end(), [] (const value_type&amp; elem) &#123; // do something &#125;); 我们经常需要考虑如何在一次 for 循环中删除掉某个元素而保证 iterator 有效，其 实我们应该考虑能否直接用 remove_if 来完成这一功能。 这样的例子很多，我们一直重复的一些动作其实STL中早就为我们封装好了算法，只不过 在没有发现之前，我们总是在不断的重复着那些我们自以为很优雅的解法。 最容易自以为懂了的东西其实这本书中的大部分内容以前都不太全面的接触过：智能指针，STL，字符串， I/O，正则表达式，线程 等等。我自以为自己懂了却发现完全不懂的东西是I/O这 一部分。 1cout &lt;&lt; "hello world" &lt;&lt; endl; 这样的语句大家都会用，但是我从来没有去考虑过所谓的 endl 到底是什么东西。后来 我知道 endl 是一种操控器，自以为自己懂了，却从来没有想过 1cout &lt;&lt; endl; 为什么可以换行，并把内容显示在屏幕上。看完这本书之后我才知道其实 endl 是一个 函数，它接收一个 stream 作为它的参数。伪代码去下： 12345ostream&amp; endl(ostream&amp; os) &#123; os.put('\n'); os.flush(); return os;&#125; 而 ostream 的 &lt;&lt; 操作符有一个重载版本，接收一个函数指针作为它的参数： 123ostream&amp; ostream::operator &lt;&lt; (ostream&amp; (*op) (ostream&amp;)) &#123; return (*op)(*this);&#125; 就是是为什么 cout &lt;&lt; endl; 可以正常工作的原因。你完全可以扩展自己的“操控器”来 完成自己额外的需求。 I/O 其实是一个设计非常好的库，它的各大组件之间的职责分派非常明确，stream 其实自身根本不处理实际的输入输出，这些东西都委托给了 streambuf 处理。I/O 本 身可能在项目中使用的并不是特别的多，但是个人觉得它的源码库有机会还是很值得读一 读的。 黑魔法C++11有许多新的特性，比如：变参模板，右值引用等等。这些特性造就了一堆的黑魔法出 现，比如tuple，binder，function。很遗憾这本书并没有深入的讲解这些黑魔法的 具体实现机制，只是提到了它们的用法。关于 tuple 的实现，《深入理解C++11:C++11 新特性解析与应用》这本书中有比较详细的介绍。关于 binder 看过一篇相关的文章 图解boost::bind，感觉还不错。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 中使用 {} 作为串流迭代器 EOF]]></title>
    <url>%2F2016%2F03%2F17%2Fcppx-end-of-stream-iterator%2F</url>
    <content type="text"><![CDATA[stream iterator 是一种神奇的迭代器适配器，它让我们可以使用 STL 算法操纵输 入输出流，比如把 vector 中的内容全部输出，可以简单的写成这样。 12vector&lt;int&gt; coll = &#123;1, 2, 3, 4, 5, 6&#125;;copy(coll.cbegin(), coll.cend(), ostream_iterator&lt;int&gt;(cout, " ")); 当然你也可以使用这种方式处理输入，比如从标准输入中输入元素到 vector 中去。 1234vector&lt;int&gt; coll;copy(istream_iterator&lt;int&gt;(cin), // start of source istream_iterator&lt;int&gt;(), // end of source back_inserter(coll)); // destination istream_iterator 要比 ostream_iterator 难用一些，因为你必须要使用一个 EOF 表示输入的结束，这个概念可以用 istream_iterator 的默认构造函数产生的对 象表示。也就是上面这个 istream_iterator&lt;int&gt;()。 这种语法看起来比较诡异，我在看 《C++ 标准库》^1这本书的勘误的时候发现了一种新 的语法，直接使用{}。 1234copy (istream_iterator&lt;string&gt;(cin), // start of source &#123;&#125;, // end of source //(default constructed istream iterator) back_inserter(coll)); // destination 之所以可以这样做主要归功于 C++11 统一了初始化语法，可以在任何地方使用 {} 来初始化，在 copy 中，因为我们可以根据第一个参数推导出第二个参数的类型，所以 可以直接通过 {} 来调用默认的构造函数创建代表 EOF 的迭代器。 勘误的原话如下： Note that since C++11, you can pass empty curly braces instead of a default constructed stream iterator as the end of the range. This works because the type of the argument that defines the end of the range is deduced from the previous argument that defines the begin of the range: 另外需要提醒的是，《C++ 标准库》的中文译本应该是基于第一次印刷版本翻译的，原书 有一些错误，在英文版的勘误中有修正，大家如果读这本书应该关注一些它的 勘误，以免被一些错误所误导。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 中的 emplace]]></title>
    <url>%2F2016%2F03%2F16%2Fcppx-stdlib-empalce%2F</url>
    <content type="text"><![CDATA[最近读《C++ 标准库》这本书，发现C++11中大部分的容器对于添加元素除了传统的 insert 或者 pusb_back/push_front 之外都提供一个新的函数叫做 emplace。 比如如果你想要向 std::vector 的末尾添加一个数据，你可以： 12std::vector&lt;int&gt; nums;nums.push_back(1); 你也可以使用： 12std::vector&lt;int&gt; nums;nums.empace_back(1); 那么这两种方式的区别到底是什么呢？在《C++标准库》一书中没有给出解释，我查了一 下相关的资料，在此做一个总结。 避免不必要的临时对象的产生emplace 最大的作用是避免产生不必要的临时变量，因为它可以完成 in place 的构 造，举个例子[^1]： 12345678struct Foo &#123; Foo(int n, double x);&#125;;std::vector&lt;Foo&gt; v;v.emplace(someIterator, 42, 3.1416); // 没有临时变量产生v.insert(someIterator, Foo(42, 3.1416)); // 需要产生一个临时变量v.insert(someIterator, &#123;42, 3.1416&#125;); // 需要产生一个临时变量 这是 emplace 和 insert 最大的区别点。emplace 的语法看起来不可思议，在上 面的例子中后面两个参数自动用来构造 vector 内部的 Foo 对象。做到这一点主要 使用了 C++11 的两个新特性 变参模板 和 完美转发。”变参模板”使得 emplace 可以接受任意参数，这样就可以适用于任意对象的构建。”完美转发”使得接收下来的参数 能够原样的传递给对象的构造函数，这带来另一个方便性就是即使是构造函数声明为 explicit 它还是可以正常工作，因为它不存在临时变量和隐式转换。 123456789101112131415161718struct Bar &#123; Bar(int a) &#123;&#125; explicit Bar(int a, double b) &#123;&#125;&#125;;int main(void)&#123; vector&lt;Bar&gt; bv; bv.push_back(1); // 隐式转换生成临时变量 bv.push_back(Bar(1)); // 显示构造临时变量 bv.emplace_back(1); // 没有临时变量 //bv.push_back(&#123;1, 2.0&#125;); // 无法进行隐式转换 bv.push_back(Bar(1, 2.0)); // 显示构造临时变量 bv.emplace_back(1, 2.0); // 没有临时变量 return 0;&#125; map 的特殊情况map 类型的 emplace 处理比较特殊，因为和其他的容器不同，map 的 emplace 函数把它接收到的所有的参数都转发给 pair 的构造函数[^2]。对于一个 pair 来说，它既需要构造它的 key 又需要构造它的 value。如果我们按照普通的 的语法使用变参模板，我们无法区分哪些参数用来构造 key, 哪些用来构造 value。 比如下面的代码： 1234map&lt;string, complex&lt;double&gt;&gt; scp;scp.emplace("hello", 1, 2); // 无法区分哪个参数用来构造 key 哪些用来构造 value // string s("hello", 1), complex&lt;double&gt; cpx(2) ??? // string s("hello"), complex&lt;double&gt; cpx(1, 2) ??? 所以我们需要一种方式既可以接受异构变长参数，又可以区分 key 和 value，解决 方式是使用 C++11 中提供的 tuple。 1pair&lt;string, complex&lt;double&gt;&gt; scp(make_tuple("hello"), make_tuple(1, 2)); 然后这种方式是有问题的，因为这里有歧义，第一个 tuple 会被当成是 key，第二 个tuple会被当成 value。最终的结果是类型不匹配而导致对象创建失败，为了解决 这个问题，C++11 设计了 piecewise_construct_t 这个类型用于解决这种歧义，它 是一个空类，存在的唯一目的就是解决这种歧义，全局变量 std::piecewise_construct 就是该类型的一个变量。所以最终的解决方式如下： 123pair&lt;string, complex&lt;double&gt;&gt; scp(piecewise_construct, make_tuple("hello"), make_tuple(1, 2)); 当然因为 map 的 emplace 把参数原样转发给 pair 的构造，所以你需要使用同样 的语法来完成 emplace 的调用，当然你可以使用 forward_as_tuple 替代 make_tuple，该函数会帮你构造一个 tuple 并转发给 pair 构造。 1234map&lt;string, complex&lt;double&gt;&gt; scp;scp.emplace(piecewise_construct, forward_as_tuple("hello"), forward_as_tuple(1, 2)); 所以对于 map 来说你虽然避免了临时变量的构造，但是你却需要构建两个 tuple 。 这种 traedoff 是否值得需要代码编写者自己考虑，从方便性和代码优雅性上来说： 1scp.insert(&#123;"world", &#123;1, 2&#125;&#125;); 这种写法都要胜过前面这个 emplace 版本。所以个人认为对于临时变量构建代价不是 很大的对象（比如基础类型）推荐使用 insert 而不是 emplace。 [^1]: 例子来自 StackOverflow [^2]: 参考 std::map::emplace]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中的聚合初始化]]></title>
    <url>%2F2016%2F03%2F13%2Fcpp-aggregate-initlization%2F</url>
    <content type="text"><![CDATA[C++标准库中提供两个容器表示数组这个概念：array表示静态数组，vector表示动态数组 。这两个类型都可以使用列表初始化（list initilization）来初始化。 12std::array&lt;int, 5&gt; = &#123;1, 2, 3, 4, 5&#125;;std::vector&lt;int&gt; = &#123;1, 2, 3, 4, 5&#125;; 乍看上去没什么好奇怪的，毕竟都是 STL 中的容器，提供类似的初始化接口没有什么特 别的，而且 C++11 中提供的 initilizer_list 也让上面这种语法变得非常的普遍，接 受一个 initilizer_list 参数的构造函数甚至有一个专有术语 initializer-list constructor，比如vector就有这样一个构造函数： 12vector( std::initializer_list&lt;T&gt; init, const Allocator&amp; alloc = Allocator() ); 这一切看上去都合情合理，直到我发现，array 没有显式定义任何的构造函数。也就是 说它的这种初始化根本就没有用到 C++11 中的任何特性，你甚至可以在 C++98 中使用这 样的语法初始化它。 那么这一切又是如何做到的呢？答案是它使用了 C++ 的另一个特性：聚合初始化（ aggregate initialization）。 聚合初始化聚合初始化其实由来已久，在C语言中就存在了。 1int array[5] = &#123;1, 2, 3, 4, 5&#125;; 在C++中对于聚合体（aggregate）的初始化称为聚合初始化，可以使用上面这种语法。 有两种类型的对象被称为聚合体： 数组类型 满足下列条件的类类型（通常是结构体（struct）或者联合体（union））： 没有私有或保护的非静态数据成员 没有用户提供的构造函数 没有基类 没有虚函数 所以说下面这个结构体的对象可以使用聚合初始化： 123456struct Aggregate &#123; int i; int j;&#125;;Aggregate aggr = &#123;1, 2&#125;; 上面这些都没什么神奇的，真正神奇的是如果你的聚合体中间有嵌套，你可以不用使用花 括号分割： 123456struct Aggregate &#123; int arr[4]; int j;&#125;;Aggregate aggr = &#123;1, 2, 3, 4, 5&#125;; 在上面这个初始化中，arr 成员会得到{1, 2, 3, 4}, 而 j 成员会初始化成 5 。 std::array 是一个聚合体所以其实 std::array 之所以可以使用列表初始化的原因是它是一个聚合体，也就是说 这个模板的所有成员都是 public，理论上你可以直接访问他们，不过C++标准没有规定 它的成员变量的名称，使用他们是未定义的行为，不具有可移植性。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中实现简单的Python风格字符串格式化函数]]></title>
    <url>%2F2016%2F03%2F10%2Fpython-like-str-formater-in-cpp%2F</url>
    <content type="text"><![CDATA[前一段时间学习 Python，被这门语言的便利性惊艳到了，比如你可以这样产生一个字 符串： 12# output "hello world, PI is 3.14""&#123;&#125; world, PI is &#123;&#125;".format("hello", 3.14) 最近学习C++标准库，看到C++11新的变参模板，发现它可以用来实现一个简单的类似 Python 风格字符串格式化函数[^1]，语法如下：。 12// output "hello world, PI is 3.14"FormateString("&#123;&#125; world, PI is &#123;&#125;", "hello", 3.14) 本文讲解一个非常简单的实现版本，不处理下面这样的语法： 12// output "say you say me"FormateString("&#123;0&#125; you &#123;0&#125; me", "say") 如果你需要一个丰富的字符串格式化功能，可以考虑使用cppformat这个库。 具体实现注意：因为使用了C++11中的新特性，你需要一个C++11编译器，通常你需要在编译的时 候设置 -std=c++11。本文实现的版本源码可以在我的代码库中找到 基本的实现思路是使用变参模板捕获格式说明符之外的所有参数，然后依次把他们通过 stringstream 拼接在一起，最终返回拼接的结果，函数的声明如下：。 123template &lt;typename... Types&gt;const std::string FormatString(const std::string&amp; fmt_spec, const Types&amp;... args); 该函数实现如下： 1234567template &lt;typename... Types&gt;const std::string FormatString(const std::string&amp; fmt_spec, const Types&amp;... args) &#123; std::stringstream builder; BuildFormatString(builder, fmt_spec, args...); return builder.str();&#125; 该函数声明一个用于构造字符串的 stringstream，然后通过调用辅助函数 BuildFormatString 完成最终的字符串格式化，之所以这样做的原因是可以把 builder 通过引用传递，从而不用在后续的递归中一次一次的声明临时 stringstream变量。BuildFormatString 使用递归的方式实现字符串的格式化，具体 实现如下。 1234567891011121314151617181920void BuildFormatString(std::stringstream&amp; builder, const std::string&amp; fmt_spec) &#123; builder &lt;&lt; fmt_spec;&#125;template &lt;typename T, typename... Types&gt;void BuildFormatString(std::stringstream&amp; builder, const std::string&amp; fmt_spec, const T&amp; first, const Types&amp;... args) &#123; auto pos = fmt_spec.find_first_of("&#123;&#125;"); if (pos &gt; fmt_spec.length()) &#123; builder &lt;&lt; fmt_spec; return; &#125; builder &lt;&lt; fmt_spec.substr(0, pos); builder &lt;&lt; first; BuildFormatString(builder, fmt_spec.substr(pos + 2), args...);&#125; 其中第一个普通函数（非模板函数）用来终止递归。这种实现方式只要参数支持 stringstream 的输出操作就可以正常的运行。这个版本并没有做过优化，比如它每 一次调用 BuildFormatString 都会产生一个 std::string 类型的临时变量用于存放 格式化说明符 fmt_spec。可以考虑通过增加一个 pos 参数来解决这个问题，或者是使 用 const char* 替代 std::string 作为格式说明符的类型。此外 builder &lt;&lt; fmt_spec.substr(0, pos) 中的子串生成可以通过循环取代。事实上直接 使用循环不会给性能带来任何的优化，因为字符的整块处理比循环单字符处理要快很多， 对于优化问题可以参考后面一小节 测试结果简单的测试代码如下： 123456789int main(int argc, char *argv[])&#123; cout &lt;&lt; FormatString("", "hello", 3.14) &lt;&lt; endl; cout &lt;&lt; FormatString(" world!", "hello", 3.14) &lt;&lt; endl; cout &lt;&lt; FormatString("&#123;&#125; world!", "hello", 3.14) &lt;&lt; endl; cout &lt;&lt; FormatString("&#123;&#125; world! PI is &#123;&#125;", "hello", 3.14) &lt;&lt; endl; cout &lt;&lt; FormatString("&#123;&#125; world! PI is &#123;&#125;", "hello") &lt;&lt; endl; return 0;&#125; 输出结果如下： 12345world!hello world!hello world! PI is 3.14hello world! PI is &#123;&#125; 如果 ‘{}’ 占位符多于实际提供的参数，占位符会被保留，反之如果参数多于占位符，参 数会被忽略。 优化2016-03-24更新，之前这个版本没有优化过，后续出于性能调优的考虑，做了一点点小 的改动，记录在此。 使用 ostringstream 替代 stringstrem上一个版本个人疏忽，使用了 stringstream 作为字符串的builder，但是实际上我们 只是使用它作为输出缓冲区，所以可以直接使用 ostringstream 替代。 find_first_of 返回值修正find_first_of 在查找失败的疏忽返回的是 string::npos 通常这个值被定义为 -1 ，但是因为它的类型 string::size_type 通常是一个无符号数，所以 npos 变成了能 表示的最大值，所以之前的 pos &gt; fmt_spec.length() 判断才能正常工作，但是这并不 是可移植的方式，正确的写法应该是： 12if (pos == std::string::npos) &#123;&#125; 使用 ostringstream::write 去掉前缀子串的创建之前的版本中为了输入前缀子串使用了 builder &lt;&lt; fmt_spec.substr(0, pos); 这样的 语句，它使得每一次前缀输入都需要生成一个前缀子串。我们可以使用 write 成员函数 去掉这个子串的创建，直接写入 string 中的一块内容。 1builder.write(fmt_spec.data(), pos); 使用位置下标去掉后缀子串的创建在之前处理完一个参数之后，通过递归的方式处理下一个参数： 1BuildFormatString(builder, fmt_spec.substr(pos + 2), args...); 这个递归调用的第二个参数会产生一个临时变量，这个变量其实可以通过位置下标去掉， 做法是更改函数的签名，让他接受一个额外的参数如下： 1234template &lt;typename T, typename... Types&gt;void BuildFormatString(std::ostringstream&amp; builder, const std::string&amp; fmt_spec, std::string::size_type idx, const T&amp; first, const Types&amp;... args); 查找的占位符的时候使用带位置信息的版本 1auto pos = fmt_spec.find_first_of("&#123;&#125;", idx); 当然写入前缀的后缀处理的时候也要相应的更改 12builder.write(fmt_spec.data() + idx, pos - idx);BuildFormatString(builder, fmt_spec, pos + 2, args...); 通过上面的这些更改，性能得到了一定的提升，对于下面的测试： 123456789101112131415161718192021222324const int kOutLoopCount = 1000;const int kInnerLoopCount = 1000000;int main(int argc, char *argv[])&#123; cout &lt;&lt; FormatString("") &lt;&lt; endl; cout &lt;&lt; FormatString("world") &lt;&lt; endl; cout &lt;&lt; FormatString("&#123;&#125; world!", "hello", 3.14) &lt;&lt; endl; cout &lt;&lt; FormatString("&#123;&#125; world! PI is &#123;&#125;", "hello") &lt;&lt; endl; cout &lt;&lt; FormatString("&#123;&#125; world! PI is &#123;&#125;", "hello", 3.14) &lt;&lt; endl; long sum = 0; for (int i = 0; i &lt; kOutLoopCount; ++i) &#123; auto beg = high_resolution_clock::now(); for (int i = 0; i &lt; kOutLoopCount; ++i) &#123; FormatString("&#123;&#125; world! PI is &#123;&#125;", "hello", 3.14); &#125; auto end = high_resolution_clock::now(); sum += (end-beg).count(); &#125; cout &lt;&lt; "average: " &lt;&lt; sum / kOutLoopCount &lt;&lt; endl; return 0;&#125; 没有优化过的版本，平均实践大概是 1294218 优化过的版本的平均时间大概是 1068972，效果还是不错的。 [^1]: std::string 在实现的时候没有考虑过多态的使用，比如它没有声明虚拟析构函 数，所以不建议继承自 std::string 扩展自己的字符串，你可以使用组合替代继承来 扩展标准库中的字符串，但是使用全局函数的方式更简单方便，所以这里采用这种方式。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 C++ 11 初始化列表和转换构造函数]]></title>
    <url>%2F2016%2F03%2F09%2Fcppx-list-initilization%2F</url>
    <content type="text"><![CDATA[C++11 统一了原本各种乱七八糟的初始化规则，采用统一的大括号初始化，所以你可以像 下面这样初始化： 1234567string s;string s = "hello world";string* s = new string("hello world");string s&#123;&#125;;string s = &#123;"hello world"&#125;;string* s = new string&#123;"hello world"&#125;; 后面的三个大括号初始化都叫做列表初始化。C++ 初始化非常的复杂，详细信息可以参考 下面这个链接。 本文主要讨论 string s = {&quot;hello world&quot;} 这种类型的列表初始化和转换构造函数的 关系。 类型转换操作符在 C++ 中和隐式转换相关的函数有两种，一种是把自身类型转换成其他类型的转换操作符 ，比如为了能够像while(cin &gt;&gt; s)这样处理输入，标准库中的流可以隐式转换成 void* 类型（不默认转换成 bool 的原因是下面这样的代码会变成合法的 std::cin &lt;&lt; 12），前面这种观点是在C++11之前的做法，在C++11中引入了显 式类型转换操作符（explicit convert operator），它使得std::cin &lt;&lt; 12这种语句变 为非法，因为没有隐式转换，同时又让while(cin &gt;&gt; s)这种语句变为合法，因为语言规 定对于到bool的转换，在条件语句中（包括，if, for, while 等）会自动完成，所以目 前 stream 的类型转换符声明为explict operator bool(): 12345class basic_ios &#123;public: operator void*() const; // c++98 explicit operator bool() const; // c++11&#125;; 转换构造函数另一种是把其他类型转换成自身类型的构造函数，比如下面的简化的 string 定义^1： 1234class string &#123;public: string(const char* s);&#125; 在 C++98 中这种只需要一个参数就可以调用，而且没有声明成 explicit 的构造函 数，我们称之为为转换构造函数，这种构造函数使得 1std::string str = "hello world"; 这样的语句成为合法的语句，理论上编译器会通过转换构造函数生成一个临时变量，然后 通过拷贝构造函数初始化str（不过实际上这个临时变量在绝大部分的编译器中都会优 化掉）。 C++11 为了统一初始化的语法，扩展了转换构造函数的定义，只要没有声明为 explicit 的构造函数都是转换构造函数。所以下面的代码在 C++11 中是合法的： 1std::pair&lt;int, int&gt; ipair = &#123;1, 2&#125;; 这是因为 pair 类似下面这样的构造函数： 1pair(const T1&amp;, const T2&amp;); 当编译器看到 {} 类型的列表初始化的时候，会查找相应的转换构造函数，然后构造一 个临时变量，然后通过临时变量初始化 ipair（当然这也是理论上的，编译器绝大多数 都会把这个临时变量优化掉）。注意这种初始化不允许值的narrow convert比如把 double 变成int, 所以下面的代码会报错。 123456class Narrow &#123;public: Narrow(int a, int b);&#125;;Narrow narrow = &#123;1, 2.0&#125;; initilizer_list在 C++11 中为了统一初始化语法，还引入了 initilizer_list 类型，代表一个同构的 值序列，所以你可以像下面这样写代码： 1234foo(std::initilizer_list&lt;int&gt; list);foo(&#123;1, 2, 3&#125;)foo(&#123;4&#125;) 编译器会自动把大括号内的值封装成一个initilizer_list。当然我们也可以让构造函 数接受 initilizer_list 作为它的参数。 1234class IntVector &#123;public: IntVector(initilizer_list&lt;int&gt; list);&#125; 这时候我们也可以像下面这样初始化 IntVector： 1IntVector iv = &#123;1, 2&#125;; 这种构造函数叫做 initializer-list constructor（这个名称我从 C++11FAQ 中得知，应该是通用的术语）这种构造函数的优先级要高于普通的构造函数。所以如果我 们还有另外一个构造函数： 12345class IntVector &#123;public: IntVector(int a, int b); IntVector(initilizer_list&lt;int&gt; list);&#125; IntVector iv = {1, 2} 这条语句调用的是initializer-list constructor。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《程序设计实践》]]></title>
    <url>%2F2016%2F02%2F29%2Ftpop-note%2F</url>
    <content type="text"><![CDATA[作者布拉恩.科尼汉（Brian W.Kernighan）是一座高山，难得一见的大师级的人物。C 语言圣经K&amp;R中的 K 指的是他，awk 语言中的 K 也是他。它写过很多久负盛名 的书籍，比如《C程序设计语言》，《UNIX 编程环境》，《编程风格元素》和这本《程序 设计实践》。 大师写的书基本上都是一个基调，言简意赅，字字珠玑，简洁但不简单。这本书没有任何 的废话，从前言到附录，每一个部分都能让你受益匪浅。这本书很薄，却无所不包，分成 九个章节，每一章都讲述了程序设计环节中的重要问题。这本书可以和前阵子读的《程序 员修炼之道》相媲美，强烈推荐每个程序员认真的读一读（不管你是不是主要用C语言 做开发） 英雄所见通常略同，这本书和原来看过的很多书有重合，但是这本书讲的更加清晰明了。 这也体现了书名中的实践二字，这本书提到了很多其他书籍都泛泛而谈的金科玉律的实 践方式。 编码风格关于菜鸟和大牛之间的差距，有人说体现在代码调试能力上，有人说体现在文档阅读能力 上，我更认同的观点是体现在代码风格之上。一段好的代码是美的，优雅的，这是每一个 程序员都应该追求的境界，代码的简单、清晰、直白远比刻意的高效重要的多。 很多人建议名字起的越长越好，但是起名好坏的关键不在于长短而在于清晰，传达它的目 的，而清晰性和作用域相关。 123for (theElementIndex = 0; theElementIndex &lt; numberOfElements; theElementIndex++) elementArray[theElementIndex] = theElementIndex 这样的代码相比于下面的代码真的没有任何值得推荐的地方 12for (i = 0; i &lt; nelement; i++) elem[i] = i 很多人觉注释越多越好，但是代码本身的简单和清晰比冗长的注释要重要的多。你应该首 先改进自己的代码，如果代码实在比较难以做到清晰，加上适当的注释并在修改了代码的 时候保持和代码的同步更新。 算法和数据结构对于我们大部分的人来说，学习算法和数据结构不在于自己发明新的算法和数据结构而在 于选择，让你在遇到问题、需要优化的时候能够有所选择。数据结构的四大金刚：数组、 链表、二叉树、哈希表是每程序员都应该了解的。 设计和实现这一章给出了马可夫链文字自动生成程序的设计和 5 种不同的语言的实现，我也试过用 Python 重写了该程序。一个程序员需要掌握多门语言，不在于炫耀自己的技术而在于选 择和权衡，如果你只会 C 语言，那么即使在不需要过多考虑性能的地方你也没有机会 享受到C++、Python 带来的开发效率上的提升。 程序的设计通常和你选择的实现语言无关，但是和你选择的数据结构有关，你使用的数据 结构通常就决定了你使用的算法。你应该选择简单清晰的算法和数据结构，然后不断的迭 代的，因为没有人可以一触而就。此外产品级别的代码需要不断的打磨和测试。 接口这一章首先展示了一项非常有用的技术——原型——一个在各种书籍中说烂了的技术，这本书 给出了它如何应用的实际例子。代码不可能一次成功，我们不应该坐在自己座位上苦思冥 想，我们应该开始写代码，建立一个原型，尝试自己的算法。你不是天才，不管你多自恋 ，你都不可能天才到一次把程序写对。 关于接口最重要的东西应该是它的接口说明（specification），在《程序员修炼之道》 中作者把它称为合约（contact），个人理解这两个概念殊途同归——告诉别人你需要什么 ，你提供什么，这是一种供求双方的协议。 好的的接口设计还要考虑很多其他的问题，比如：信息隐藏、资源管理、错误处理等等。 有些语言提供原生的支持比如C++的访问控制、RAII、异常处理等，有些语言却要设计者 自己处理和权衡这些问题，比如 C 程序员。 调试代码预防的越好，BUG 越少，调试所花费的时间就越少，所以你应该先读一读第一章。 关于大部分人想到调试第一反应是借助调试器，打断点，单步跟踪，在作者看来，这是最 后一招。你应该先理性的分析一下BUG出现的现象，看看出错的时候的栈帧信息，查查 你最近的修改，和别人讲讲你的代码，定位最可能出错的地方，实在不行就休息休息，这 些方式比你用调试器快很多。 测试测试的首要原则是——你得做测试。 你自己写的代码，你自己应该做测试，不要依靠测试人员帮你做测试，因为没有人比你自 己更懂你自己写的代码。测试不是为了证明你的程序是对的，而是尽可能找到你的程序中 可能出错的地方。没有人的程序是没有错的，即使是像高德纳这样的上帝级别的人物写的 程序一样会出错。 我们应该在自己写代码的同时就开始测试，写一点测试一点，而不是写完了再一次性的测 试。检查你的边界条件，测试你的先决条件和后置条件，使用断言，防御性的编程。这些 方法恰恰是《程序员修炼之道》中按合约编程的实践方式。 我们需要全面的测试，你可以使用不同的方式实现同一个问题，对比两者的输出，如果不 一样，那至少有一种方式是错误的。你可以用一种非常简单低效的方式实现同一个问题， 然后用它对比你自己的版本，如果结果不同，很大的可能是你的程序有问题。 自动测试在《程序员修炼之道》中也有提到，但是这里给出了实践方式。你需要使用到一 些脚本语言来帮助你完成自动化的操作，比如awk，python等。 性能调优如果不必要，不要尝试调优，最简单直接的方式编写的代码最有可能接近正确。 如果你一定要做优化，先用 profiler 查一查性能的瓶颈是在什么地方，在无关紧要的 做优化只会浪费你的时间。 优化要适可而止。 可移植性不要使用标准以外的特性，标准之内的特性使用主流的部分（那些大家都在用，确定不 会有未定义问题的特性），如果你必须问一个语言专家才能一个特性是否是可移植的， 不要用它。 对于C和C++的条件编译很多人说它是可移植性的助手，实际上他们却是可移植性的大忌， 不要使用他们。条件编译使得你看到的代码可编译器看到的代码不一致，它使得代码非常 难以理解和测试。你的程序在这个平台上可以正常运行只是说明编译器看到的那一部分代 码正常运行，你换一个平台可能立马出错。 我们应该使用抽象，把平台相关的细节隐藏在实现细节中，把和平台相关的代码移动到独 立的文件中，比如linux平台的实现放在linux.cpp，windows平台的实现放在 windows.cpp中，通过编译选项选着合适的实现。这样你的代码会清晰很多，也更容易 扩展，更容易测试。 如果你涉及到数据的交换，最好使用文本格式，你可能会丢失一些性能，但是对于可移植 性来说有非常大的好处，而且会使得你数据处理更加简单。 记法我原来一直不太理解《程序员修炼之道》里面作者说的“领域语言”是什么意思，也不太理 解《设计模式》里面说道的解释器模式有什么作用，更不理解为什么《黑客与画家》里面 作者会鼓吹 lisp 语言中强大到可以自动编程的宏。这一切都在我看到这本书的第九章 ：Notation 之后变得豁然开朗 领域语言根本就不神秘，我们大量使用的 printf 格式化记号就是其中之一，几乎每个 语言中都包含的正则表达式也是如此。在“问题域”和“解决域”之间一直都存在鸿沟，为了 让你可以更方便的跨越这条鸿沟，你可以自己指定一门靠近问题域的语言，让你可以通过 问题域中的术语来编程。这看上去很高大上，但是语言不过是记号而已，你可以指定非常 简单的记号，比如正则表达式，比如printf的格式说明符。 自动生成代码根本就没有那么神秘，编译器本身就是机器代码的自动生成工具。早期的 C++ 编译器 cfront 把 C++ 代码转换成 C 语言代码，从这个角度看 cfront 就是一个代码生成器。 一切的一切又回到解决问题的王道：增加一个中间层。领域语言就是这个中间层，我们不 必非得自己写一个编译器来实现我们自己的语言，我们可以通过代码转换器转换成更底层 的语言比如C++/C，我们可以使用简单的脚本语言来帮我们完成这一转换。]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 正则表达式疑难点]]></title>
    <url>%2F2016%2F02%2F26%2Fpython-regx-note%2F</url>
    <content type="text"><![CDATA[^ 和 \A 以及 $ 和 \Z 的区别Python 的文档中对于这几个的记号的含义解释如下： ^ Matches the start of the string, and in MULTILINE mode also matches immediately after each newline. $ Matches the end of the string or just before the newline at the end of the string, and in MULTILINE mode also matches before a newline. foo matches both ‘foo’ and ‘foobar’, while the regular expression foo$ matches only ‘ foo’. More interestingly, searching for foo.$ in ‘foo1\nfoo2\n’ matches ‘ foo2’ normally, but ‘foo1’ in MULTILINE mode; searching for a single $ in ‘foo\n’ will find two (empty) matches: one just before the newline, and one at the end of the string. \A Matches only at the start of the string. \Z Matches only at the end of the string. 从上面的文档看 $ 和 \Z 的含义只有在 MULTILINE 模式下才会有区别，比如说下面 的例子[^1]: [^1]: 例子来自 stackoverflow 1234&gt;&gt;&gt; re.search(r'^word', 'Line one\nword on line two\n', flags=re.M)&lt;_sre.SRE_Match object; span=(9, 13), match='word'&gt;&gt;&gt;&gt; re.search(r'\Aword', 'Line one\nword on line two\n', flags=re.M) is NoneTrue 1234&gt;&gt;&gt; re.search(r'word$', 'Line one word\nLine two\n', flags=re.M)&lt;_sre.SRE_Match object; span=(9, 13), match='word'&gt;&gt;&gt;&gt; re.search(r'word\Z', 'Line one word\nLine two\n', flags=re.M) is NoneTrue \number 的含义说来惭愧，这里这个记号其实在大部分语言的的正则表达式中都存在，孤陋寡闻的我以 为只有 Python 中存在这种语法。（2016-03-21） 这个记号我以前没有在其他语言的正则表达式中见过，它表示前面匹配的第 number个组的内容，Python 文档中给出的含义如下： Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \1 matches ‘the the’ or ‘55 55’, but not ‘thethe’ (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the ‘[‘ and ‘]’ of a character class, all numeric escapes are treated as characters. 主要的点有下面几个： 匹配 number 组中的内容 组号从 1 开始 只能匹配前面99组之中的组 如果 number 以 0 打头或者是三位的 8 进制值，会被当成普通字符 如果在 [] 之间会被当成普通字符 比如说下面的例子 1234567&gt;&gt;&gt; re.match(r'(.+) \1', '555 555') is not NoneTrue&gt;&gt;&gt; re.match(r'(.+) \01', '555 \01') is not NoneTrue&gt;&gt;&gt; re.match(r'(.+) [\1]', '555 \1') is not NoneTrue&gt;&gt;&gt; 这个看起来比较诡异的功能在匹配 HTML 或者 XML 标签的时候比较有用比如： 12345&gt;&gt;&gt; re.match(r'&lt;(\w+)&gt;\w+&lt;/\1&gt;', '&lt;a&gt;python&lt;/a&gt;') is not NoneTrue&gt;&gt;&gt; re.match(r'&lt;(\w+)&gt;\w+&lt;/\1&gt;', '&lt;p&gt;python&lt;/p&gt;') is not NoneTrue&gt;&gt;&gt; (?P&lt;name&gt;) 和 (?P=name) 的含义通常来说在正则表达式中(...)代表分组，但是在 python 中(?...)表示一种扩展， 比较好用的是(?P&lt;name&gt;)和(?P=name)这两个。前面提到可以用()分组，然后用 \number 引用组中的内容，但是当分组很多的时候 \number 就比较难以维护。Python 中对于这种问题的解法通常都是用名字代替数字比如字符串格式化中的做法 12345&gt;&gt;&gt; '&#123;0&#125; and &#123;1&#125;'.format('Tom', 'Jerry')'Tom and Jerry'&gt;&gt;&gt; '&#123;tom&#125; and &#123;jerry&#125;'.format(tom='Tom', jerry='Jerry')'Tom and Jerry'&gt;&gt;&gt; 正则表达是中也可以用命名的方式替换掉 \number 记号，方法就是通过 (?P&lt;name&gt;) 给分组起名字然后通过 (?P=name) 引用分组。例如： 123&gt;&gt;&gt; re.match(r'&lt;(?P&lt;TAG&gt;\w+)&gt;\w+&lt;/(?P=TAG)&gt;', '&lt;a&gt;python&lt;/a&gt;') is notTrue&gt;&gt;&gt; search() 和 match() 的区别search() 和 match() 的主要区别是 match() 只会匹配字符的开头，而 search() 会搜索字符的任何位置。另一个区别就是对于 MULTILINE 模式，^ 标记， 使用 search() 可以搜索逻辑行开始而 match() 只会匹配物理行开始^2。 看下面的例子[^3]： 12345678910111213141516171819202122# example code:string_with_newlines = """somethingsomeotherthing"""import reprint re.match('some', string_with_newlines) # matchesprint re.match('someother', string_with_newlines) # won't matchprint re.match('^someother', string_with_newlines, re.MULTILINE) # also won't matchprint re.search('someother', string_with_newlines) # finds somethingprint re.search('^someother', string_with_newlines, re.MULTILINE) # also finds somethingm = re.compile('thing$', re.MULTILINE)print m.match(string_with_newlines) # no matchprint m.match(string_with_newlines, pos=4) # matchesprint m.search(string_with_newlines, re.MULTILINE) # also matches [^3]: 例子来自 stackoverflow]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 多态性继承和非多态性继承的区别]]></title>
    <url>%2F2016%2F02%2F24%2Fpoly-and-inher%2F</url>
    <content type="text"><![CDATA[在 C++ 中多态的实现是以继承为基础的，但是这门语言的演化中继承早于多态出现，继承 不一定就意味着多态的使用^0。在后文中我把用于多态的继承称为多态性继承，不用于 多态的继承称为非多态性继承^1。 多态被称为面向对象编程的核心，可以比较确定的说在 C++ 中多态性的继承应该比非多态 性的常用的多。那么这两种继承模型之间主要区别是什么呢？这就是本文将要讨论的问题 。 注意：本文中讨论的关于C++ 多态性和非多态性继承区别并不是C++的一项准则而是一种 最佳实践。 区别个人认为多态性继承和非多态性继承的关键区别点在于：两种模型中基类和派生类的作用 不同。 在多态性继承中，基类的主要作用是提供接口^2，子类的主要作用是提供接口的实现 在非多态性继承中，基类的主要作用是提供实现，子类的主要作用是为实现封装接口 多态性继承：父类接口、子类实现这一点应该比较好理解，因为这正是多态的基本功能所在： 12345678910111213141516171819202122class Shape &#123;public: virtual double Area() = 0; // 父类提供接口&#125;;class Rectangle : public Shape &#123;public: Rectangle(double x, double y) : _x(x), _y(y) &#123; &#125; virtual double Area() &#123; return _x * _y; // 子类实现 &#125;private: double _x; // 这里只是举例子，矩形的表示通常 double _y; // 是通过两个顶点而不是两条边。&#125;;// 用户代码Shape* shape = new Rectangle(2, 3);shape-&gt;Area(); 在多态中我们通常使用的是父类提供的接口多态的调用子类提供的实现，而在非多态性继 承模型中则通常是相反的。 非多态性继承：父类实现、子类接口这一点听起来比较诡异，而且你完全可以写出不符合这种模式的代码，但是从许多最佳实 践的角度来看，确实是如此的，比如使用 Deque 来实现一个 Stack 和 Queue： 1234567891011121314151617181920212223242526272829303132class Deque &#123;public: void push_back(int val); void push_front(int val); int pop_back(); int pop_front();&#125;;class Stack : private Deque &#123;public: void push(int val) &#123; // 这里可以直接写成 push_back 不过为了强调 // 父类实现特意加上了父类名。 Deque::push_back(val); // 使用基类的实现 &#125; int pop() &#123; Deque::pop_back(); // 使用基类的实现 &#125;&#125;;class Queue : private Deque &#123;public: void push(int val) &#123; Deque::push_back(); // 使用基类的实现 &#125; int pop() &#123; Deque::pop_front(); // 使用基类的实现 &#125;&#125;; 非多态性的继承的优势不使用多态最大的优势在于效率和开销，你不用为每一个对象付出额外的 vptr 的空间 开销，也不用为方法的调用付出间接调用的开销。而且你可以让你的类在栈中分配，进一 步提高效率。 比非多态性继承更好的方式注意上面我使用了 private 继承而不是 public 继承，因为我们需要的是父类的实现而不 是它的接口。但是这种方式目前来说并不是最佳的方式，更好的方式是使用组合替代继承 ： 12345678class Stack &#123;public: int pop() &#123; return _container.pop_back(); &#125;private: Deque _container;&#125;; 这种方式比继承有更大的灵活性，因为继承使得 Deque 和 Stack 这两个类耦合在一 起，而使用组合就没有这个问题。 两者其实可以综合上面描述的只是一种简化现象，在 C++ 的现实世界中事情远远要比这里讨论的复杂的多。 1234567891011121314151617class Base &#123;public: virtual bool Init() = 0;&#125;;bool Base::Init() &#123; // 实现父类的初始化&#125;class Drived : public Base &#123;public: virtual bool Init() &#123; // 实现父类的接口 if (!Base::Init()) &#123; return false; &#125; // 使用父类的实现 // 初始化派生类 &#125;&#125; 上面的 Base 类中的Init^3既提供了实现又提供了接口。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《黑客与画家》]]></title>
    <url>%2F2016%2F02%2F18%2Fhackers-and-painters-note%2F</url>
    <content type="text"><![CDATA[这本书发人深省，作者思想深邃到让人不寒而栗，很多事情原来从来没有想过，作者以 他非凡的洞察力和缜密的逻辑思维把问题讲解的非常透彻，文字生动而幽默，一切都像故事 一样娓娓道来，让人欲罢不能。 作者保罗.格雷厄姆是硅谷的创业教父，整本书也可以说是写给创业者的指南，包括为什么 要去创业、如何找到创业的突破口、如何选择创业的技术、如何设计产品、如何开发产品等 等。 作者本身是一名黑客，和大多数黑客一样推崇极致。你需要进度的努力才可能会得到极大的 回报，才可能在创业的大浪淘沙中存活下来。 这是一本个人文集，里面充斥着各种个人的思考和偏好。作者以传销式的手法向你描述他对 于问题的看法。所以在阅读这本书之前请你先做好思想准备，也许读完之后，你就不在是你 了。 我学到了什么一个能说会道的书呆子可以改变整个世界。 为什么书呆子不受欢迎一文中的观点我非常认同，别人笑我太疯癫，我笑他人看不穿 也许我现在在做的事情遭到很多人的鄙视，也许很多人觉得我不可理喻，但是我有自己内心 坚定的信仰，不必太在乎别人对你的看法。知道自己在需要做什么，并坚持做下去比其他的 事情都更重要，我也许成为不了一个技艺精湛的黑客，但是我时刻都关注自己的技艺的增长 。不要忘记时刻关注自己的技艺。 黑客与画家讲述了很多浅显但是容易被人忽视的道理，程序员应该像画家、建筑师和作 家一样创作，关注作品的美感，写程序要像写诗一样优雅。写程序有很多地方可以借鉴绘画 。比如你应该开始画（写程序）然后慢慢的清楚自己要画什么（最终的程序是什么样子）； 比如你应该逐步完成你的作品（程序）而不是一次全部搞定，这一点和现在备受推崇的迭代 不谋而合；比如你需要一丝不苟的对待你自己的作品（代码）；比如你需要趁你有很好的状 态的时候进行开发；比如你和别人合作的时候需要有明确的分工，否则代码会变成一团乱麻 ；比如你需要不断的练习才能成为熟练的画家（程序员）；比如你可以通过不断的观摩前人 优秀的画作（开源项目）来提升自己的境界。 不能说的话一文告诉我们社会上的种种世俗观念背后其实存在很多不能说的谬误，找到 这些东西会有利于得到你超乎常人的优势，这些地方是你很有可能突破成为创业的项目。自 由的思想，独立的精神能够帮助我们走的更远。 在另一条路一文中作者鼓吹了互联网软件的发展前景，其实这些年的互联网创业浪潮很 好的印证了作者的观点，如果说找到风口能让猪飞起来，这就是风口之一，但是这个口上现 在已经站满了各种各样的猪。虽然互联网软件目前来说还是一个很有活力的领域，但是它似 乎没有了刚开始的那种占据先机的优势了。相对来说移动互联网的热度似乎在持续的上升， 而IoT的概念也在不断的普及开来，未来什么地方才是真正的风口我这种凡夫俗子实在难以 洞察。 创造财富一文和关注贫富分化一文基本上就是在告诉我们为什么需要去创业，我们 可以通过创造出对社会有价值的东西来获得财富，我们可以在大公司上班创造价值，但是我 们的贡献会被平均化，但是通过创业我们通过更努力的工作来得到更大的价值而不会被其他 人平均化。社会之所以出现贫富差距是因为每个人可以创造出的价值是不一样的，每个人的 能力有不同所以创造出来的价值就不一样。作者没有提到剩余价值理论，或者他们根本不认 同这一点，不过就算考虑了剩余价值理论，我们仍然不能否认每个人因为自身能力的不同创 造出来的价值是不一样的，最终导致贫富差距。 设计者的品味一文让我耳目一新之处在于他解释了品味因人而异的荒谬性。提升自己的 品味才能做出好的设计。好的设计简单、不过时、解决核心问题、有趣味性等各种特性。记 得老大说品味上去了就很难下的来。 最后几篇文章是关于编程语言的，作者极度推崇Lisp这类的魔幻语言，他显然不喜欢静 态语言，也不喜欢那些为了防止出错而做的多余的设计。在作者看来把用户当成是傻瓜而设 计的东西必然会被用户看成是很傻的设计。作为黑客他也许是对的，因为他有着丰富的经验 和高超的技艺，但是这一类的高手毕竟还是少数，大量的初学者需要编译器的帮助来解决各 种高手们看起来很弱智的BUG，所以作者极度推崇Lisp，但是作为小菜的我短时间内还不会 去使用这门语言。 设计与研究非常的简单，核心思想是使用原型，这个概念在大量的书籍当中都有推荐， 是非常有用的技术。 更多的内容这本书只是作者文章的一小部分，他还有大量的文章在自己的个人网站中，有兴趣的同学如 果英语够好可以看看PAUL GRAHAM。 另外这本书的翻译质量非常的高，译者阮一峰也是一个非常有名的博主，如果感兴趣可以看 看他的个人博客——阮一峰的网络日志]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《C++ 语言的设计和演化》]]></title>
    <url>%2F2016%2F02%2F17%2Fcpp-design-evolution-note%2F</url>
    <content type="text"><![CDATA[这本书讲述C++语言的设计和演化，可以让你对于C++的各种特性达到知其然更知其所以然的 境界。很遗憾，这本书没有读完，因为实在读不下去，原因是我比较作死的买了一本英文影 印版的旧书（目前市面上该书已经绝版），但是本贾尼的文法和用词习惯实在太过于高深， 我很艰难的读完了第一部分，却失去了读第二部分的勇气。以前太过自负了，以后读技术专 著有口碑不错的中文译本还是不要过于追求原滋原味的好。此外这本书是过年前几天开始阅 读，年后各种走亲访友，没有时间安心的看书，使得这本书的阅读过程断断续续的，最终也 就没有阅读下去的欲望了。 半本书的体会这本书我虽然只是读了半本，但是还是有许多的感悟。其中最大的感悟是谢谢所有为创造 C++ 付出过努力的人，C++不像JAVA有强大的公司作为后盾，它的发展很长的一段时间都 只有本贾尼一个人在支撑着，很多人吐槽C++设计很糟糕，但是又有谁去仔细的想过这门语 言发展到现在，那些语言的设计者们在背后付出了多少的努力呢。 C++可以说是用户驱动型的语言，它随着时间不断的演化，不断的解决用户提出的问题，不 断的添加用户们想要的特性。它很核心的一个设计理念是不强迫用户使用某种单一的方式 去解决问题，很多人JAVA的使用者用怜悯的口吻说C++不是纯粹的面向对象，却永远不知 道C++从来就没有考虑郭纯粹的面向对象。语言的设计不是美学创作，C++的目标不是创造出 完美的语言而是提供目前可用的问题解决方式。这种方式也从来都不是单一的，用面向对象 （这里指虚函数）可以解决的很多问题，使用泛型也可以解决。C++提供各种特性以供用户 自己选择最佳的方式，比如为了效率的考虑只使用实体类（有的书上称为ADT或者 class-based），为了灵活性选择虚拟类。没有哪一种方式天生就优于另外一种方式，所以 C++提供了各种方式供你选择，所以在C++中会存在四种编程范式，这也是很多人吐槽这门语 言非常臃肿的一个原因。 不要把C语言的过错归结到C++中去，很多人吐槽说C++语言中的坑太多，其实很大一部 分的坑来自C语言，而不是C++的本身。C++在设计的时候很想填上C语言中原有的坑，但是为 了尽可能的兼容C语言，它保留了大部分C中原有的缺陷。关于这一点陈浩的《C++的坑真的 多吗》 一文有比较详细的讨论，建议大家阅读。C++为了改进C语言中的一些坑 其实做了很多努力，比如inline函数、namespace、const 等等。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在C++类声明中为什么既包含接口又包含实现]]></title>
    <url>%2F2016%2F02%2F07%2Fwhy-cpp-declaration-has-interface-with-implement%2F</url>
    <content type="text"><![CDATA[包含接口和实现的类声明C++备受一些人吐槽的一点是它在类的声明中既包含了实现细节又包含了接口细节，比如： 123456789#include "Point.h"class Circle &#123;public: double Area(); // 接口private: double _radius; // 实现 Point _center; // 实现&#125;; 这其中带来的很大的一个问题就是有时候即使只是改变类内容的实现细节（比如Point 类 定义发生了变化，或者把_radius变成 float 类型），类的用户也需要重新编译自己的程 序（这通常称为编译依赖），这一点让很多人难以接受。（当然还存在其他问题，比如用户 知道了实现细节就可以通过一些手段欺骗编译器，写出一些依赖实现而不是依赖接口的代码 ）。 为什么C++会如此定义这种方式来自C++的前身C With Class，该语言的设计初衷是结合Simula语言在程序组 织上的便利性和C语言本身的高效性。当年C++之父使用Simula写模拟器，发现类的概念非 常好用，但是最终因为Simula本身效率非常的低而不得不使用BCPL语言重写。 他发现Simula之所以低效的一个很重要的原因是无法在栈和静态数据区（存放全局变量、 静态变量的区域）中创建用户自定义的对象（其中的原因我不清楚，不过从《C++语言的设 计和演化》一书中的论述来看，应该是因为它把类接口声明和类实现声明分离开来了）。 为了能够像下面的代码一样在栈中创建一个对象： 123456#include "Circle.h"void test_circle() &#123; Circle circle; circle.Area();&#125; 编译器必须在编译期间知道circle对象占用多大空间。把实现细节放在类的声明当中让 这一点变成可能而且实现较为简单。所以出于效率方面的考虑C With Class使用了这种方 式，之后的C++语言沿用了这一方式。 当然这么做的另一个原因是让用户自定义类型的对象模型和C语言的结构体的对象模型能够 兼容。 允许不代表必须在C++的设计和演化中，有一个永恒不变的指导思想就是不强迫用户使用单一的方式解决问 题（这估计也是C++领域会有那么多的最佳实践的书籍的原因）。C++允许你这么做，但是不 强迫你把实现细节写在类的声明当中。你如果不想让你的用户知道任何的实现细节，或者说 你想要摆脱编译依赖，你完全可以这样写。 12345678910111213141516171819202122// 给用户的接口class Circle &#123;public: static Circle* CreateNew(); virtual void Area() = 0;&#125;;// 隐藏在用户背后的实现class CircleImp : public Circle &#123;public: virtual void Area();private: double _radius; Point _center;&#125;;// 用户代码void test_circle() &#123; Circle* circle = Circle::CreateNew(); circle-&gt;Area();&#125; 这种做法需要使用到虚拟函数机制，所以会有一定的开销（主要是vptr和通过指针间接调用 函数的开销），而且没有办法在栈上面创建对象（静态存储区域中也是如此）。如果你不想 要这些开销，你可以通过“pointer to implement”机制屏蔽掉实现的细节。 123456789class CircleImp;class Circle &#123;public: void Area();private: CircleImp* _imp;&#125;; 这样一来，你可以通过不完整类型CircleImp来隐藏实现信息，当然它还是需要间接指针 调用的运行开销，但是开销相对于上面的方式来说会小很多（至少你可以再栈中创建该类型 的对象）。此外上面两种方式基本上都没有办法正常的实现内联，所以内联带来的性能提升 你无法享受。这些方式都不是最高效的方式，不过毕竟你最关心并不是效率对吗，否则你完 全可以把实现细节写在类的声明当中。 关于以上讨论的更详细的内容请参考《Effective C++》和《C++语言的设计和演化》两本书 。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 学习资源的汇总]]></title>
    <url>%2F2016%2F02%2F05%2Fcpp-gurues-blogs%2F</url>
    <content type="text"><![CDATA[我大学的时候学《论语》，老师给我们说了一句至今让我记忆犹新的话：如果你想要成为国 学大师，你需要有大师在你的身边指引。 C++是一门比较难以精通的语言，想要成为大师需 要有大师的引导。很不幸的是大师可遇而不可求，幸运的是网络时代让我们离大师越来越近 ，甚至触手可及。接收大师的熏陶的一种方式是拜读他们的作品，你可以去读他们的书或者 你也可以去读他们的博客。 C++ 相关的博客/网站/文摘 Bjarne Stroustrup：C++语言之父 Scott Meyers：《Effective》系列书籍作者 Stan Lippman：《C++ Primer》、《深度探索 C++对象模型》、《Essential C++》的作者 Herb Sutter：《Exceptional》系列书籍作者 isocpp：C++ 标准 国内不错的C++文摘： 伯乐在线 酷壳 C++ 必读书籍在 Stack Overflow 上有一个非常火的问题：The Definitive C++ Book Guide and List 上面罗列了大量的C++精品书籍，这里是一份中文翻译（翻译原文出自计算 机书籍控 ，但是翻译比较陈旧，我参照目前的答案原文进行了更新）： 初级如果你是一个无编程经验的C++初学者 《C++程序设计原理与实践》(Programming: Principles and Practice Using C++ )作 者： Bjarne Stroustrup（更新到C++11/C++14） C++之父写的C++入门书籍。本书面 向没有编程经验的初学者，但相信有编程经验的人也能从本书中学到不少东西。 如果你有其它语言经验的C++初学者 《C++ Primer》作者：Stanley Lippman, Josée Lajoie, and Barbara E. Moo （更新 到 C++11） 近1千页，本书透彻的介绍了C++，以浅显和详细的方式讲到C++语言差不多 所有内容。2012 年8月发行的第五版包含C++11的内容。（不要和 C++ Primer Plus (Stephen Prata) 搞混了，该书远不及前者受欢迎。） 《C++ 语言导学》(A Tour of C++) 作者： Bjarne Stroustrup，这本导学书籍是一本关 于 标准C++（包括语言本身和标准库，使用C++11标准）的所有方面的快速（分成14章 ，大概 180页）入门教程。这本书站在一个相对较高的级别向已经了解C++或者至少是有 经验的程序员介绍C++。这本书是《C++ 程序设计语言第四版》一书中2-5章内容的一个扩 展。 《Accelerated C++》作者：Andrew Koenig and Barbara Moo 这本书覆盖了和C++ Primer 一样的内容，但厚度只有C++ Primer的四分之一。这主要是因为本书面向的不是 编程的初学者，而是有其它语言经验的C++初学者。对于初学者，本书学习曲线稍显陡峭 ，但对于能克服这一点的学习者而言，它确实非常紧凑的介绍了C++这门语言。（历史上 ，这是一本划时代的书籍，因为它是第一本使用现代方法向初学者教授语言的书籍） 《C++编程思想》(Thinking in C++)作者：Bruce Eckel 共两卷，是一本教程式的免费入 门书籍，可惜的是这本书被充斥着许多低级错误（比如书中认为临时变量默认都是const ），并且没有官方的勘误列表。在 （http://www.computersciencelab.com/Eckel.htm） 中有一份不完整的第三方勘误列表，可惜的是这份文档目前明显不再维护。 最佳实践 《Effective C++》作者：Scott Meyers 本书以瞄准成为C++程序员必读的第二本书籍而 写， Scott Meyers成功了。早期的版本面向从C语言转过来的程序员。第三版修改为面向 从类似 Jave等语言转来的程序员。内容覆盖了50多个很容易记住的条款，每个条款深入 浅出（并且有趣）讲到了你可能没有考虑过的C++规则。关于C++11和C++14的例子和一些 过时的信息可以参考《Effective Modern C++》。 《Effective Modern C++》作者：Scott Meyers 本书基本上可以看成是《Effective C++ 》一书的最新版本, 书籍的主要目的是帮助C++程序员完成从C++03到C++11和C++14 的过渡。 《Effective STL》作者：Scott Meyers 讲解方式和Effective C++类似，但内容主要面 向于 STL 。 中级 《More Effective C++》作者：Scott Meyers 更多（深入）关于C++的规则。没有前一本 Effective C++重要。但同样值得一读。 《Exceptional C++》作者：Herb Sutter 讲解方式为提出并解决一系列的C++难题。本书 极其透彻的讲解了C++资源管理、异常安全和RAII。同时覆盖了一些较为深入的技术，比 如：编译防火墙(pimpl idiom)、名字查找规则,、好的类设计和C++内存模型。 《More Exceptional C++》作者：Herb Sutter 讲到了Exceptional C++没有涉及到的更 高级的异常安全技术, 同时讨论了高效的C++ OOP方式和如何正确的使用STL。 《Exceptional C++ Style》作者：Herb Sutter 讨论了泛型编程、最优化和资源管理。 本书出彩之处在于谈到了如何用非成员函数和单职责原则编写模块化的C++代码。 《C++编程规范》(C++ Coding Standards) 作者：Herb Sutter and Andrei Alexandrescu “编程规范”这里并不是”代码缩进要用几个空格”。这本书包含了101个例子 、惯用法、缺陷，通过这些可以帮助你编写正确、清晰高效的C++代码。 《C++ 模板完全指南》(C++ Templates: The Complete Guide)作者：David Vandevoorde and Nicolai M. Josuttis 本书是关于C++11之前的模板的。它覆盖了从非常基础到最高 级的元编程知识，解释了模板工作原理的细节（概念和实现方式）。并且讨论了大量的缺 陷。附录中包含关于ODR和重载的精彩总结。 高级 《C++设计新思维-泛型编程与设计模式之应用》(Modern C++ Design ) 作者：Andrei Alexandrescu 泛型编程鼻祖级书籍。本书先介绍了基于策略（policy-based)的设计、 type lists 和泛型编程基础， 然后讲到了许多有用的设计模式(包括small object allocators, functors, factories, visitors, and multimethods) 如何被高效、模块 化、清晰的泛型代码实现。 《C++模板元编程》(C++ Template Metaprogramming) 作者：David Abrahams and Aleksey Gurtovoy 更多的是讲解boost::mpl，想要深入理解mpl的可以看一下。 《C++并发编程实践》(C++ Concurrency In Action) 作者：Anthony Williams 这本书主 要内容是C++11的并发支持，包括线程库、原子(atomics)库、内存模型、锁和互斥量。同 时也讲解了开发和调试多线程程序的一些难题。 《Advanced C++ Metaprogramming》 作者：Davide Di Gennaro 前C++11时代TMP技术的 手册级书籍。本书更侧重于工程实践。里面有大量的可能几乎无人知道但很实用的技术写 成的代码。本书可能比Alexandrescu的书更值得读。对于资深的开发者来说，这是一个学 习C++ 暗角技术的绝佳机会，通常这些技术要通过资深的编程经历才能获取。 手册类 —— 适合所有级别读者 《C++程序设计语言》(The C++ Programming Language) 作者：Bjarne Stroustrup(更 新到 C++11) C++之父写的经典C++书籍。内容覆盖C++的所有东西，从语言内核到标准 库、编程范式和语言哲学(这使得最新版突破1千页)。2013年5月出版的第四版涵盖了 C++11的内容。 《C++标准程序库》(C++ Standard Library Tutorial and Reference) 作者：Nicolai Josuttis (更新到C++11) 这本书是C++标准库（STL）的引导和手册。 2012年4月发 行的第二版涵盖了C++11。 《The C++ IO Streams and Locales》作者：Angelika Langer and Klaus Kreft 除了这 本书，市面上基本没有讲解streams and locales的书。 C++11 手册 《The C++ Standard (INCITS/ISO/IEC 14882-2011)》作者：C++标准委员会 这当然是 C++ 最权威的标准。要注意的是，C++标准是提供给有足够精力和时间的专家级用户研究 用的。国内估计很少有人看，在国外一般它的第一个发行版也非常贵($300+ US)，国外有 人会买现在价值$30US的电子发行版。 《Overview of the New C++ (C++11/14)》作者：Scott Meyers(更新到 C++11/C++14) 这是 Scott Meyers开设的一个为期3天的C++课程的教材。Scott Meyers 是C++社区最受尊敬的作者之一。虽然内容比较简短，但质量极高。 经典/古老注意: 下列书中的部分内容可能有些过时或者不再认为是最佳实践 《C++的设计与演化》(The Design and Evolution of C++ )作者：Bjarne Stroustrup 如果你想知道为什么C++是今天这个样子，那么这本书将给你答案。本书覆盖C++标准化之 前的一切东西。 《C++沉思录》(Ruminations on C++) 作者：Andrew Koenig and Barbara Moo 本书不是 为了讲解具体的C++技术细节，而是如何通过C++编写出色的OO代码。 《Advanced C++ Programming Styles and Idioms》作者：James Coplien 讲解了一些 C++ 特有的惯用法. 它确实是一本不错的书籍，如果时间闲暇也可一读。不过它确实很老 了，可能有些不符合现代的C++。 《大规模C++程序设计》(Large Scale C++ Software Design) 作者：John Lakos 本书介 绍了如何管理大规模C++软件项目的技术。很值得一读，除了有些过时以外。它是在C++98 以前写的，缺少了好多对大规模项目重要的特性（比如名字空间）。假如你工作在一个大 规模的 C++项目中，你可能想要读它, 不过你需要注意那些不适用甚至错误的技术点。 《深度探索C++对象模型》(Inside the C++ Object Model) 作者：Stanley Lippman 如 果你想知道虚函数是如何实现、多继承时基类是如何在内存中排布的和所有影响性能的东 西，那么这本书会给你答案。不过这本书有好多低级的拼写排版错误，英文原版错误更多 ，侯捷翻译的版本中注明和纠正了很多，但本书绝对值得一读，你将明白编译器如何实现 C++的对象模型。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《程序员修炼之道》]]></title>
    <url>%2F2016%2F01%2F25%2Fthe-pragmatic-programmer-book-note%2F</url>
    <content type="text"><![CDATA[这是第一本我刚看完书评就想写些什么的书，读书在于感悟，而悟道却往往在一瞬之间。以 前看很多书，老觉得作者说的也不过尔尔，现在想来是自己的功力不够，还体会不到作者想 要表达的意思。之前看书过于贪功，喜欢规定自己在一段时间段内一定要看完某一本书，现 在想想觉得可笑，快速读完但是内化不了的书不看也罢。这是一本我看了很久才看完的书， 但是我现在还是不敢说自己读懂了它，这本薄薄的书中内容太过于丰富，我想我的资质还是 差了一些，天外有天，我还有好远的路要走。 悟道参禅老子说：“道法术器”，这是进学的不同阶段，市面上的好书也有分这些不同的层次。个人认 为对于C++学习来说《Vim 实用技巧》属于器这一级别的书，读这样的书有助于“利器”； 《C++ Primer》属于术这一级别的书，可以帮你掌握基本的C++技术；《Effective C++》属 于法这一个级别的书，读这一类的书有助于理解如何优雅的使用C++技术；《程序修炼之道 》这样的书则是属于道这个级别书，它已经完成超脱于语言，指导个人修养的提升。 很多人说这本书的译名非常的烂俗，但我觉得译者深得其中的精髓，正如注重时效的团队一 章所言，这本书大部分是教你如何成为更好的程序员。这是一本需要慢慢感悟的书，悟道参 禅，得道者可以成仙，对于软件工程师来说，得道者能够成神，大家心中的大神。 看不懂的章节这本书我有很多章节都看的不是很明白，比如领域语言，我虽然也接触过Qt中的qrc 资源文件的使用，但是却没有办法真正的说服自己在项目中使用领域语言，毕竟对我来说 开发一种语言还太过于遥远。 又比如估算一节谈如何学会估算从而提高自己对于可行性的一种天然的直觉。作者虽然花 了大量的篇幅在写如何估算，我还是觉得自己没有办法理解其中的奥妙之所在。 再比如黑板这一个章节描述了一种生产和消费者之间一种那个匿名、异步的数据交换方式 。这是我第一次听说过这个概念，没有在其他的书中看过相关的介绍，我很努力的尝试理解 作者想要表达的技术却依然很难掌握这种技术。 书中难以理解的地方还有很多，希望自己日后功力见长之后能够领悟到作者传达的深意。 自我修养这本书的大部分内容都在谈如何成为一个更好的程序员，比如书中的第一条提示和最后一条 提示： Care About Youre Craft —— 关心你的技艺 Sign Your Work —— 在你的作品上签名 首尾呼应语重心长的告诉我们要提高自身的修养，对自己的作品负责，也为自己的作品感到 骄傲。 书中令我感触最深的是两位作者身上浓浓的工匠情怀，他们强调程序员自己的不断学习和修 炼，他们甚至单独写了一章你的知识资产告诫我们要不断的学习。这本书的附录引用和参 考了大量的书籍和网上资源，足以见得两位作者自身的博学。在这一点上作者们和孔子的学而时习之的思想其实是一至的。 进一步学习要学的东西太多，从器的层面上我至少还需要下面这些东西 一门脚本语言（偏向于 Python），无论是在文本处理、代码生成、测试、自动化等方面 它都有很大的用途。 VimL，学会扩充自己的编辑器完成自己想要做的工作。 GDB、DDD 等调试工具，学会有效的调试方式。 Git，我虽然知道基本的使用方式却并不熟悉它的使用，我需要精通这种代码管理器。 doxygen 文档生成器，这是全部是写得以在C++中实践的重点方式。 H5、CSS3，使用 Web 的方式发布文档是最佳的方式，至少它能很好的更行。 Autotool、CMake、cron，这些自动化工具。 学会一个 profiler，可选的工具有gprof，oprofile，zoom，pref，pstack，Valgrind 下面是相关的一些链接： What is a good easy to use profiler for C++ on Linux\ What can I use to profile C++ code in Linux\ Performance profiling on Linux\ Alternatives to gprof\ How to profile multi-threaded C++ application on Linux 路漫漫其修远兮，吾将上下而求索，加油！！！]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《More Effective C++》]]></title>
    <url>%2F2016%2F01%2F25%2Fmore-effective-cpp-note%2F</url>
    <content type="text"><![CDATA[这本书没有《Effective C++》一书重要，但仍然值得一读。这是我看过最多的关于这本书 的评价。这个评价还算中肯，但是这句话面向的是初学者。这本书里面提到的很多技术估计 没有几年的开发经验应该不太可能用到，比如自己处理引用计数，自己设计代理类等等。如 果你是比较高阶（至少你自己是这么认为的）的C++程序员（嗯，或者你可以说自己是工程 师），这本书非常值得一看，因为里面设计的引用技术、字符代理、双分派问题都是近乎神 技，即使用不到这些技术，你依旧可以在这些代码中学到很多设计方面的新的思维。 还有很多人说这本书有点过时，这是实话，作者在书中提到模板、异常可能不受支持的问题 现在看来像是在开玩笑。但是作者写这本书的时候确实有这个问题，而且这些论断并不会影 响文中其他内容的讨论，所以认为这本书太老而不值得一读的人完全可以消除这个顾虑。唯 一的例外是关于异常规格（exception specification）的讨论确实有点过时，因为新的标 准中已经废弃的这一功能，但是阅读相关的内容会让你更容易理解为什么它会遭到废弃。 相关书籍嗯，这是一本有一定难度的书。一般的人可能比较难以轻松的读完它，在阅读这本书之前我 建议大家先看看《设计模式》和《深度探索C++对象模型》两本书，当然你应该不会还没有 看过《Effective C++》就跑来看这本书吧，如果是，放下这本书吧，把《Effective C++》 看完两遍再来看这本也不迟。 这本书两面讨论的很多技术在《设计模式》和《深度探索》两本书中都有提到并且有更详细 和全面的讲解。读完这两本书再读文中的内容会比较轻松一些。当然不同的作者对于同一个 问题可能会有不同的看法，比如对于把析构函数声明成纯虚函数这一点，梅耶（本书作者） 好像比较推荐这么做但是李普曼（《深度探索C++对象模型》一书的作者）好像不太赞成这 么做。此外两书在讨论返回值优化的时候用的术语也不同，本书使用RVO而《深度》一书 使用NRV（深度探索一书中关于NRV和拷贝构造之间的关系不太准确，详见我的另一篇博文 深入探索C++对象模型一书中拷贝构造函数和NRV关系探讨 ）。 这本书里面提到的很多模式和《设计模式》一书中的模式有些出入。比如虚拟构造函数在《 设计模式》一书中指的是“工厂方法”模式，而虚拟拷贝构造函数类似《设计模式》中的原型 模式但是侧重点不同，书中主要侧重拷贝的虚拟化而《设计模式》一书中侧重的则是通过拷 贝来创建对象。又比如设计模式中的代理和被代理者有相同的接口，强调两者无缝的替换性 而本书中的代理则更加的宽泛，并不要求接口一致，它更多的是强调使用代理封装原本功能 之外的一些功能，从这一点上看它更像是装饰者模式。 了解《设计模式》和《深度探索C++对象模型》两本书的内容会让此书的阅读更加的轻松， 同时也有更多的参考可供触类旁通。 总结这本书本身就是作者经验的总结，所以这本书没有太多可以总结的东西。从书本身的角度来 看，难点主要在于效率和技术两章，读者可以慢慢的品味这两章的内容，必然受益无穷。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细数《深度探索C++对象模型》一书中的20个翻译错误]]></title>
    <url>%2F2016%2F01%2F18%2Ficom-translation-error%2F</url>
    <content type="text"><![CDATA[《深度探索C++对象模型》一书由侯捷先生翻译，侯先生是非常有名的C++专著译/作者，这 本书可以看得出来他也花了不少心思翻译。但是我在阅读的过程中还是发现了一些翻译上的 不足。我在下笔写这篇文章的时候纠结到底是用瑕疵一词还是错误一词呢？我最终还是选择 了错误一词，因为有些地方确实有误导之嫌疑，我对照英文原文和中文译本，把我认为可能 是翻译错误的地方整理在此文中。这些地方有可能是我误解了作者的意思而侯捷理解正确了 ，也有可能是我本身误解了侯捷的翻译，我把原文和译文一并贴出，读者可以自行对照判断 。 此文中的页码和行号都是简体译本中的页码和行号，行号中的 - 表示倒数，行号不包括 代码内容，行号前面的码表示是代码的错误 P46，L-4译文如下： 原先cfront的做法是靠“在derived class object 的每一个virtual base classes 中都安插一个指针”完成。 原文如下： In the original cfront implementation, for example, this is accomplished by inserting a pointer to each of the virtual base classes within the derived class object. 这一个错误非常明显，原文中说 “inserting a pointer … within the derived class object.“ 意思是说在子类中安插指向每一个虚拟基类的指针，而不是在虚拟基类中安插指 针。 这段文字后面的代码可以证明： 1void foo(const A* pa) &#123; pa-&gt;__vbcX-&gt;i = 1024; &#125; pa 的类型是 A，它是虚拟基类 X 的子类，指针安插在它的对象上面而不是安插在虚拟基类 X 的对象上。此外指针的名字 __vbcX 表示指向虚拟基类 X 的指针再一次证明这一点。 P78，L3译文如下： 我建议你总是把一个member的初始化操作和另一个放在一起（如果你真的觉得有必要的话 ），放在constructor之内，像下面这样： 原文如下： I recommend always placing the initialization of one member with another (if you really feel it is necessary) within the body of the constructor, as follows: 这句的主干是”placing the initialization of … with in the body of constructor“ 。也就是说”把…的初始化放在构造函数体内“，这一点侯捷的译文没有错，但是”the initialization of one member with another“的意思应该理解成”使用一个成员来初始化 另一个成员的操作“，而不是把两个成员初始化放在一起。 之所以这么说原因很简单，下面给出的例子代码明显只是把其中一个放入构造函数体内。而 且这样理解明显更加合理，因为这种方式在效率性和正确性上都有比较号的权衡。把独立的 成员变量初始化放在成员变量初始化列表可以提高效率，而把相关的成员编码放入到构造函 数中可以保证正确性。 P80,L2上面的那个翻译错误，直接导致了这个翻译错误：译文如下： 是因为我要给你一个忠告：请使用”存在于constructor体内的一个member“，而不要使用” 存在于member initilazation list 中的member“来为另一个member设置初值。 原文如下： I reiterate my advice to initialize one member with another inside the constructor body, not in the member initialization list. 译文不但读起来很别扭，而且意思也改变了。原文中使用了 reiterate 一词表示重申， 他要表达的应该是前面说的把使用一个成员来初始化另一个成员这样的操作放在构造函数体 内。前面说的成员变量而这里说的是成员方法，其实本质上都是一样，因为 xfoo() 可能会 访问到某些没有初始化的成员。 P90，L5译文如下： 其效果是，如果一个inline函数在class声明之后立刻被定义的话，那么就还是对其评估 求值。 原文如下： the effect is still to evaluate the body of an inline member function as if it had been defined immediately following the class declaration. 这句话错的更加离谱了，按照字面来理解也应该是说，”效果是依然像内联成员函数被立即 定义在类声明之后一样评估求值它“。最明显的证据就是原文中的still其实作者想表达的 是效果和P89页上的第2点措施是一样的。 P106，码L1-L2译本代码如下： 1234Concrete2*pc2;Concrete1*pc1_1, *pc1_2;pc1_1 = pc2; // 译注：令pc1_1 指向 Concrete2 对象*pc1_2 = *pc1_1; 原文代码如下（原文的代码和译文代码命名不一致，为了方便，我统一改成了译文中的 pc1_2）： 1234Concrete2 *pc2;Concrete1 *pc1_1, *pc1_2;pc1_1 = pc2;*pc1_1 = *pc1_2; 也就是说代码的最后一句的赋值是反的。作者的注释和译注的注释都解释了赋值的错误，子 类的子对象备覆盖了，现在 bit2 member 有一个非预期的数值。 那么问题是有子对象的应该是子类，也就是 pc2 所指的对象才对，现在 pc1_1 指向 pc2， 所以被覆盖的应该是 pc1_1 而不是 pc1_2。所以原文中的代码是没有错误的，但是译 文中的代码有误。可以把译文中的pc1_1 = pc2改成pc1_2 = pc2以得到正确的结果。 P149，L1译文如下： 我想你很少看到下面这种怪异的写法： 原文如下： it was not uncommon to see the following admittedly bizarre idiom in the code of advanced users: 除去后面那些什么高阶用户不说，原文使用了 not uncommon 是双重否定应该是表示经常 看到这种代码才对而不是很少，所以此处应该是误译。 P207，L6译文如下： 如果 class object 是最底层的 class，其 constructors 可能被调用；某些用以支持这 一行为的机制必须被放进来。 原文如下： These constructors, however, may be invoked if, and only if, the class object represents the “most-derived class.” Some mechanism supporting this must be put into place. 原文中的能且仅能没有翻译，然而所有最大的错误还是在于 These 的翻译，它指的不是最 底层的 class 的构造函数而是基类的构造函数，因为最底层的类必须负责虚拟基类的构造 ，而这种构造需要额外的机制支持。 P219，L2译文如下： 何时需要供应参数给一个 base class constructor？这种情况下在“class 的 constructor 的 member initialization list 中”调用该class的虚拟函数，仍然安全吗 ？ 原文如下： What about when providing an argument for a base class constructor? Is it still physically safe to invoke a virtual function of the class within its constructor’s member initialization list? 这里的的错误非常明显，作者想要表达的意思其实是： 123456789class Base &#123;public: void Base(int arg) &#123; &#125;&#125;;class Drived : public Base &#123;public: void Drived() : Base(get_argument_by_virtual_function()) &#123; &#125;&#125;; 作者在前文中说过，在 member initialization list 中调用该类的虚函数初始化成员变量 是安全，所以这里反问“如果在 member initialization list 中给基类构造函数提供参数 时调用该类的虚拟函数是否安全，答案是否定的，原文中的翻译相差太远了。 P220，L-2译文如下： C++ Standard 上说 copy assignment operators 并不表示 bitwise copy semantics 是 nontrivial 原文如下： The Standard speaks of copy assignment operators’ not exhibiting bitwise copy semantics as nontrivial 这一句的翻译就更不靠谱了，完全变味了。按原文的理解，这句话应该译文：标准规定不具 备bitwise copy semantics的copy assignment operators是nontrivial。 P223，L-9译文如下： 然而我们无法支持它，我们仍需要根据其独特的继承体系，安插任何可能个数的参数给 copy assignment operator 原文如下： We can’t reasonably support this, however, and still insert an arbitrary number of arguments to the copy assignment operator based on the peculiar characteristics of its inheritance hierarchy. 很明显，这里作者想要表示的是无法在支持上面的操作的同时给根据其独特的继承体系安插 任何可能个数的参数给 copy assignment operator。所谓安插参数就是像在涉及到虚拟基 类的构造函数一样，通过添加 __most_drived 这样的参数来控制那些地方应该调用虚拟 基类的 copy assignment operator。 原文之所以说无法在支持上面的操作（也就是通过指针调用函数）的同时支持安插参数的原 因书中没有说，我也不太理解。但是作者想要表达的应该就是这个问题，文中提到的 6.2 节也讨论过这个问题，因为构造函数是通过指针传递的，所以没有办法设置默认参数。 个人的理解是指针的间接引用是一个运行期的求值问题，安插参数却需要在编译时完成。我 们总不至于得让用户提供我们额外安插的参数。 P234，L1译文如下： 如果 object 内含一个 vptr，那么首先重设相关的 virtual table。 原文如下： If the object contains a vptr, it is reset to the virtual table associated with the class. 原文意思是把 vptr 重置以便指向相关的类虚表，而不是重设虚表。 P235，L1译文如下： 译注：上页的destrucotr扩展形式似乎应为2,3,1,4,5，才符合constructor的相反顺序。 这段译注有误导的嫌疑，个人认为作者的顺序是没有错的，比如给点下面的继承体系： A ^ | B ^ | C 并有如下代码： 12A* pa = new C;delete pa; 因为析构的顺序和构造是相反的，所以先调用C的析构，此时vptr指向的是C的虚表，所以不 需要重置，调用完C的析构的时候调用B的析构，因为C已经析构完成，相当于目前是一个完 整的B类型了。B的析构函数本体执行之前当然应该首先重置vptr让它指向B的虚表，否则在 析构中调用的函数不就会调用到C的实体中去了吗，所以第一步是（1）不是（2）是合理的 。译者可能是受到和constructor相反的顺序这句话的影响给出的译注。 P252，L6此处不能说是译者的误译，因为译者说没有充分的理解这句话的意思，所以给出了原文如下 ： This has always resulted in less than first class handling of the initialization of an array of class objects. 我找到的原文如下： This has always resulted in less that first-class handling of the initialization of an array of class objects. 我得到的原本和译本有一个细微的差别就是 less that 而不是 less then。这句话的 意思个人理解是，因为构造函数是通过指针调用的，所以没有办法给出非常优雅的方式处理 类对象数组的初始化。关于指针调用函数是无法设置参数的问题在copy assignment operators 的讨论中也有提到过。 其实作者想要表达的意思应该是没有很合理的方式解决初始化问题，比如后文中给出两种方 式：第一，不允许；第二产生内部的违背语言规则的stub constructor，都不是优雅的解 决方式。 P258，L-7译文如下： 还记得吗？在个别数组元素构造过程中，如果发生 exception，destructor 就会被传递 给 vec_new() 原文如下： Recall that the destructor is passed to vec_new() in case an exception is thrown during construction of the individual array elements. 原文的意思应该是：还记得吗？为了防止在个别数组元素构造过程中发生 exception， destructor 被传递给了 vec_new()。 P263，码L2译文代码如下： 1Point3d *p = &amp;((Point3d*)ptr)[ ix ] // 译注：原书为 Point *p = ... 恐为笔误 原文代码如下： 1Point *p = &amp;((Point3d*)ptr)[ ix ]; 其实原文的代码没有错误，因为通过多态的调用，可以正常的析构掉数组元素。否则在后面 的解释中作者不会强调这个调用是虚拟的。 后面的地方之所以要在取下边之前转换成 Point3d* 是为了一次能够偏移 sizeof(Point3d) 的大小而不是 sizeof(Point) 的大小。 P268，码L-5,L-3译文代码如下： 12T temp;temp.operator+(a, b); //（1） 译注：原书是 a.operator+(temp,b); 误 标示为（-1）的那一行，未构造的临时对象被赋值给operator+()。 原文如下： 12T temp;a.operator+(temp, b); // 1 In the line marked //1, the unconstructed temporary is passed to operator+(). 其实后文中作者说的很明显，temp没有构造就直接传递给了operators，然后通过拷贝构造 或者NRV的constructor进行构造。所以这个地方其实是把 temp 当成是一个优化返回值的对 象。译者把它理解成结构的返回值，是对于作者的原本意思的误解。 P269，L8译文如下： 因此以一连串的 destruction 和 copy construction 来取代 assignment 一般而言是不 安全，而且会产生临时对象。 原文如下： Therefore the replacement of assignment with a sequence of destruction and copy construction is generally unsafe and the temporary is generated. 作者在P268中给出的代码中会产生temp变量，P269中的代码用析构和拷贝构造替换之后不会 产生临时变量。 1234567891011// ********* 有临时变量*************T temp;a.operator+( temp, b ); // 1// c = tempc.operator =( temp ); // 2temp.T::~T();// ********* 无临时变量*************c.T::~T();c.T::T( a + b ); 但是这种转换不一定是安全的，因为赋值和先析构再拷贝并不一定就是同样效果，如果效果 不一样，那么就只能通过产生临时变量的方式解决上述问题。译文中的而且会产生临时对象 有误导之嫌。 P300，L1译文如下： 把两块区域以个别的”备摧毁之local object“链表（已在编译时期设妥）联合起来 原文如下： associate the two regions with separate lists of local objects to be destroyed 原文的意思是给两块区域分别于不同的链表关联起来。 P305，L7，L10译文如下： 相同形式的 exception 数据栈中。 原文如下： some form of exception data stack。 译者把 some 看成了 same，应该翻译成：某种形式的 exception 数据栈中。 同一段的最后一句也有错误，译文如下： 以及可能会有的 exception object 描述器（如果有人定义它的话）。 原文如下： and possibly the address of the destructor for the exception object, if one if defined. 译者把 destructor 看成了 descriptor，应该翻译成：以及可能会有的析构函数地址。 P306，L1，L8，L-4这三个地方都用了”繁殖“一词，但是原文是”propagated“一词，翻译成传播或者传递会比翻 译成繁殖更准确一些。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中构造函数和虚拟函数的微妙关系]]></title>
    <url>%2F2016%2F01%2F18%2Fconstructor-virtual%2F</url>
    <content type="text"><![CDATA[构造函数和虚拟函数之间存在许多比较微妙的关系，比如构造函数不能是虚拟函数，构造函 数不能正常调用虚拟函数等等，本文将会讨论产生这些问题的原因。 构造函数为什么不能是虚拟函数构造函数和析构函数在设计之初就是成对出现的，他们是一种对称关系：构造分配资源，析 构释放资源；构造用来初始化，析构用来清理。但是现在有一个点他们极不对称： 析构通常是虚函数 构造不能是虚函数 构造和析构的另一个不对称的地方是异常处理，构造函数中出错只能抛出异常，但是析 构函数中不允许抛出异常 通常声明成虚函数的析构函数关于析构通常是虚函数的问题，在 《Effective C++》一书中有讨论，原因很简单： 12class Base &#123; // 基类公共资源 &#125;;class Sub : public Base &#123; // 子类自己的资源 &#125;; 为了能够进行多态的处理程序，我们需要通过基类指针指向子类的对象： 1Base* base = new Sub; 那么问题来了，当我们调用 1delete base; 的时候，假如 Base 没有把析构函数声明成虚函数，那么它会直接调用 Base 的析构函数（ 这一点在编译的时候就已经确定了），那么 Sub 中分配的子类资源得不到释放这就造成了 资源泄露。如果 Base 的析构函数是虚函数，那么它实际上会调用到子类的析构函数，而子 类的析构函数会自动调用基类的析构函数，最终使得基类和子类的资源都会得到释放。 123Sub::~Sub() &#123; this-&gt;Base::~Base(); // 编译器安插代码。&#125; 不能声明成虚函数的构造函数构造函数不能是虚函数的原因很简单，这是一个鸡生蛋，蛋生鸡的问题。要让虚函数正常的 工作，关键在于每个对象中都存在的 vptr 指向正确的虚表。但是这个 vptr 不会凭空出现 并已经设置好了的，它总得在某个地方设置好，而这个设置点最合理的位置就是构造函数。 如果把构造函数声明成虚函数，那么谁来正确的处理vptr呢？所以我们不能把构造函数声明 成析构函数。 构造函数中无法正常的调用虚函数给出下面的代码： 1234567891011121314151617181920212223class Base &#123;public: Base() &#123; name(); // ***1*** &#125; void name() &#123; vname(); &#125; virtual char* vname() &#123; return "Base"; &#125;&#125;;class Drived : public Base &#123;public: virtual char* vname() &#123; return "Drived"; &#125;&#125;;Base* base = new Drived; 上面程序中调用的 vname() 是 Base 中的 vname 实体而不是 Drived 中的 vname() 实体 ，因为实际上编译器处理过的构造函数的伪代码如下： 1234567891011Base::Base() &#123; __vptr = __base_vtbl; // 编译器安插的代码 name();&#125;Drived::Drived() &#123; // 编译器合成并安插的代码 Base::Base(); __vptr = __drived_vtbl;&#125; 也就是说设置合适的 vptr 是在调用基类的构造函数之后，基类的构造函数中调用的虚函数 即使是转换成了虚表中的函数调用，也不可能调用到子类的中函数实现，因为那时候 vtpr 还没有指向子类的虚表。关于代码的安插顺序可以参考《深度探索C++对象模型》一书。 如何实现虚构造函数嗯，这个问题有点白痴。最直接的答案是：不可能，不那么直接的答案是：工厂方法。工厂 方法模式的别名就是虚构造函数，因为我们没有办法把构造函数声明成虚拟函数，所以我们 只有通过曲线救国的方式：通过工厂方法来返回可由子类重新定义类型的实例。 123456789101112131415161718192021222324class Widget &#123; &#125;;class Button : public Widget &#123; &#125;;class Checkbox : public Widget &#123; &#125;;class WidgetCreator &#123;public: virtual Widget* CreateWidget() &#123; return new Widget; &#125;&#125;;class CheckboxCreator &#123;public: virtual Widget* CreateWidget() &#123; return new Checkbox; &#125;&#125;;class ButtonCreator : public WidgetCreator &#123;public: virtual Widget* CreateWidget() &#123; return new Button; &#125;&#125;; 用户不再直接通过调用 Widget 来获得 Widget 或者它子类的实例，而是通过上面这样的工 厂方法CreateWidget 获得。 12345WidgetCreator* creator = CheckboxCreator::Instance();Widget* widget = creator.CreateWidget(); // 返回 Checkboxcreator = ButtonCreator::Instance();Widget* button = creator.CreateWidget(); // 返回 Button 因为这个方法可以重载同时又提供构造函数的功能，所以它也被成为虚拟构造函数。关于工 厂方法的详细信息可以查看《设计模式》一书。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《深度探索 C++ 对象模型》]]></title>
    <url>%2F2016%2F01%2F18%2Finside-cpp-object-model%2F</url>
    <content type="text"><![CDATA[这本书应该有一个副标题——隐藏在编译器背后的故事。这是一本非常有深度的书，它告诉我 们编译器在实现C++的那些特性（封装，单继承，多继承，虚拟继承、虚函数，构造，拷贝 ，析构，模板，内联，异常，RTTI等等）时帮我们做了什么。 译者侯捷在译序中说的本立道生可谓是一语中的。不了解这些东西你可以写出正确的C++程 序，因为你知道C++语法。但是如果你知道C++中的特性是如何实现的，它们的开销是什么， 你就可以在单继承、多继承、虚拟继承之间；抽象类、实体类之间；继承和组合之间做出最 合适你自己的选择。同时了解这些知识会让你对于自己写的程序理解的非常透侧，一个优秀 的程序员要对自己写下的代码了如指掌。 关于书中的错误这本书原版就有很多瑕疵，书中有很多编辑上的错误，译者侯捷先生在翻译的时候对大部分 的错误进行了更正，所以中文译本在编辑上的错误比较少，这一点非常感谢译者。 不过这本书的翻译比较诡异，大多数地方都是中英文混合，侯捷先生说是为了让大家熟悉英 文的专业术语。总体来说，这种翻译风格并不会给阅读带来太大的影响，毕竟长期阅读计算 机专著的人对于这些术语也不是很陌生。 不过本书有一定的难度，翻译起来比较困难，侯老爷子虽然功力非常的深厚，但是翻译也难 免会出现错误。我在阅读的过程中凡是遇到不通顺或者难以理解的地方基本上都会参考英文 的原文辅助理解。这个过程中我发现其实本书还是有很多地方的翻译是有待商榷的，我把我 找到的这些地方整理成了另一篇博文——细数《深度探索C++对象模型》一书中的20个翻译错 误。当然这些都是个人对于原文的理解，有可能是我理解错误 ，大家可以看一看自行判断。 知识点小结书中对于各种特性的讲解的非常的仔细，此处对书中的一些信息按照特性分类总结。 封装所谓封装就是把数据和处理数据的方法当入到同一个结构中，书中使用 ADT（抽象数据类型 ） 一词来表示纯粹的封装。 123456class ADT &#123;public: void fun(int arg);private: int data;&#125;; C++把函数放到对象之外，类的内部只是存放非静态的数据。所以上面的封装最终会转换成 类似下面的C代码。 12345struct ADT &#123; int data;&#125;;void ADT_fun(ADT* this, int arg); 如果你要使用C语言来模拟封装，完全可以用上面这种方式模拟。 单继承单纯的单继承不会带来任何的开销，因为下面的继承： 12class Base &#123; public: int foo; &#125;;class Sub : public Base &#123; public: int bar; &#125;; 和下面的结构体： 1234struct Sub &#123; int foo; int bar;&#125;; 得到的内存布局是一样的。其实你甚至可以自己用C语言模拟这种继承： 123456789struct Base &#123; int foo;&#125;;struct Sub &#123; struct Base base;#define foo base.foo int bar;&#125;; 在Linux内核的网络协议栈中有大量的这种写法。 多继承多继承的主要问题在于处理第二个和之后的基类时，需要调整偏移量，以便能找到正确的地 址，比如有如下继承体系的情况下。 12class Sub : public FirstBase, public SecondBase &#123; ... &#125;;Sub* sub = new Sub; 那么 Sub 和 FirstBase 直接可以直接转换，编译器不需要额外的处理。 1FirstBase* fb = sub; 但是 Sub 和 SecondBase 之间的转换需要编译器调整偏移量，给定下面的代码：。 1SecondBase* sb = sub 编译器如果要保证正确性需要把它转换成： 1SecondBase* sb = (SecondBase*) ((char*) sub + sizeof(FirstBase)); 这主要是因为在一个完整的子类对象中，以此存放了各个基类的子对象（P112）。 虚拟继承虚拟继承是最蛋疼的问题，因为它意味着共享，给定下面的继承体系。 1234class VBase &#123; public: int a; &#125;;class RBase1 : public VBase &#123; &#125;;class RBase2 : public VBase &#123; &#125;;class Sub : public RBase1, public RBase2 &#123; &#125; 下面的代码中，编译器无法之道 a 到底是通过 RBase1 继承而来的还是通过 RBase2 继承 而来的，所以这段代码无法通过编译。 12Sub sub;sub.a = 10; 解决上面这种菱形继承的最好的方式就是使用虚拟继承， 12class RBase1 : public virtual VBase &#123; &#125;;class RBase2 : public virtual VBase &#123; &#125;; 这样一来体系中就会共享同一个 VBase 的子对象。但是代价是非常高的，因为整个对象的 内存模型都会编码，VBase 不再作为 RBase1 子对象。所以原本适用于这个模型的所有东西 基本上都不再使用。访问 VBase 子对象现在需要通过一个额外的变量（可以是指针，也可 以是偏移量）访问，效率上要比普通的继承低。 此外为了实现共享，虚拟基类由继承体系中最底端的类负责构造而不是直接子类负责构造， 比如： 1Sub sub; sub 对象的构造过程中，它需要负责调用 RBase1，RBase2（实体基类）和 VBase（虚拟 基类）的构造函数，但是 RBase1，RBase2 的构造函数不能调用 VBase 构造函数。这种机 制非常的复杂，需要通过给构造函数添加额外的参数来完成 1234567891011121314151617181920212223Sub::Sub(Sub* this, bool __most_drived) &#123; if (__most_drived) &#123; this-&gt;VBase::VBase(); &#125; this-&gt;RBase1::RBase1(false); this-&gt;RBase2::RBase2(false); ...&#125;RBase1::RBase1(RBase1* this, bool __most_drived) &#123; if (__most_drived) &#123; this-&gt;VBase::VBase(); &#125; ...&#125;RBase1::RBase1(RBase1* this, bool __most_drived) &#123; if (__most_drived) &#123; this-&gt;VBase::VBase(); &#125; ...&#125; 编译器在对象创建的时候传递合适的 __most_drived。 12// Sub sub;Sub::Sub(&amp;sub, true); 当涉及到虚拟继承的时候，几乎所有的机制都会变得非常的复杂，所以不用为好。 虚函数单继承下虚函数的引入使得每一个函数虚函数的类都必须包含对于的虚表（vtbl——里面存放实际调用 的函数的地址），而每一个对象都有虚指针（vptr）指向正确的虚表。给定下面的继承体系 。 12345678910111213class Base &#123;public: virtual char* foo() &#123; return "foo"; &#125;&#125;;class Sub &#123;public: virtual char* foo() &#123; return "foobar"; &#125;&#125;; 相应的客户端代码如下： 12Base* pbase = new Sub;cout &lt;&lt; pbase-&gt;foo() &lt;&lt; endl; // "foobar" 上面的代码之所以能够正常的工作的原因是，编译器把 pbase-&gt;foo() 的调用改成了对于 虚表中的函数的调用： 1(*pbase-&gt;__vptr[1])(pbase); // p147 多继承下多继承下如果涉及到第二个基类，那么需要编译器调整 this 指针的位置，给出如下的继承 体系： 12345678910111213141516171819class FirstBase &#123; &#125;;class SecondBase &#123;public: virtual char* foo() &#123; return "foo"; &#125;&#125;;class Sub : public FirstBase, public SecondBase &#123;public: virtual char* foo() &#123; return "foobar"; &#125;&#125;;```cpp如果要下面的代码能够得到正确的处理，编译器需要做特殊的处理。```cppSecondBase* sb = new Sub;sb-&gt;foo(); // "foobar" 如前面继承所以，子类和第二个基类之间的转换成需要加上偏移量，以得到争取的基类地址 。此时因为多台 sb 所指向的子对象对应的 vtbl 中存放的方法是 Sub 中的成员方法，直 接进行前面提到的转换： 1(*sb-&gt;__vptr[1])(sb); 并不能得到正确的结果，因为 Sub 的 foo 成员函数经过编译器的处理会变成这样： 1char* foo(Sub* this); // 为了清晰性，没有加入 name mangling 但是此时 sb 指向的却是一个 SecondBase 子对象，所以为了能够得到正确的函数调用 ，必须对sb进行修正加上合适的偏移量使它指向 Sub 对象的地址。这个修正同样比较 复杂，书中提到的做法是通过thunk，或者改变vtabl中实体的类型，让他不再只是存储函数 的地址，同时也存储this的偏移量。（后面这种做法对于那些不需要调整this指针的函数来 说效率太低）thunk是包含了偏移量设置和实际函数调用的代码块，它的作用有点类似于设 计模式中的装饰者模式，通常thunk看上去像下面这个样子。 123sb_foo_thunk: this += sizeof(FirstBase); Sub::foo(this); 构造构造函数的主要问题是在需要的时候它必须合成，或者在已有的函数上安插代码，下面是常 见的几种情况。 组合12345class Widget &#123;private: String str; int val;&#125;; 对于类编译器需要合成一个构造函数用来安插 str 成员变量的构造。 123Widget::Widget() &#123; // 合成的构造函数 str.String::String();&#125; 继承可能大部分人认为只要有继承就一定会合成默认构造函数以调用基类的构造函数，但是这种 观点是错误的，编译器只会在必要的时候这么做。 12class Base &#123; public: int i; &#125;class Sub : public Base &#123; public: int i; &#125; 对于上面的继承，编译器不会合成默认构造函数，因为构造函数被判定为 trivial（不重要 ）。但是像下面这种代码则会合成构造函数： 12class Base &#123; public: String str; &#125;class Sub : public Base &#123; public: int i; &#125; 虚函数如果要处理虚函数就必须要设置好 vptr 指向正确的 vtbl，所以只要有有虚拟函数的定义 就一定会有代码的安插，无论是在合成的构造函数中还是已有的构造函数中。比如下面的类 定义。 1234class Widget &#123;public: virtual char* foo();&#125;; 其他书中还是非常多其他的内容，包括内联、异常、RTTI、模板等等。此处不再总结，这本书非 常值得一读，推荐所有有一定基础的C++程序员阅读这本书。]]></content>
      <tags>
        <tag>C/CPP</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入探索C++对象模型一书中拷贝构造函数和NRV关系探讨]]></title>
    <url>%2F2016%2F01%2F11%2Fcpp-copy-constructor-nrv%2F</url>
    <content type="text"><![CDATA[最近深入探索C++对象模型一书，对于P67中最后一段话的第一句非常不解 这个程序的第一个版本不能实施 NRV 优化，因为 test class 缺少一个 copy constructor 从这段文字来看如果没有拷贝构造函数就不会有 NRV 优化，这一点让人颇为不解，因为从 P66 页中给出的例子来看，NRV 通过额外的引用型参数优化掉了参数的返回，根本没有拷贝 构造函数的调用，这个代码和作者自己的论述看上去是自相矛盾的。 对于这个问题，我在三更_雨的博文第二章构造函数语义学–关于NRV优化和copy constructor，找到一些相关的答案，调整了文章行文顺序，放在此处做一个记录。 作者的观点这个解释来自作者李普曼: 早期的cfront需要一个开关来决定是否应该对代码实行NRV优化，这就是是否有客户（程 序员）显式提供的拷贝构造函数：如果客户没有显示提供拷贝构造函数，那么cfront认为 客户对默认的逐位拷贝语义很满意，由于逐位拷贝本身就是很高效的，没必要再对其实施 NRV优化；但如果客户显式提供了拷贝构造函数，这说明客户由于某些原因(例如需要深拷 贝等)摆脱了高效的逐位拷贝语义，其拷贝动作开销将增大，所以将应对其实施NRV 优化 ，其结果就是去掉并不必要的拷贝函数调用。 这说明其实作者之所以这么说是因为cfront编译器的缘故，不过目前这种编译器并不多见 ，所以这个论述本身也就不成立了，读者可以直接忽略这个观点。 译者的观点作者既然给出了解释，其他的解释原本没有太大的必要，但是这些观点对于书的理解有一定 的帮助，所以也纪录在此。 这本书的译者侯捷先生在他的 FAQ 中对于这个问题有和读者之间的讨论。过程如下： leetron给侯捷写信说道： 问题： 在67页，最下面两行：这个程式的第一个版本不能实施NRV最佳化，因为test class 缺少 一个copy constructor。但是在66页「在编译器层面做最佳化」那一段中所列的码显示， 当编译器把xx以__result取代，变成__result.X::X(); 即default constructor被唤起 。唤起default constructor 是可以理解的，可是编译器转换后的码并没有使用到 copy constructor呀，为什麽67页最后两行却说缺少一个 copy constructor，就不能实施这个 最佳化了呢？ 我对上面这个问题做了些解释，但不知我的猜想是否正确。 我的解释是：如同63页与64页「回返值的初始化」这一段，编译器可能将 63页下面的 X bar()函式定义转换成64页的虚拟码，其中有一行__result.X::X(xx); 这会使用到copy constructor。 转换成64页的码后，65页与66页分述了两种后续可能出现的最佳化动作，其中一种即是66 页的编译器层面做最佳化。如此，虽然66页最佳化后的码看起来并不使用到copy constructor，但是这些码是根据像64页那种样子的码(注一)最佳化而来的，而若没有 copy constructor，根本无法转换成64页那种虚拟码，因为其中有一个呼叫copy constructor的动作。所以，虽然 66页经过编译器最佳化的结果省去了 __result.X::X(xx); 这个copy constructor的呼唤动作（因为根本没有xx了），但若没 有明白提供一个copy constructor，却无法让编译器进行这样的最佳化。 另一方面，我叁考第5章，205页最下面一段话：「一般而言如果你的设计之中，有许多函 式都需要以传值(by value) 传回一个local class object….那麽提供一个copy constructor 就比较合理–甚至即使default memberwise语意已经足够。它的出现会触发 NRV最佳化。然而，就像我在前一个例子中所展现的那样，NRV最佳化后将不再需要唤起 copy constructor，因为运算结果已经被直接计算於「将被传回的object」体内了。」所 以，我提出如上所述那个解释，但不确定是否正确，所以e-mail给您以确认一下。 注一：当然，编译器到底怎麽实作这些转换动作，理论上我们是未知的，不能一概而论。 所以我写「像64页那种样子的码」。 侯捷给出的答复是： 首先，我要说 leetron 把他的意思描述得非常清楚。在我收到的读者来函中，算是上品 — 尤其是描述这麽复杂的思路。 其次，我同意 leetron 说： 转换成64页的码后，65页与66页分述了两种后续可能出现的最佳化动作，其中一种即是 66页的编译器层面做最佳化。 但是我不同意 leetron 这样的看法： 如此，虽然66页最佳化后的码看起来并不使用到copy constructor，但是这些码是根据 像64页那种样子的码(注一)最佳化而来的， 我认为，NRV 最佳化并非是由 p63 的原始码而至 p64 的虚拟码，再至 p66 的最佳化。 我认为是从 p63 的原始码直接至 p66 的最佳化。所以，似乎可以不需要 copy ctor。 但这麽一来我也无法解释为什麽 lippman 在 p67 最下强调「必须要有 copy ctor 才能 实施 NRV 最佳化」。 最后侯捷引用了另外一个读者的论述 黄俊达先生认为：Lippman 在 p67 最后一行所言『这个程式的第一个版本不能实施 NRV 最佳化，因为 test class 缺少一个 copy constructor』，此语错误。黄先生认为如 果程式没有 explicit copy constructor，编译器会自动为我们做出来（如为 trivial，则 直接 bitwise copy；如为 nontrivial，则由编译器为我们合成出一个 copy constructor ）。因此，有没有 explicit copy constructor 并不影响 NRV 最佳化的实施。他认为 NRV 最佳化主要是由编译器 option 来决定要不要实施。他并且做了一些实验，判断 VC 和 gcc 都没有做到 NRV 最佳化，而其不做的理由不是因为技术上的困难，是为了避免造成「user defined copy constructor 之副作用失效」– 所谓副作用是指，例如「在 user defined copy constructor 中做一个 cout 输出」之类这种「与 memberwise copy 无关」的动作。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《UML 精粹》]]></title>
    <url>%2F2016%2F01%2F09%2Fuml-distilled-note%2F</url>
    <content type="text"><![CDATA[读这本书主要有两个原因，第一是前阵子看《设计模式》一书的时候对于它的OMT表示方 法比较感兴趣；第二则是论文需要画一些图，想要画的规范一些。对于《UML 精粹》这本书 早有耳闻，因为这本书不是号称权威的“三剑客”写的书，但是销量比他们的书都要好，而且 这本书非常的薄，比较适合阅读。 两个中文译本在中国《UML 精粹》一度遭人唾弃，因为它有一个徐家福先生的译本招人唾弃，认为他糟蹋 了一本好书，我在大学的时候就尝试过读这个译本，最后放弃了这本书，因为实在读不懂说 的是什么（UML 相关的几本“三剑客”写的书好像也有翻译太差这个问题）。 这本书在国内还有另外一个译本，译者是UMLChina（本名好像是潘加宇），我读的译本就 是这个，感觉上还是不错的。不过这个译本目前已经绝版，市面上买不到，我千辛万苦在淘 宝上找到一本二手书，如获珍宝。 在网络上还可以找到这本书的英文原版 PDF，虽然不是很清晰，但是阅读还是没有问题的。 如果找不到合适的译本，可以考虑看那份原版的电子档，反正书也不是太厚，自己没有读懂 好过别人没有读懂把你带沟里去了。 二八原则这本书没有详细的介绍 UML 的方方面面，也算是对得起“精粹”二字。本书最大的亮点在于 把二八原则贯彻的淋漓尽致，他用大量篇幅写了最核心的东西（类图，序列图），剩下的那 些不太重要的东西一笔带过。这是一种技巧，也是一种态度，我认为做任何的事情都应该向 它学习，理解到精髓方能举重若轻。 不要在意细节UML 是图形建模语言，大家用的最多的是它的图，而图是画给人看的。这和编程语言最大的 区别在于语法的严谨程度不同，C 语言是写给机器看的，所以你把printf写成了pf编译 会报错，但是你在图上多画或者少画一个箭头，人还是能够理解。 俗话说一图胜千言，图像最大的优势在于它的表现力比文字强，非常的直观。所以画图的 大忌是什么都堆砌在图上，力求图片信息的准确和丰富。一种密密麻麻的图片和一段密密麻 麻的文字一样让人没有任何想要看下去的欲望。图片的重点是传达出你想要表达的那部分信 息展示出来，把不需要的东西全部忽略掉，这一点对于任何的图都是一样的。 选择合适的图UML 中的图非常的多，每种图都有自己独特的表现力，比如序列图适合表现交互关系，活动 图适合表现处理流程，组件图适合表现模块化信息等等。我认为只因为自己的个人偏好问题 强制使用一种图是不合适，比如因为偏好序列图就不分场合的使用这种图的做法个人认为是 不可取的。 书中书本书的许多章节都有推荐阅读部分，这一部分对于我来说是很有价值的，这本书的作者 Martin Flower 自身就是一个享誉全球的大牛。他的另外几本书也很有阅读的必要，比如 《重构》、《分析模式》等等。他在推荐阅读部分给出的书我相信都是一些好书，特别是其 中“鲍勃大叔”的《敏捷软件开发 原则 模式 实践》，这本书在网上的口碑非常不错，值得 一读。]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书札记之 —— 《设计模式》]]></title>
    <url>%2F2016%2F01%2F03%2Fdesign-patterns-note%2F</url>
    <content type="text"><![CDATA[刚开始接触面向对象编程的时候觉得封装是它最大的优点，毕竟相对于面向过程编程来 说，数据和操作数据的行为封装在一起给人耳目一新的感觉。随着编程经验和阅历的增长， 我开始觉得继承和多态才是面向对象最大的优势，运行时绑定的魔力太过于惊人。后来 我去看了设计模式，我又觉得组合才是面向对象编程的精髓之所在，面向接口而不面向 实现编程才是复用的王道。我知道有一天当我功力渐长之后，回过头来想这个问题的时候我 还会有新的看法，我也期待那一天快点到来。 关于这本书的翻译这本书的中文版参与翻译的人非常的多，结果就是质量参差不齐。总体感觉结构模式和行为 模式两个章节要比创建模式一章翻译的到位一些。不过瑕不掩瑜，这本书的翻译还算是可以 的，个人推荐在看中文译本的时候备一本英文原本，这样你可以在不通顺的地方那个参考英 文原本，了解作者的原意。 三思而后行读完这本书之后，我突然想起了《Effective C++》中的一个条款：考虑虚函数之外的其他 选择。其实一个问题通常都会又非常的多的解法可供选择，而大部分的时候，我们想都没想 就选择了虚函数，因为它通常比其他的方式要简单许多。 设计模式是一个问题较为灵活的解法，同时它也是这个问题较为复杂的解法。原来的我在编 程的时候重来不做设计，总是跟随自己的惰性，选择一种目前最简单的实现方式。其实这种 方式不一定就是不对的，只是在没有考虑过其他解法的时候就决定使用这种方式的做法是不 可取的。我们会满足与目前不优雅的解决方式的原因，是我们还不知道有更优雅的解决 方式。 读完这本书，我最想对自己说：三思而后行。在做任何一个你觉得理所当然的决定的时候， 先考虑一下，你是否还有其他更加合理的选择。 温故而知新设计模式是经验的总结，温故而知新，这是一种能力，更是我们需要学习的做事的态度。当 今的软件界，更像是一个共产主义时代，基本上你能够想到的任何的软件都已经有相关的开 源项目。学习那些优秀的开源软件是进步的绝佳途径，就像《黑客于画家》中说到的，只有 通过不断的临摹和观察大师的作品，我们才有可能会成为真正的大师。 此外总结也是非常非常重要的，把别人精湛的技巧内化成自己功力的一部分才有可能真正的 进步，学了忘、忘了学的循环只是在浪费自己的时间而已。 间接性这本书提到了 23 个模式，几乎所有的模式都是某种程度的间接操作，这就像是软件开发的 至理名言：任何问题都可以引入中间层来解决。也许有一天我们可以通过引入间接的操作来 解决设计模式中没有告诉我们解法的问题，或许有一天我们可以创造自己的设计模式。 模式感悟我一直觉得读书在于感悟，读《设计模式》这本书，我有非常多的感悟，我在书上写了密密 麻麻的各种笔记。正如作者所言，没有人会在第一遍看这本书的时候就读懂所有的内容，我 相信自己现在自以为是对作者观点的注解的各种笔记都可能是对于作者的观点的曲解。所以 我不打算把自己对于具体的每一个模式的感悟写在这里，这是一本需要反复的读的书，一千 个人眼中有一千个哈姆雷特，希望看到这篇文章的你能自己在这本书中读到自己的感悟。]]></content>
      <tags>
        <tag>读书笔记</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 年书单]]></title>
    <url>%2F2016%2F01%2F02%2Fbook-list-to-read%2F</url>
    <content type="text"><![CDATA[新的一年已经开始，这个学期已经接近期末，想来突然觉得恐慌，因为我真的要毕业了。我 即将要离开学校，离开这个我可以专心学习的地方，而我真的还有很多很多很多书没有看完 。幸运的是我还有将近半年的时间可以看书，我在这里写下我自己目前手头上有的一些书， 这些书必然是无法在今年全部看完的，都写在这里权当是自我勉励吧。 技术书籍 设计模式 UML 精粹 深度探索 C++ 对象模型 Effective C++ More Effective C++ Effective STL 程序员修炼之道 C++语言的设计和演化 黑客与画家 程序设计实践 C++标准库:自学教程与参考手册 Vim 实用技巧 Exceptional C++ More Exceptional C++ Exceptional C++ Style Autotool C++编程规范 C++设计新思维 C++ Templates 测试驱动开发 Effective Morden C++ 重构 代码大全 人月神话 设计原本 编码整洁之道 UNIX 编程的艺术 大教堂与集市 操作系统 TCP/IP 详解：卷一 UNIX 网络编程：卷一 UNIX 网络编程：卷二 Pro Git CMake Tutorial &amp;&amp; Mastering CMake C++ 沉思录 UNIX 编程环境 STL 源码剖析 非技术书籍 三体 解忧杂货店 冰与火之歌 全球通史 中国哲学简史 孟子注 孔子传 论语新解 春秋左传注 古龙作品全集 庄子今注今译 春秋左传今注今译]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客更新小记]]></title>
    <url>%2F2016%2F01%2F01%2Fupdate-blog-with-hexo%2F</url>
    <content type="text"><![CDATA[年前在公司实习，和同事说起博客的事情，他推荐我使用 hexo。回来一直忙着其他事情 ，也就没有尝试去了解 hexo 到底是什么玩意。新年忙里偷闲，折腾了一下这技术，可以 说是惊艳，爱不释手。于是把自己在 github pages 上面的博客使用 hexo 更新了一下 ，这里写一个小札记。 hexo个人认为无论是什么样一种技术，了解它的第一步应该是去它的官网看看，那里会有最权威 的信息和文档，hexo 也不例外，大家如果有兴趣了解 hexo，可以去它的官网 看看。 我不打算在这里介绍 hexo，因为我觉得官网上的信息已经足够你了解关于它的任何信息 了。如果你偏好教程类的文章而不太喜欢读文档的话，你可以查看下面这些文章（我粗略的 看过，感觉不算坑）。 hexo系列教程： next 主题我比较喜欢简约的风格，一直以来都认同 KISS 原则，所以我选的主题也是一个非常简约 风的 next。你可以在 hexo 的官网找到各种主题。 next 这个主题的有非常高的可配置性，你可以查看它的使用教程，定制自己的 主题风格。个人觉得需要注意的地方有下面这些： hexo 和 next 在文档中都把配置写在 _config 文件中，但是他们分别有自己的 配置文件。hexo 的配置文件在根目录下面，而 next 的配置文件在主题的根目录下 面（通常是 themes/next） next 有很多 custom.styl 文件可以用来定制你的主题。但是你更改这些文件之后需 要先把这些文件 commit 之后才会在 github pages 上起作用。 hexo 如何托管hexo 可以把生成好的网页一键发布到 github pages 上面，这个远比使用 jekyll 写文章要方便的多，但是我们如何托管 hexo 的源码呢？ 通常我们会创建 username.github.io 的仓库，并用它的 master 分支来用来托管 hexo 生 成的网页。你完全可以直接使用另外一个新的仓库比如 blogsource 来托管 hexo 的源码， 不过这样会生成两个不同的仓库，非常不方便。所以我个人趋向于让生成的网页和 hexo 使 用同一个仓库。 个人的做法是在 username.github.io 上面建立一个新的分支 source 用来存放 hexo 源码 ，这样你可以在另外一台电脑上把你仓库 clone 下来之后直接切换到 source 分支开始写 博客。 对于 hexo 源码的托管需要注意的地方就是因为 hexo 和 next 属于两个不同的仓库，所以 当我们把 hexo 的源码传到 source 分支后，它不会包含 next 中的文件，只会包含一个空 的文件夹。 你可以在每次克隆完 username.github.io 之后切换到 source 分支下面的 themes 目录， 然后再克隆一份新 next 的代码下来。当然这种做法的前提是你没有自己定制过 next 主题 ，因为官方的仓库中必然不会有你的定制代码更新。 我解决这个问题的方法是在自己的账户中 fork 一份 next 官方库，然后把自己的定制修改 提交到自己的仓库当中。以后需要重新 clone 主题的时候直接从自己的 next 仓库中克隆 即可。这样你可以保存自己的代码，同时也可以在 next 更新之后更新自己的私有库。 hexo 常用插件使用了一段时间之后碰到了一些问题，不过这些问题通常都可以通过插件解决，下面是我用 的一些插件 中文换行变成空格问题我原来使用 jekyll 的时候就发现了这个问题，最终通过自己编写插件解决了这个问题，并 写了一篇文章阐述问题产生的原因和解决方式，有兴趣的可以看看解决 jekyll 中文换行 变成空格的问题一文 。 hexo 中解决这个问题非常简单，你只需要安装插件 hexo-filter-fix-cjk-spacing即可。 脚注问题原来使用 jekyll 可以使用[^1]这样的方式生成脚注，但是在 hexo 中无法实现这一点。 为了能够使用脚注，我使用了hexo-renderer-markdown-it 这个插件，它的 功能非常强大，推荐大家使用。 不过需要注意的是默认的在 markdown-it 中你没有办法通过 more 来完成摘要的截取，你 需要在配置文件中使用如下的配置： 123markdown:render:html: true 具体的可以参考这个链接 https://github.com/hexojs/hexo/issues/1467 和这个链接 https://github.com/celsomiranda/hexo-renderer-markdown-it/issues/14 文章目录安装 hexo-toc 插件可以生成文章目录。关于 TOC 这一点，Hexo 的新版本似乎已 经内置支持了，但是我使用 hexo-next 主题的时候会生成目录，但是不会自动给目录选项 加上跳转链接。安装了hexo-toc 之后就没有了这个问题。 站点部署旧版本的 Hexo 内置支持 deploy 到 git 仓库中，新版本的需要安装 hexo-deployer-git。 搜索功能文章很多的时候，搜索功能显得非常的重要，hexo 3.0 之后可以使用下面 hexo-generator-search 建立本地搜索。]]></content>
      <tags>
        <tag>github pages</tag>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英特尔 QSV 在 FFMPEG 中的使用（Windows）]]></title>
    <url>%2F2015%2F10%2F08%2Fintel_qsv_windows%2F</url>
    <content type="text"><![CDATA[上一篇文章中介绍了 Linux 下如何在 FFMPEG 中使用 Intel QSV，这篇文章介绍如 何在 Windows 下使用这个功能。 INDE在 Windows 下通常使用 INDE 中的 Intel Media SDK 而不是 MMS，因为后者 只在 Linux 下和 Windows Server 下可用。 INDE 可以免费下载，建议下载它的离线安装包，因为很多功能你并不需要，使 用离线安装包，你可以指下载你想要的功能。 安装 Media SDK在 Windows 上安装 Media SDK 比较简单，请参考这个链接 中的安装方法。我们只使用它做视频编码，所以只需要选择 build 下的 - Media SDK for Windows - Media Raw Acclecerator for Windows 这两项就可以了。 Windows 下编译支持 qsv 的 FFMPEG 库编译 mfx_dispatcherwindows 编译 qsv 之前需要安装 mfx_dispatcher，它相当于是应用程序和具体的 硬件加速库之间的一个中间层，它负责帮助应用库定位底层代码，这样应用库就可以 不用直接链接到硬件加速的具体实现。 [mfx_dispatcher][] 代码可以在 github 上下载到，在 github 的 README 中也 提供了编译方法。需要注意的是，它使用的编译工具是 mingw64 的 x86_64 工 具链，如果你使用的是 mingw64 的 i686 工具库，记得把教程中的 x86_64 替换成 i686。 mfx_dispatcher 安装完成之后会在 /usr/i686-w64-mingw32/usr/local/ 下生成 相应的库文件和头文件。 链接到 FFMPEGFFMPEG 需要使用 pkg-config 定位 libmfx 库，这个库的 libmfx.pc 文件在 安装完 mfx_dispatcher 之后会安装在 /usr/i686-w64-mingw32/usr/local/lib/pkgconfig 目录下。为了让 FFMPEG 的 configure 脚本能够找到它你需要把这个地址加入到 PKG_CONFIG_PATH 中。 export PKG_CONFIG_PATH=/usr/i686-w64-mingw32/usr/local/lib/pkgconfig 为了让 FFMPEG 支持 qsv 你需要加入下面三个配置选项： ./configure --enable-libmfx \ --enable-encoder=h264_qsv \ --enable-decoder=h264_qsv \ ... 使用中可能会出现的问题在使用 h264_qsv 编码器的时候，可能会出现 Error initializing an internal MFX session 错误，目前没有找到具体原因。在把 Media SDK 下的 libmfxhw32.dll 文件拷贝到执行目录下之后这个问题就消失看。]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英特尔 QSV 在 FFMPEG 中的使用（Linux）]]></title>
    <url>%2F2015%2F10%2F08%2Fintel_qsv_linux%2F</url>
    <content type="text"><![CDATA[Intel Media SDK现在 Intel 不再发布单独的 Intel Media SDK， 这个组件在 Linux 平台下集 成在 Intel Media Server Studio 中，后文简称 MMS 目前的 MMS 版本推荐的安装平台只有一个 CentOS（SUSE12 在当前版本中也 算是一个推荐平台）。其他平台的安装比较复杂，官方也不太推荐使用。后文的介绍 是基于 CentOS 操作系统的。 如何安装 MMS首先，你需要在 Intel Developer Zone 下载最新的 MMS 版本，其 中的 Community 版本是免费的， MMS 的安装主要分三个步骤。 在解压出来的的文件夹下面有一个 SDK2015Production* 目录，切换到这个目录下 面之后，有一个 CentOS 目录。这个目录下面有一个 intel_scripts_centos* 压缩包，解压这个压缩包之后可以得到下面三个脚本： -build_kernel_rpm_CentOS.sh -install_sdk_UMD_CentOS.sh -uninstall_sdk_UMD_CentOS.sh 安装需要用的是前面两个脚本。 1. 安卓用户空间驱动（user-mode driver – UMD）下面的命令需要使用超级用户权限： ./install_sdk_UMD_CentOS.sh mkdir /MSS chown {普通用户名}:{普通组名} /MSS 2. 编译内核空间的驱动包下面的命令使用普通用户权限执行： cp build_kernel_rpm_CentOS.sh /MSS cd /MSS ./build_kernel_rpm*.sh 3. 安装内核空间的驱动下面的命令使用超级用户权限执行： cd /MSS/rpmbuild/RPMS/x86_64 rpm -Uvh kernel-3.10.*.rpm reboot 判断是否已经成功的编译内核模块驱动重启系统之后执行如下命令： lsmod | grep &apos;i915&apos; 得到的类似如下的结果： i915 837369 4 drm_kms_helper 44256 1 i915 drm 294746 3 i915,drm_kms_helper i2c_algo_bit 13509 1 i915 intel_gtt 19747 1 i915 i2c_core 40683 5 i2c_i801,i915,drm_kms_helper,drm,i2c_algo_bit video 19785 1 i915 button 13953 1 i915 如何在 FFMPEG 中编译 intel qsv 硬件编码器FFMPEG 中使用 libmfx 实现 intel qsv 的硬件编码器，如果想要编译它的硬 件编码器，所以如果想要编译这个硬件编码器，你需要在加入如下的配置选项： ./configure --enable-libmfx \ --enable-encoder=h264_qsv \ --enable-decoder=h264_qsv \ ... libmfx can not found using pkg-configlibmfx.pc编译中可能会报出下面的错误： libmfx can not found using pkg-config，这个 错误可能是不同的原因导致，你需要查看 ffmpeg 根目录下的 config.log 文件。 如果这个文件中报错说 pkg-config 无法找到 libmfx 这个库，那是因为 MMS 的 默认安装没有提供 libmfx.pc 文件，你需要在自己创建这个文件： sudo mkdir -p /opt/intel/mediasdk/pkgconfig vim /opt/intel/mediasdk/lib64/pkgconfig/libmfx.pc 在文件中写入如下内容： prefix=/opt/intel/mediasdk exec_prefix=${prefix} libdir=${exec_prefix}/lib64 includedir=${exec_prefix}/include Name: libmfxhw64 Description: Intel Media SDK dispatcher. Version: 2015r6 Libs: -L${libdir} -lmfxhw64 Cflags: -I${includedir} 注意这个地方引用的是 libmfxhw64 库，因为测试的是 64 位平台。 当然你可以可以选择在 /usr/lib64/pkgconfig/ 下面创建 libmfx.pc 文件。 mfx/mfxvideo.h同样是 libmfx can not found using pkg-config 这个命令，也可能是头文件的 错误，在 config.log 中会报错说无法找到 mfx/mfxvideo.h 这个文件。 在安装完 MMS 之后，在 /opt/intel/mediasdk/include/ 目录下面会有 mfxvideo.h 这个文件，但是在 FFMPEG 中，引用的是 mfx/mfxvideo.h 这个 头文件，因此报错，解决的方式是，在 /opt/intel/mediasdk/include 这个目录 下面新建目录 mfx，然后吧 include 的头文件拷贝一份到 mfx 目录下。 通过上面这种方式可以修正 mfx/mfxvideo.h 无法找到的错误。 链接 FFMPEG 时的错误在链接 ffmpeg 的时候还是有可能会出现 MFXxxx undefinded reference 的错 误，这时候你需要让你的程序链接到 lmfxhw64 这个库。最简单的方式是，在 /usr/lib64/ 中建立一个 libmfxhw64 的软连接 ln -s /opt/intel/mediasdk/lib64/libmfxhw64.so /usr/lib64/libmfxhw64.so 然后在编译自己的程序的时候加入 -lmfxhw64 选项。 在 FFMPEG 中使用 qsv 编码器qsv 的编码器在 FFMPEG 中有 h264 和 h265 两种，你可以通过下面的代码 找到这个编码器。 av_find_encoder_by_name(&quot;h264_qsv&quot;); 此外，通过 qsvenc_h264.c 这个源文件，我们可以看到它支持 QSV 和 NV12 两种格式，但是 QSV 这个格式好像无法正常的使用，你需要把编码的 pfx_fmt 设置成 NV12。]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英伟达硬件加速解码器在 FFMPEG 中的使用]]></title>
    <url>%2F2015%2F10%2F07%2Fnvenc_ffmpeg_usage%2F</url>
    <content type="text"><![CDATA[这篇文档介绍如何在 ffmpeg 中使用 nvenc 硬件编码器。 私有驱动nvenc 本身是依赖于 nvidia 底层的私有驱动的，所以想要使用编码器首先需要 安装 nvidia 的私有驱动。在 NVIDIA VIDEO CODEC SDK 的介绍中 说明，最新版本的 nvenc sdk 5.0 在 linux 需要 346.22 以上的驱动，在 windwos 下则需要 347.07 以上的驱动 The latest NVENC SDK version available is 5.0, which requires NVIDIA GPU driver 347.09 or above for Windows and 346.22 or above for Linux. 目前 Ubuntu 15.04 上的驱动满足这个要求，Windows 平台可以直接到官网上下载最 新的驱动安装。（个人不建议去官网下载最新的 Linux 驱动，因为我试了很多次都 没有安装成功，最终会导致无法进入系统）。 在 Ubuntu 15.04 下使用下面的命令安装最新的驱动。 sudo apt-get install nvidia-346 \ nvidia-346-vum \ nvidia-modprobe \ nvidia-opencl-icd-346 \ nvidia-prime \ nvidia-settings 注意 nvidia-modprobe 必须要安装，因为私有驱动使用的内核模块，需要安装这 个包在系统启动的时候加载这些内核模块。安装完成之后可能无法进入系统，这个应 该是 nvidia 中的一个 BUG，你可以重启之后选择 grub 中的 ubuntu 高级 选项 中低版本的内核进入系统之后重启再选择高版本的内核进入系统。这一点非常 的诡异，目前没有找到原因。 启动系统之后使用 lsmod | grep nvidia 应该会得到类似下面的结果： nvidia_uvm 69632 0 nvidia 8380416 36 nvidia_uvm drm 348160 7 i915,drm_kms_helper,nvidia 直接通过 sudo modprobe nvidia_uvm 好像也无法成功的加载需要的模块。 另外安装驱动安装完成之后会在 /dev 下面创建几个和 nvidia 相关的设备，通过 ls /dev/nvidia* 应该会得到类型以下的结果： /dev/nvidia0 /dev/nvidiactl /dev/nvidia-uvm 编译 FFMPEG要想在 FFMPEG 中使用 nvenc 编码器，你需要在编译选项中加入 enable-nvenc 选项。这个选项依赖于 nvEncodeAPI.h 头文件，这个头文件并没有包含在私有驱 动中，你需要到 NVIDIA VIDEO CODEC SDK 中下载 SDK，解压后在 Samples/common/inc 目录下有这个头文件，把它拷贝到可以链接到的目录中去。 之后编译就可以顺利的通过，得到包含 nvenc 编码器的库。 使用 nvencFFMPEG 中直接使用 av_find_encoder_by_name(&quot;nvenc&quot;) 就可以找到这个这个编 码器并使用它。nvenc.c 的 pix_fmts_nvenc 变量定义来看，这个编码器应该是 支持 YUV420P, YUV444P 和 NV12 三种格式的，但是测试的过程中发现 YUV420P 没办法使用，所以应该吧 AVCodecContext 的 pix_fmt 设置成 NV12。]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英伟达硬件解码器分析]]></title>
    <url>%2F2015%2F10%2F07%2Fnvcuvid_analyse%2F</url>
    <content type="text"><![CDATA[这篇文章主要分析 NVCUVID 提供的解码器，里面提到的所有的源文件都可以在英伟 达的 nvenc_sdk 中找到。 解码器的代码分析SDK 中的 sample 文件夹下的 NvTranscoder 中包含了编码器和解码器的用法，编码 器的内容不在这里分析，因为 FFMPEG 中已经包含了相关的代码，不需要其他的处理 。 解码器在 SDK 中有一份封装，主要是 NvTranscoder 下的 VideoDecoder 类。目前 这个类的具体用法还不是特别的清楚。分析将会从 main 函数开始。 mainNvTranscoder 有一个单独的文件，执行逻辑从 main() 函数开始。 cuInit(0) 应该是初始化 cuda 的相关代码。目前没有找到定义，估计类似于 FFMPEG 中的 av_register_all。 105 行之前的代码是编码相关的代码， 85 行以前设置各种编码参数，87 行分析从 命令行读入的参数，100 行打开目标输出文件。 110 行开始代码应该是和解码相关的核心代码。cuDeviceGet, cuCtxCreate cuCtxPopCurrent, cuvidCtxLockCreate 应该是固定写法。初始化一些内部机制 。 120 行的 InitVideoDecoder 是解码器创建的地方。这个函数需要认真的分析，整 个解码器的关键代码应该就在这里面。 137 行初始化 119 行中创建的 FrameQueue。这个队列应该相当于解码器和编码器之 间的一个缓冲区，解码器方内容进去，编码器从中取内容出来。 139 行到 180 都是关于编码器的设置。这里不做详细的分析。 187 行的注释显示 pthread_create 创建出来解码线程，所以解码工作是由这个线 程完成的。线程执行的函数是 DecodeProc 这个函数，而这个函数只不过是调用的 解码器的 Start() 方法。 195 行的代码注释来看，这后续的代码都是编码相关的代码，这里不做分析。最后在 245 行和 246 行的未知 cuvidCtxLockDestroy 和 cuCtxDestroy 应该是对应于 110 行的那些代码。 VideoDecoder.cpp这个文件实现了解码器的封装类 CudaDecoder, 这个类是整个硬件解码器实现的关键 ，但是这个类其实比较简单。它在 main 函数中涉及到的方法只有 InitVideoDecoder, GetCodecParam, Start 和 GetDecoder 这四个。 InitVideoDecoder这个方法是首先被调用的方法。它负责编码器的初始化操作。 从 VideoDecoder.cpp 中的实现来看，初始化主要包括三个部分： 创建视频源视频源的参数是 CUVIDSOURCEPARAMS，其中设置了一个 pfnVideoDateHandler，从 字面上理解它是一个视频数据的回调处理函数。 创建视频源的方法是 cuvidCreateVideoSource() 函数，目前来说这个函数的致命 问题在于它的接收 videoPath 作为参数，这似乎意味着它只能处理文件视频源。这 个函数的函数原型定义在 nvcuvid.h 这个头文件中，这个头文件只定义了下面这 些和视频源相关的接口： cuvidCreateVideoSource(); cuvidCreateVideoSourceW(); cuvidDestroyVideoSource(); cuvidSetVideoSourceState(); cuvidGetVideoSourceState(); cuvidGetSourceVideoFormat(); cuvidGetSourceAudioFormat(); 从接口来看只有 cuvidCreateVideoSource(); cuvidCreateVideoSourceW(); 这两 个函数可用，而它们唯一的区别在于接收不同的文件路径字符串，前者是普通字符而 后者是宽字符。 目前暂时没有其他的资料表明可以创建非文件类型的视频源，所以这个解码器的用处 估计不会太大，至少在传屏应用中的用处会相对较小。 获取视频源的参数，并创建 cuvid 库的解码器视频源的参数信息在创建视频源之后可以通过 cuvidGetSourceVideoFormat() 函数 获得，在 InitVideoDecoder() 函数中获取参数最诡异的地方在于 111 行创建了 一个 CUVIDOFORMATEX 类型的变量 oFormatEx，然后让 oFormat 引用这个变量 的 format 字段。在调用 cuvidGetSourceVideoFormat 之后竟然可以直接访问 oFormatEx 这个变量的 raw_seqhdr_data 字段，个人估计它的内部实现使用了 类似 container_of 这样的技术访问了 oFormatEx。但是为什么这样设计不得而 知。 创建解码器的函数是 cuvidCreateDecoder()，这个函数的原型定义在 cuviddec.h 文件中。 cuvidcreatedecoder(cuvideodecoder *, CUVIDDECODECREATEINFO *); cuvidDestroyDecoder(CUvideodecoder); 解码器的参数是通过 CUVIDDECODECREATEINFO 传递的，这个结构体的大部分字段 都是通过前面获得的 oFormat 中的信息获得。 创建视频源的解析器初始化的最后一步是创建一个视频源的解析器，其中设置了三个回调函数， HandleVideoSequence, HandlePictureDecode, HandlePictureDisplay, 在 nvidia 的文档中并没有说这些回调函数会在什么时候调用，也没有说明这些回调 函数要完成的事情是什么，只能从名字中猜测 HandlePictureDecode 这个函数是 用来解码的。 Start在 main 函数的解码线程函数中只调用了 CudaDecoder 类的 Start 函数。而 Start 函数本身也非常的简单，只不过调用了 cuvidSetVideoSourceState() 把状 态变成 cudaVideoState_Started 然后一直取状态直到状态不再是 started。 从这个函数的实现来看，它的内部应该在把视频源设置为 cudaVideoState_Started 状态之后开始读取视频源（文件）中的数据。然后通过 回调函数进行处理。应该是首先调用 HandleVideoData(), 个人猜测这个函数在数 据从文件中读取出来之后会被调用来解析原始数据，HandleVideoSequence 这个函 数没有太大的用途，只是一些参数的检测而已。HandlePictureDecode 应该是在成 功解析到数据帧的时候调用，这个函数调用了 cuvidDecodePicture 解码数据。数 据解码出来之后会调用 HandlePictureDisplay 函数，该函数把数据放入到数据缓 冲区 FrameQueue 中以便编码器能够把数据取出来。 总结使用 CudaDecoder 首先需要调用 cuvidCreateVideoSource 创建一个文件视频源， 然后调用 cuvidGetSourceVideoFormat 从文件中读取解码参数信息并使用参数信 息创建一个 CUvideodecoder 解码器，之后再创建一个视频源解析器，设置回调函 数处理视频的解码。 上面的初始化完成之后调用 cuvidSetVideoSourceState 把视频源的状态设置为 cudaVideoState_Started，之后库的内部会开始读文件，把读取的数据交给 HandleVideoData 解析，解析完成之后会把数据交给 HandlePictureDecode 调 用 cuvidDecodePicture 进行解码。在解码完成之后调用 HandlePictureDisplay 把数据放入到 FrameQueue 缓冲区里面。 补充：video source 和 nvcuvid在 SDK 给出的例子中，数据是通过 video source 接口来提供的。但是这并不意 味着我们在编写程序的时候只能使用它提供的 video source 接口。根据官方文 档 中第三小节最后给出的解释 Note: The low level decode APIs are supported on both Linux and Windows platforms. The NVCUVID APIs for Parsing and Source Stream input are available only on Windows platforms. NVCUVID 的 video source 只在 windows 平台可用，不过从最新的 nvenc_sdk 的代码来看，videosource 和 sourcepraser 在 linux 平台下也是可 用的。只不过从接口来看，这两个 API 只能用于文件的解析。 在文档的第四小节 4.2 中有这么一段话： For Linux platforms, you will need to write your own video source and parsing functions that connect to the Video Decoding functions. 这一点明确说明，其实我们可以不使用它本身的 video source 接口，使用自己的 接口提供视频源，然后使用 nvcuvid 最底层的解码接口对数据进行解码和后续处 理。 MAP在 nvcuvid 的官方文档中给出的接口中，最诡异的两个接口是 cuvidMapVideoFrame() cuvidUnmapVideoFrame() 这两个函数好像是用于处理解码之后的数据的，但是这其中的原理是什么并不清楚， 有待后续研究。]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英伟达硬件加速编解码器的介绍]]></title>
    <url>%2F2015%2F10%2F07%2Fgpgpu%2F</url>
    <content type="text"><![CDATA[硬件加速硬件加速的学术名称是 GPGPU（General-purpose computing on graphics processing units），中文名称是通用图形处理器。最基本的思想是使用 GPU 的运 算能力完成原本需要 CPU 来进行的运算。 并行计算GPU 是用来处理图形任务的图形处理器，其中一个非常大的优势在于它的并行处理能 力。面对单指令流多数据流（SIMD），并且数据处理的运算量远大于数据调度和传输 的需要时，GPU 的并行处理效率要高于传统的 CPU 的处理。 为了充分的利用 GPU 的并行处理能力，大部分的显卡厂商都推出了自己的 GPU 开发 SDK，比如： NVIDIA —— CUDA Intel —— Intel® Media SDK AMD —— AMD APP SDK（前身是 ATI Stream） 当然这些厂商都是各自为阵，推出的 SDK 都是只能用于自己的显卡的 SDK，所以代 码想要在不同的平台上能够统一是比较困难的。 OpenCLOpenCL（Open Computing Language，开放计算语言），是一个为异构平台编写程序 的框架，此异构平台可由CPU，GPU或其他类型的处理器组成。这种语言主要是为了异 构平台的并行运行设计的。 从本质上来说，它和 CDUA 等等 SDK 上是不同的，它是一种语言，相当于是 JAVA 语言这个级别，而后者是一个开发包，相当于 JDK 这个级别。 OpenCL 目前的语言规范已经到了 2.1（Preview），支持最好的 AMD 的 SDK，最新 版本已经支持了 OpenCL 2.0，其他两个只支持 OpenCL 1.2。 OpenCL 提供了一个统一的 API，这个 API 在上述的厂商的 SDK 中都有实现。所以 安装 CUDA 会包含 OpenCL 组件，它是英伟达对于 OpenCL 语言的一种实现。 OpenCL API VS SDKOpenCL API 最大的优势在于它的跨平台，可以在不同的架构上运行，所以理论上它 比 SDK 更有竞争力。但是它最大的问题在于它的 API Level 比较基础，直接使用它 进行视频的编解码处理难度比较大。 此外 OpenCL API 的实现是依赖于底层的 GPU 架构的，不同的厂商提供了不同的实 现，使用之前需要安装不同厂商提供的实现，从这个角度考虑 OpenCL 的跨平台并没 有想象中那么完美。 SDK 的问题在于不同的厂商的 SDK 是不兼容的。但是它提供了比 OpenCL API 更加 丰富的功能，比如 NVIDIA 直接提供了视频编解码相关的接口，使用起来会比 OpenCL API 更加的轻松。 英伟达硬件编解码方案实现英伟达的 GPU 硬件编解码可以使用如下几种方案： 基于 OpenCL 的 API 自己写一个编解码器这的难度非常大，首先你需要对于 OpenCL API 非常的熟悉，其次你需要对于编解码 的知识了解的非常透彻。这两个问题的任何一个都有非常大的难度，以目前已有的技 术来说成功的概念不是特别大。 MainConcept 公司做了这件事情，它提供了基于 OpenCL 的 H264/AVC 编码器，但是 这个编码器是商用的（此外它还提供了基于 CUDA 的编码器和基于 Intel QSV 的编 解器，以及包装过前面几者的编码器）。 所以从技术可行性上来说这个是可行的，只是目前来说个人还不具备这个实力。 使用 SDK 中的编解码接口英伟达关于视频的编解码提供了两个相关的 SDK NVENC NVCUVID 前者负责硬件编码，二后者负责硬件解码。 NVENC 是一个单独的 SDK，集成在最新的显卡驱动上面，安装最新的驱动之后可以 找到相关的库文件。在 Ubuntu 14.04 中，可以在 /usr/lib/nvidia-352/ 目录下 面找到相关的库文件。 NVCUVID 是 CUDA 的组件，包含在最新的 CUDA Toolkit 中。不过在显卡的类 库中可以找到 libnvcuvid.so 这个库文件。在之前版本的显卡驱动中其他还包含 一个称之为 NVCUVENC 的硬件编码器和 NVCUVID 相对应，不过目前这个组件已 经被 NVENC 替代了。 使用编码器对于 OpenCL 和 SDK 的封装这种方式是个人认为最理想的方式，FFMPEG 目前存在一个编码器 nvenc 是对于英 伟达的 NVENC 的封装，通过使用它可以和 FFMPEG 无缝的整合起来。此外它也包 含对于 Intel QSV 的封装。AMD 的相关接口目前没有找到相关的资料。 不过 FFMPEG 只存在 NVENC 的接口，不存在 NVCUVID 的封装。如果需要实现相 关的解码器可能需要自己实现 FFMPEG 接口。 libx264 有对于 OpenCL 的封装，不过我在 windows 中尝试这个功能的时候并没 有成功。 另外还存在一个开源的格式转换器 HandBrake，它包含对于 Intel QuickSync 的封装，以及使用 OpenCL 进行图象的拉伸处理和使用 x264 的 opencl 封装 。这个项目缺点在于文档不是很丰富，研究起来有一定的难度。]]></content>
      <tags>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器系列之 —— 编辑利器 Vim 之插件配置]]></title>
    <url>%2F2015%2F10%2F06%2Fvim-plugin%2F</url>
    <content type="text"><![CDATA[在每个程序员的心里都有一款完美的 IDE，只不过不同的程序员心中对于完美的定义 并不相同，所以从来都没有一款大家都喜欢的 IDE 存在，它们总是少一些你想要的 功能，或者是多了一些你不想要的功能。 解决这种问题的方法之一是配置，这也是为什么备受大家推崇的各种编辑器或者 IDE 都含有大量的可配置选项，通常来说我们可以通过配置选项把编辑器现有的功能配置 成我们最顺手的状态。 但是如果编辑器没有你想要的功能，配置是无济于事的。增强编辑器的功能，靠的是 这篇文章中要介绍的 —— 插件。插件的存在是 Vim 和 Emacs 这类的编辑器能够备受 推崇的原因之一，因为它们让不可能变成可能。 其实最理想的状态应该是像 Shougo 这类的大神一样，不爽了自己写一个。可惜的 是大部分人没有这个能力，我们通常是用大神写好的插件。这篇文章介绍的是如何使 用 Vim 的插件，而不是如何编写自己的插件。 如何找到自己想要的插件Vim 的插件很多，所以如何找到一个合适的 Vim 插件也是一件比较头疼的事情。最 简单的做法是使用别人的 Vim 配置文件，比如我最初使用的配置文件就是k-vim 。这一类的配置文件通常是作者多年以来使用 Vim 过程中积累的经验，他们选用的 插件也通常是一些最好用的插件。 另外一种方式就是去介绍 Vim 插件的网站上查找排名最前的那些插件。我最喜欢的 Vim 插件网站是 vimawesome。这个网站上的每个插件都会有评分，一般来说最 靠前的都是大家用的最顺手的。 当然你也可以去 github 上搜索相关的插件，然后看看哪一个插件的 star 最 多。 插件的安装通常我们会使用大量的插件，这些插件的管理（安装、删除、升级）非常不便。为了 解决这个难题，我们需要一个管理插件的插件，这一类型的插件很多，用的比较多的 有： -Vundle -Neobundle -Pathogen -VimPlug 我一直都是使用 Vundle，它可以非常方便的管理插件。中间两个我没有使用过在这 里不做介绍，最后一个是比较新的插件管理器也非常好用，有兴趣的可以去它们的主页上 查看相关信息。 Vundle 的安装比较简单，只需要两个简单的步骤即可： 1. 克隆插件代码：git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim 2. 在配置文件中插入：set nocompatible filetype off set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin &apos;gmarik/Vundle.vim&apos; call vundle#end() filetype plugin indent on Vundle 是唯一一个我们需要手动安装的插件，安装完这个插件之后你可以通过它 帮你自动完成其余插件的安装。比如我想要安装 delimitMate 这插件，你只需要 做如下的配置： call vundle#begin() Plugin &apos;VundleVim/Vundle.vim&apos; Plugin &apos;Raimondi/delimitMate&apos; call vundle#end() 也就是在 call vundle#begin() 和 call vundle#end() 之间加入你想要配置插 件的名字。Vundle 支持多种插件源，其中 Raimondi/delimitMate 这中写法表示 安装 github 上 Raimondi 用户的 delimitMate 插件。详细的语法请参考 Vundle 在 github 主页中的介绍，或者通过 h vundle 查看帮助文档。 常用插件推荐Vim 好用的插件太多，我一般只用 Vim 做 C/C++ 的开发，所以这里推荐的插件很多 都是和 C/C++ 相关，如果你用它做其他类型的开发，可以自行寻找相关的插件。 插件安装之后通常需要一些简单的配置，这里并没有给出这些配置，因为配置通常因 人而异，不同的人喜欢不同的快捷键，写在这里也会使得文章本身变得复杂。大部分 的插件的配置方式在项目主页上都会给出，我给出了所有插件的主页链接，所以就不 再给出配置方法。如果你确实需要参考，可以参考我的代码仓库中的相应配 置文件。 界面美化类型插件vim-colors-solarizedsolarized 是一个非常有名的主题，这个插件是它的 Vim 版本。 不过这个主题 只能用在 GVim 中。如果你在终端中使用 Vim，那么你应该寻找终端主题工具而不是 Vim 主题插件。xfce 自带的 xfce4-terminal 和 kde 自带的 konsole 都带有这个主题，Ubuntu 15.04 以后的 gnome-terminal 也带有这个主题，在 之前的 Ubuntu 版本中想要使用合格主题可以安装 gnome-terminal-colors-solarized 这个插件。通常这个插件需要配合 dircolors-solarized 这个插件同时使用，这样才能达到最佳的显示效果。 vim-airline这个插件是一个状态栏（statusline）和标签栏（tabline）的一个增强插件，它是 vim-powerline 的一个后继插件，它使用纯 VimL 编写，不需要用到 Python 所 以它的速度要快一些，也轻巧一些，这也是称之为 air 的原因。 这个插件可以说是漂亮的不像实力派，它功能非常强大，同时又有大量的主题存在， 可配置性非常的高，强烈推荐。 tmuxline如果你喜欢把 Vim 和 tmux 配合起来使用，那么你可以考虑安装 tmuxline 这个 插件，它可以把 tmux 和 Vim 的状态栏设置成统一的主题，让这两者更加完美的融 合。关于 tmux 的使用，你可以参考我的另一篇博文分屏利器 Tmux 自动补全插件自动补全插件通常分为两种：代码块的插入和输入自动补全。很多人想到的自动补全 都是第二种，但其实第一种的功能也是强大到没有朋友的。 代码块的插入所谓代码块的插入，其实就是把一些常用的代码块通过简单的几个字符扩展成完整的 代码，相当于是缩写替换成全名。比如输入 main 使用扩展，立刻插入： int main(int argc, char *argv[]) { |&lt;- 光标位置 return 0; } 输入： fori 使用扩展，可以插入： 光标位置 V for (int i, i &lt; |; i++) { } 这一类的代码，在你是编写任何一种语言的代码时都会存在，而这种插件的存在会大大的 提升你的编码效率。 ultisnips代码块的插入其实又分开为两个插件，引擎 和 代码块描述。引擎 的作用是 驱动整个代码块扩展，比如你输入 main 之后按下扩展键，它负责找到相应的代码 块并完成扩展。而 代码块描述 用来说明 main 到底是扩展成 int main(int argc, char *argv[]) 还是： int main(void) ultisnips 就是所谓的 引擎，它是基于 Python 的，所以我们需要首先安装 Python，在大部分的 Linux 发行版本中，默认自带 Python，其他操作系统可能需 要自行安装。 vim-snippets通常我们不会自己编写 引擎 但是我们可以自己编写想要的 代码块描述。当然有一 些 代码块描述 写的比较好而且非常全面，所以也成了一个常用的插件，这也就免去了 自己动手写 代码块描述 的麻烦，vim-snippets 就是这种代码块描述插件。 当然这并不意味着你就只能使用它们的 代码块描述，你完全可以根据自己的喜好 进行自己的定制和扩展。 输入补全插件 —— YouCompleteMe这一类的插件，几乎所有的 IDE 都有提供，比如你输入 vim- 的时候列出 vim-colors-solarized，vim-airline，和 vim-snippets 供你选择补全。 这种插件在 Vim 中比较多，最受欢迎的应该是 YouCompleteMe，这个插件也是强 大到没有朋友的级别，不过这个插件比较难以安装，因为这个插件非常的庞大，在墙 内安装它非常的耗时，很多时候你可能会安装到一半的时候突然出错。不过这个插件 着实强大，不妨多试几次。 除了 YouCompleteMe 之外还有其他的一些自动补全的插件也比较好用，比如 neocomplete 插件。这些插件通常可以和前面的 ultisnips 配合使用，具体的 配置方法你可以参考它们的帮助文档，或者直接 Google。 兼容插件 —— supertabultisnips 和 neocomplete 都使用 tab 作为触发按键，所以会有冲突，你可 以通过配置改变其中一个的触发按键，也可以通过 supertab 这个插件，让它们共 存。YouCompleteMe 的文档说它集成了 supertab 的功能，如果你选择使用它的 话，可以不用安装这个插件。 括号匹配在 C/C++ 中使用了大量的括号（这里的括号包括单双引号），这些括号通常是必须 配对的，初学者容易因为错漏这些匹配的括号而导致错误。解决这一类的错误的最佳 方式通常是成对的输入这些括号，你可以手动完成他们，也可以通过插件自动完成它 们。 delimitMate，auto-pairs这个插件可以很轻松的完成括号的匹配输入，通常有它就够用了。它比较轻巧，速度 很快。另外一个类似的插件 auto-pairs 也可以完成这一操作，不过它的速度要比 delimitMate 慢一些，不过功能相对强大一些，比如： for (int i = 0; i &lt; 10; i++) {|} 使用 delimitMate 完成匹配后输入回车，你可以得到 for (int i = 0; i &lt; 10; i++) { } 而使用 autopair 你可以得到 for (int i = 0; i &lt; 10; i++) { | } 总的来说，后者相对智能一些，不过速度不如前者，选择哪个全看个人洗好。 rainbow_parentheses括号匹配在数量较少的时候比较容易，一旦嵌套过深，查找对应的另一半会比较困难 。 Vim 为了解决这个问题提供了 % 这个快捷键，跳转到对应的括号上面，这个按 键的问题在于你需要先把光标移动到其中一半括号上，而且这个按键本身不是很好输 入。rainbow_parentheses 这个插件的作用是把匹配的括号通过同一种颜色标出来 ，这样我们可以很容易的通过视觉找到匹配的括号。这在类似于下面这样的代码中还 是比较实用的。 if ((c = getchar())) 当然如果你的代码嵌套过深，你首先应该想的是是否该改一改你自己的代码了。 vim-surround老实说这个插件和括号的匹配本身没有太大的关系，只是功能类似所以放到一块。这 个插件其实也是一个杀手级的插件，它可以在你指定的内容周围环绕成对的符号。比 如，你可以快速把 hello world 变成： &quot;hello world&quot; 或者更神奇的： &lt;H1&gt;hello world&lt;/H1&gt; 而这一切并不需要你切换到输入模式才能完成。关于它的详细用法可以参考它的帮助 文档。 和 vim-surround 配对的另一个插件是 vim-repeat 有了这个插件你可以重复上 一次 surround 动作。 Git 集成 —— fugitiveGit 是我用的最多的版本控制工具，Git 和 Vim 这两个看似风马牛不相及的神器同 样可以通过插件统一起来，这个插件就是 [fugitive][] 有了它你可以在 Vim 中 可视化的完成大部分 Git 操作，非常的方便。 不过在 github 的项目主页上没有太多关于它的用法的介绍，建议感兴趣的人查看它 的 help 文档，里面有详细的功能介绍。 多行编辑 —— multiple-cursors这个功能不知道是不是从 sublime 中学过来的，我在 sublime 中也见过，算是 它的王牌功能之一。要在 Vim 中使用这个功能你需要安装 vim-multiple-cursors 这个插件。这个插件最实用的地方就是你如果想要替换一个变量名，你不需要挨个的 替换，使用它可以先可视化的选择然后一次全部替换。 光标的快速移动 —— easymotionhjkl 已经让光标的移动非常的方便了，但是它们毕竟只能移动一个单元格，如果 你想要移动多个单元格你需要在这些快捷键前面加上移动的数量，比如 10j 向下 移动 10 行，可是我很少使用这个操作因为我没有这个脑力去计算目标行和当前行之 间的距离。 为了解决这个问题，很多人推荐使用相对行号，这样就可以直观的感受到这个距离而 不用自己计算。这当然是一个不错的选择，只不过有些人不喜欢用行号，因为它占用 了一部分可用的编辑区域。此外相对行号在调试程序的时候不太方便，毕竟你的编译 器通常告诉你在哪一行出错，而不是相对当前行在哪一行出了错（当然这些都是个人 喜好问题，我通常直接通过在命令模式下输入行号跳转到我想要的行号）。 如果我可以先按下 j 然后选择要跳到哪一行而不是先想好要跳到哪一行再按下 j 该有多好。vim-easymotion 就是完成这个功能的，你可以先按下方向键然后 可视化的选择你的目标，一切就是这么 easy。 项目管理如果你需要开发一个比较庞大的项目，你很容易迷失在大量的文件当中。这一小结主 要介绍大型项目管理的一些插件 nerdtree这个插件，久负盛名，它给 Vim 提供了方便的目录功能，很多人对它爱不释手，因 为大部分 IDE 都有这个功能，它可以给你一种很熟悉的感觉。当然它会比普通的目 录浏览器要强大，因为它提供大量的快捷键，操作起来非常方便。此外它可以很方便 的完成打开和关闭，如果你有一块比较大的显示器，你可以一直开着它，如果你只用 笔记本，你也可以关闭它，需要的时候再打开。 ctrlp这是另一个杀手级的插件，目录通常只是方便浏览而已，其实大部分的时候我们真正 想要的是快速找到并编辑某个文件。这一类的插件比较多，我最喜欢的是 ctrlp， 这个插件提供了文件查找，buffer 管理，最近使用文件查找等功能，通过扩展还可 以查找函数，非常的方便。我使用过许多类似的插件，但是这个是这个是我最喜欢的 ，因为它的速度要比其他的插件快很多。 如果你喜欢捣鼓其他的插件，你可以考虑 ctrlspace 和 unite 这两个工具 ，它们的功能也比较强大，萝卜白菜，各有所爱。其中 unite 的功能最为强大， 它有很多 ctrlp 没有的功能，没有用过的可以考虑尝试一下。 ctrlsf项目的开发，如果工程比较大，你可能会需要做一些简单的重构，比如更改一个变量 的名字。 如果这个变量只在一个文件中出现，你可以使用后面推荐的 multiple-cursors 这个插件，一次选中所有的变量，然后全部更新。 但是如果 这个变量出现在不同的文件中（比如头文件和实现文件中都有出现），上面这个工具 就不够用了。这时候你可以使用 ctrlsf 这个插件。 这个插件和 multiple-cursors 一样是从 sublime 中学过来的功能，你可以 查找工程中某个名称出现的所有位置。如果只是单纯的查找，ack 这个插件也可 以完成这一工作，ctrlsf 真正强大的地方在于你可以在结果页面中进行编辑， 这个功能配合 multiple-cursors 可以实现非常强大的重构功能，强烈推荐大家 使用。 tagbar许多的 IDE 会有一块区域列出当前文件中所有函数，Vim 中也可以通过插件实现这 一功能。我比较喜欢的插件是 tagbar，轻巧但很强大。这个插件依赖 ctags，所 以你需要在安装插件之前安装这个软件包。 cscope如果你的项目非常的大，代码之间的跳转会变成一件非常的困难的事情，你通常在阅 读到一个函数的调用的时候想要阅读一个函数定义，或者函数的实现。在项目比较小 的时候你可以自己查找然后打开定义文件，当项目非常庞大的时候这一切就变得力不 从心了。你可能会很希望有一个插件，让你直接使用快捷键就可以跳转到该函数的实 现中去。YouCompleteMe 插件可以配置这个功能，你也可以使用更加强大的 cscope。 cscope 不是 Vim 的插件，而是 tag 的生成工具，你可以通过它和 Vim 的集成，让 它为 Vim 生成 tag，方便 Vim 进行跳转，具体配置参考 cscope 主页给出的方法 。 代码注释快速注释代码 —— nerdcommenter代码的快速注释是一个非常实用的功能，这个功能我通常使用 nerdcommenter 来 实现。它可以很方便的实现代码的注释和反注释的功能。 文档化代码注释 —— DoxygenToolkit好的代码注释本身就是一份非常好的文档，要把注释转换成书面文档，通常会使用 doxygen，我们可以通过 DoxygenToolkit 这个插件很方便的在 Vim 中编写符合 doxygen 格式的注释文档，然后通过 doxygen 生成相应的文档。 C++ 相关的其他插件语法高亮升级 —— vim-cpp-enhanced-highlightVim 内置的语法高亮对于 C++ 的支持并不完美。对于标准库它无法高亮显示， vim-cpp-enhanced-highlight 这个插件可以增强高亮效果。 头文件和实现文件之间的跳转 —— vim-fswitch如果我们处于开发的初期，接口的定义并不是特别完善的时候，我们通常是需要在头 文件和实现文件之间不断的跳转的。你很可能在实现一个接口的时候突然发现需要修 改它的接口定义，于是需要找到头文件修改定义，又或者你在头文件中修改了接口的 定义，需要去实现文件中做相应的更新。vim-fswitch 这个插件可以帮我们完成 这一工作。 代码格式化工具 —— vim-autoformatVim 的代码格式化功能个人觉得只能算是凑合，C++ 代码格式化的选项并不多，为了 能够更好的格式化 C++ 代码，个人比较倾向于使用 astyle。 如果你需要在 Vim 中使用 astyle 你可以考虑安装 vim-autoformat 这个插 件，它可以在 Vim 中集成各种格式化工具包括 astyle。vim-autoformat 插件 需要 astyle 2.0.5 以上的版本，Ubuntu 中的版本没有达到这个要求，所以你 需要自己编译安装它。 Vim 的插件太多，以上只是个人常用的一些而已，你可以自己去寻找自己喜欢的那些 插件。此外插件好用不要贪杯，多了会让你的 Vim 失去它原本的轻巧和敏捷。]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器系列之 —— 编辑利器 Vim 之快捷键配置]]></title>
    <url>%2F2015%2F09%2F03%2Fvim-shortcut%2F</url>
    <content type="text"><![CDATA[无论我多爱 Vim，不容否认的一点是它的快捷键对于现在的大部分人来说比较诡异， 这其中的有很深的历史渊源。这篇文章将会重点介绍 Vim 的快捷键的由来以及个 人偏好的一些快捷键设置。 诡异的快捷键看似诡异的 Vim 快捷键其实并不诡异，这一切的一切要从 Bill Joy 和那台 ADM-3A 说起。所有学计算机的人，或者说所有用电脑的人都应该记住 Bill Joy 这个人，因为他主导开发了 BSD Unix 系统。这个系统是整个操作系统发展史上的 一座丰碑，它给我们提供了虚拟内存、网络套接字、ex、C shell 还有 Vi 等 等强悍的功能，而这些东西大部分都是 Bill Joy 写的。虽然 BSD 已经停止开 发，但是它的后代还在不断的发挥余热，苹果的操作系统的内核 Darwin 就是基于 BSD 的。 Bill Joy 的作品太多，这里要说的是它的神作 Vi，这个后来发展成为 Vim 传世神器。Vim 的快捷键之所以这么诡异就是拜它所赐，当年 Bill Joy 编写 Vi 的时候年代还比较久远，那时候他们用的不是普通的键盘而是终端机，当时 Bill Joy 使用的终端机叫做 ADM-3A，它的键盘的按键分布和我们现在的普通键 盘的按键分布大有不同，我在 wikipedia 上找到一张它的键盘分布图如下： 看完这张图你大概会明白为什么 Vim 使用 hjkl 作为方向键；为什么把如此常 用的回到普通模式功能绑定在现在很难输入的 Esc 按键上；为什么大部分的常用 键都绑定为单字符快捷键而命令输入快捷键要绑定在 : 这个需要按住 shift 才 能输入的按键上面；为什么用来绑定快捷键的 mapleader 会是 \ 这个按键，毕 竟快捷键是为了输入快捷，但是 \ 这个字符在大部分的键盘上输入都比较慢。 快捷键的修改Vim 源自 Vi，它沿用了后者的快捷键，而这些快捷键中有一些目前显得太过于 别扭了。幸运的是 Vim 是一个高度可配置的编辑，你可以随意的更改它的快捷键 ，也可以创建自己喜欢的快捷键。 递归绑定和非递归绑定Vim 的快捷键绑定分为递归和非递归两种，比如： &quot; 非递归方式 noremap &lt;space&gt; : noremap : / &quot; 递归方式 map &lt;space&gt; : map : / 第一个绑定最终的结果是输入空格会变成命令模式 :，输入 : 则会变成搜索按 键 /。第二个绑定最终的结果是输入空格最终变成搜索按键，而你没有办法再输入 : 进入命令模式（千万不要做这种配置，这里只是举了一个不恰当的例子）。 绑定模式Vim 的快捷键绑定比较复杂，因为它可以基于不同的模式绑定不同的快捷键，而 Vim 包含六类的 mapping 模式，下面这段话摘自 Vim 的帮助文档： There are six sets of mappings For Normal mode: When typing commands. For Visual mode: When typing commands while the Visual area is highlighted. For Select mode: like Visual mode but typing text replaces the selection. For Operator-pending mode: When an operator is pending (after “d”, “y”, “c”, etc.). See below: |omap-info|. For Insert mode. These are also used in Replace mode. For Command-line mode: When entering a “:” or “/“ command. 其中用的比较多的是 Normal, Insert, Command-line 这三种，这篇文章中主 要讲解的也是这几种模式的快捷键配置。这几种按键绑定模式的用法如下： inoremap jk &lt;Esc&gt; nnoremap &lt;space&gt; : cnoremap &lt;C-a&gt; &lt;Home&gt; 这些绑定最前面的字符 [inc] 表示不同的模式。如果你没有指明你使用的是哪一种 模式，比如你直接使用 noremap &lt;space&gt; : 那么它表示同时绑定到 normal, visual, operator-pending 三种模式。 常用的快捷键绑定避免输入 Esc在 ADM-3A 中 Esc 这个按键在目前的 Tab 键的位置，输入起来非常方便，但 是现在的键盘中这个按键输入起来非常的不方便，为了避免把手指移动到左上角，你 可以使用下面几种方式。 在你的系统中 Caps Lock 映射到 Esc 中。这个方式我不是很推荐，因为我 更喜欢把 Caps Lock 映射到 Ctrl 按键。 在输入普通模式命令之前先输入 Alt，因为大部分的终端编辑器会在输入 Alt 之后产生一个 Esc 按键，所以你输入 Alt-o 就可以直接在输入模式 中在当前行下面新建一行开始编辑。 绑定其他按键到 Esc 上，比如我把 jk 绑定为 Esc。 inoremap jk 经过这个绑定，我可以直接在 insert mode 下输入 jk 退出编辑模式。 替换 :Vim 的命令输入快捷键 : 需要输入两个字符（你需要先按住 SHIFT），对于一 个常用的快捷键来说，速度太慢了一点。我习惯把 绑定为 : 这样，我可 以直接输入空格进入命令模式。 noremap &lt;space&gt; : 快速切换到行首行尾Vim 切换到行首和行尾的快捷键分别是 ^ 和 $，这两个字符在正则表达式中 也代表着同样的含义。这两个按键虽然比较容易记住（只要你了解一些基本的正则 表达式知识），但是它们比较难以输入，为了能够快速的切换到行首行尾，我给这 两个功能绑定了新的快捷键。 noremap H ^ noremap L $ 使用大写的 H 切换到行尾，小写的 L 切换到行末。这两个按键原本绑定为快速 切换到页首和页尾，不过这两个功能我不是用的很多所以我把它们重新绑定到了行首 和行尾上面。 此外要提醒的一点是你可以使用 0 这个快捷键把切换到行首，还有就是如果你只 是想要在行首和行尾插入字符，直接使用 I 和 A 就可以完成任务，没有必要使 用这两个快捷键定位到行首尾之后再进行插入操作。 大小写转换我在系统设置中把 Caps Lock 按键映射到了 Ctrl 按键上，也就是说我的键盘 上目前没有大小写转换功能。在日常编程中，有些时候我们还是需要输入比较多的大 写字符，比如在 C 语言的宏定义大部分都使用大写字符。 在 Vim 中我比较常用的做法是先输入小写字符然后通过 gUw 按键转换成大小字 符。个人觉得 Vim 的大小写切换功能的快捷键绑定的不是特别直观。它使用 gu 表示转换成小写，gU 表示转换成大写；这和一般的 u 表示大写 l 表示小写 比起来直观性上相差较远且更不容易操作（gUw 其实要按四个按键）。我把大小写切 换功能的快捷键做了重新绑定。 nnoremap gu gU nnoremap gl gu 这样你可以使用 guw 把当前的单词转换成大写，glw 把这个单词转换成小写。 更便捷的文字输入Vim 的大部分的快捷键是使用可输入字符序列组成的，比如 hjkl 用来移动光标 。这种方式的一个好处是快捷键可以非常方便的输入，因为这些字符大部分都位于键 盘的核心输入区域。 这种方式最大的问题在于这些快捷键是可输入的字符，我们无法在把它们作为快捷键 的同时又把它们输入到文本中去。这个问题的解决方式有两种，第一是使用不同的模 式处理文本，比如 Vim 在普通模式下这些字符被映射成为快捷键而在输入模式下 这些快捷键失效变成可输入字符。第二种解决方案就是使用组合键，比如 Emacs 使用 C-f，C-b 移动光标，因为组合键不是可输入的字符，前面提到的问题也就 不存在了。 Vim 的方式让快捷键变得更加的便捷，但是你需要不停的切换模式。比如我想要在 编辑模式下移动光标的位置，我只能使用角落里的方向键或者更传统的做法，切换回 到普通模式移动光标到合适的位置再进入编辑模式开始编辑。 这是一种不太方便的操作方式，为了可以在编辑状态快速的移动鼠标，我借鉴了 Emacs 的做法，定义一些组合键来完成这些事情从而避免不断的切换模式。 inoremap &lt;C-k&gt; &lt;Up&gt; inoremap &lt;C-j&gt; &lt;Down&gt; inoremap &lt;C-a&gt; &lt;Home&gt; inoremap &lt;C-e&gt; &lt;End&gt; 这里定义了 C-[kj] 而没有 C-[hl] 因为 C-k 在输入模式下原本绑定为输 入一些特殊的字符，而 C-j 原本是插入新行。这两个功能我用的不是多，前者使 用本身就少，后者可以用 A-o 和 Enter 来实现。 相对来说，C-h 的删除功能我用的较多，而 C-l 这个键和很多插件都有定义到 ，所以我没有绑定，如果你找到了更好的解决方式千万记得告诉我。 更便捷的命令输入和前面提到的一点类似，命令行的输入我同样绑定了一些快捷键，方便快速的输入命 令行。 cnoremap &lt;C-j&gt; &lt;t_kd&gt; cnoremap &lt;C-k&gt; &lt;t_ku&gt; cnoremap &lt;C-a&gt; &lt;Home&gt; cnoremap &lt;C-e&gt; &lt;End&gt; 上面这个绑定，使用 C-j 切换到下一条命令，使用 C-k 切换到上一条命令。使 用 C-a 切换到命令行首，C-e 切换到命令行尾就像普通的 shell 一样。 超级用户权限编辑Vim 在编辑系统配置文件时经常会使用到，你也许也碰到过对一个文件编辑完成之 后才发现自己没有权限写这个文件。这个时候你只能使用 q! 丢弃编辑内容然后重 新以 sudo 权限编辑文件。 幸运的是，就连这么蛋疼的问题，Vim 也有解决的办法，你可以使用如下命令： w !sudo tee &gt;/dev/null % 我个人不是特别了解这个命令的具体工作原理，但是它确实有用。为了避免输入这么 一大段的命令，我把它绑定到了 sw 这个命令上 cmap sw w !sudo tee &gt;/dev/null % sw 原本是 swap 文件的写操作快捷键，不过因为我不是 swap 文件，所以我 把它重新绑定到前面这个快捷命令上去。 mapleader关于 Vim 快捷键配置最后一个需要解释的概念是 mapleader，这是一个特殊的 字符，默认是 \。 Vim 的大部分的快捷键都是可输入的字符序列，但是可输入的字符本身就不多，而 且 Vim 已经占用了很多。这就导致在单层空间里面能够提供给我们使用的字符严 重不足，我们绑定的快捷键很有可能和原本的快捷键产生冲突而覆盖它们的快捷键最 终导致快捷键失效，Vim 的各种插件绑定的快捷键让这种情况更加严重。为了解决 这种单层空间的快捷键冲突，你可以使用 mapleader 增加名字空间来解决这种冲 突，比如： map &lt;Leader&gt;j &lt;Plug&gt;(easymotion-j) map &lt;Leader&gt;k &lt;Plug&gt;(easymotion-k) 在 &lt;leader&gt; 这层空间中，把 jk 绑定为 easymotion 相关的插件，从而避免 和原本的 jk 快捷键产生冲突。通过这样的绑定之后你可以通过 \j 来触发 easymotion 相关的功能。 当然在目前的键盘中 \ 键比较偏僻，而 mapleader 在快捷键绑定用的很多，所 以我把这个按键做了更改，把它改成触手可及（原谅我的词语滥用）的 ; let mapleader=&quot;;&quot; 此外你不可以使用 &lt;leader&gt;&lt;leader&gt;或者 &lt;leader&gt;&lt;leader&gt;&lt;leader&gt;... 形成更深层次的空间，不过这给记忆带来太大的难度，不推荐使用。 通过前面的这些例子你大概已经知道了如何去绑定自己喜欢的快捷键了，Vim 的可 配置性太高，我不可能在这里写下所有的快捷键配置，如果你觉得自己的快捷键用的 不顺手或者说你想要寻求新的快捷键功能，尽管定义自己喜欢的快捷键就好了。 下一篇文章将会重点介绍 Vim 的杀手级功能 —— 插件。]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器系列之 —— 编辑利器 Vim 之基础配置]]></title>
    <url>%2F2015%2F08%2F31%2Fvim-basic%2F</url>
    <content type="text"><![CDATA[Vim 党和 emacs 党之间有一场旷日持久的战争，他们都号称自己使用的编辑 器是最好用的编辑器，这是一场编辑器之神和神之编辑器的战争，从来都分 不清胜负。 我是一个从 Emacs 阵营转移到 Vim 阵营的人，当年放弃 Emacs 只是因为想 要学习 Vim，然后就没有然后了。Emacs 是一个非常优秀编辑器，只是我现 在使用的是 Vim，而我目前没有遇到想要放弃它的痛点。 Vim 的功能非常强大，不过没有配置过的 Vim 像是一把没有用过的宝刀 —— 锋利但不顺手。这个系列的文章目的是让 Vim 顺手起来，让它使用起来至少 不会那么别扭，让你有坚持使用它的冲动。 Vim 是一个可高度配置的编辑器，我无法在一篇文章中把他讲透侧说清楚。 所以这个工具分成三个部分介绍： Vim 常用选项配置 Vim 快捷键配置 Vim 插件配置 这篇文章是 Vim 系列的第一篇文章，主要介绍 Vim 在日常编程中常用的一 些选项设置。文中完整的配置文件你可以在我的代码仓库中找。 如何配置你的 Vim要修改 Vim 的各种配置通常有两种方式，第一种方式是输入: 然后在命 令行模式下输入配置命令，比如 set number，这种方式改变的配置会在 Vim 退出之后失效；第二种方式是在你的配置文件中加入你的配置命令，比 如在 ~/.vimrc 中加入 set number，这种方式改变的配置会一直有效， 因为 Vim 启动的时候会先读取配置文件。 非兼容模式这几乎是所有的 Vim 配置文件的第一个配置，因为 Vim 是基于 VI 的，为 了兼容 VI，Vim 默认使用了兼容模式。然而 VI 毕竟是上个世纪的产物，它 有很多地方显得非常的诡异，比如你无法使用 backspace 删除、使用 c 指令替换掉的内容在退出 insert mode 之前会残留在屏幕上等等。 Vim 是 VI Improved 的意思，为了能够使用这些 Improved 的部分，我们 需要使用非兼容模式。你只需要在你的配置文件中加入 set nocompatible 行号Vim 默认不显示行号，如果你需要显示行号可以在你的配置文件中加入 set number 当然你也可以设置不显示行号，因为理论上你打开的特性越多，你的 Vim 就 越慢，你可以通过下面的配置来关闭行号的显示。 set nonumber 不过行号在调试程序的时候还是非常有用的，因为你的编译器通常会告诉你 问题出在哪一行。我比较喜欢的做法是默认关闭行号，在需要用到的时候输 入 set number 指令打开行号，为了简化这个过程，我把 F2 绑定为行号 的开关按键，方法如下： nnoremap &lt;F2&gt; :set number!&lt;CR&gt; 语法高亮语法高亮可以说是一个必不可少的功能，一方面它可以增加程序的美感，另 一方面它可以帮助减少程序中的 typo，比如关键字如果写错了，一目了然， 因为它不会被高亮。打开语法高亮： syntax on 同样绑定 F3 作为语法高亮的开关： nnoremap &lt;F3&gt; :exec exists(&apos;syntax_on&apos;) ? &apos;syn off&apos; : &apos;syn on&apos;&lt;CR&gt; TAB 宽度设置TAB 缩进在任何一门语言的 coding style 中都会被反复的提及，而不同 的规范也会有不同的缩进要求。通常来说，编写程序的时候我们习惯使用 TAB 进行缩进，不过不同的环境下一个 TAB 会被显示成不同的宽度，我 们经常会遇到一个源文件在你的电脑上显示的非常漂亮，到了其他地方就显 示的非常诡异，这也是我们需要进行配置的原因。 在 Vim 中完整的配置 TAB 宽度涉及到四个参数的设置：tabstop、 softtabstop、shiftwidth、expandtab。而它们的设置取决于你想要如何使 用 TAB。 保留 \t 字符缩进如果你需要在你的文件中保留 \t 字符，你只需要设置 tabstop 和 shiftwidth。 set tabstop=4 set shiftwidth=4 以上设置会保留你的 \t 字符，并把它显示成四个空格。这种做法并不是很推荐， \t 的宽度在其他软件中很可能是不一样的，比如：cat 中显示 8 个空格， 在视觉上和你在 Vim 显示的有很大的差别。这也是为什么很多人不提倡使用 \t 作为缩进的原因。 把 \t 转换成空格大部分的编码规范中提倡使用空格作为缩进，但是空格输入起来非常的麻烦 ，所以我们通常还是使用 TAB 来进行缩进，然后把 \t 字符转换成空格 。 Vim 中提供了把 \t 转换成空格的功能： set expandtab 而你需要把一个 \t 字符转换成多少个空格可以通过 softtabstop 这个参 数来设置。比如： set softtabstop=4 让一个 \t 字符转换成 4 个空格。 和缩进相关的另一个值是 shiftwidth，它表示一次 shift 缩进（比如 &gt; 向右 shift）的空格数，最常见的做法也是把它设置成和 softtabstop 一 样的值。 set shiftwidth=4 因为我们把 \t 转换成空格，所以你可以选择不设置 tabstop 的值。 代码自动缩进设置Vim 的缩进并不强大而且很容易让人迷惑，你想要用它来完成代码的格式化 工作其实比较困难，因此这里不会重点介绍它的设置。后续的文章中会介绍 如何使用 astyle 在 Vim 完成代码的缩进。 Vim 的代码缩进设置和它的 TAB 宽度设置一样让人迷惑，因为它包含了太多 的选项。和缩进相关的选项主要是：autoindent, smartindent, cindent。 这里不想去介绍这几个选项之间的区别以及如何设置它们，因为没有一种设 置是适合所有的文件类型的。最合适的做法是根据不同的文件类型设置不同 的 indent。 Vim 给我们提供了这个功能，你需要做的只是在你的 ~/.vimrc 中加入： filetype plugin indent on 如此一来 Vim 会自动为了探测文件的类型从而应用不同的 indent 设置。这 些默认的设置一般位于 /usr/share/vim/vim74/indent 目录下面，理论上 你只有在对这些默认的设置不满意的时候才需要去设置 smartindent， cindent 等信息。 我通常使用 Vim 做 c、c++ 的开发，Vim 会自动的识别出文件类型并且设置 indent 为 cindent。和 cindent 相关的一个参数有 cinoptions、cinwords 、cinkeys 等等，你可以在你的配置文件中设置这些值来改变缩进的行为。 不过我通常不会这么做，因为它能够设置的东西太少，我更倾向于使用 astyle 结合插件来完成我想要的各种格式化和缩进设置。 80 字符限制源文件不超过 80 个字符几乎在任何一个编码规范中都有提及，如果使用过 像 Tmux 这样的分屏工具，你会发现这一点非常有意义，因为你通常需要在 半屏查看源码。如果你的代码超过半屏，换行之后的显示非常难看。在 Vim 中我们可以在 80 个字符的位置显示一条竖线来警示我们写代码不要超过 80 个字符： set colorcolumn=81 此外，你可以使用 Vim 的另一个选项 textwidth，让它在超过 80 个字符 的时候自动换行，方法如下: set textwidth=80 这些设置是对于英文设定的，如果你需要使中文也能如此，你需要加入如下 的配置： set fo+=mB 其中 m 表示允许在两个汉字中间换行，而 B 表示将两行合为一行的时 候不要在两个汉字之间加入空格。 和宽度有关的另一个设置是 wrap。如果你的终端尺寸太小，在 Vim 的一 行很可能超过了终端的宽度，Vim 在这种情况下会把这一行在自动换行显示 ，很多时候这会让你的代码乱成一团，尤其是在你没有遵守上面的 80 个字 节限制的时候更是如此。如果你想要关闭 Vim 的自动换行显示，你可以进行 如下设置： set nowrap 我习惯为这个功能做一个按键绑定： nnoremap &lt;F4&gt; :set wrap!&lt;CR&gt; 搜索搜索相关的两个常用设置是 ic 忽略大小写，hlsearch 高亮搜索 set ic set hlsearch nnoremap &lt;F5&gt; :set hlsearch!&lt;CR&gt; 同样绑定 来切换这个功能 文件编码格式如果你不用考虑跨平台的问题，那么文件编码其实不是什么大问题，但是如 果你需要在不同的平台下编辑文件，那么你最好设置好合适的文件编码格式 ，否则你很可能会遇到一个文件在 windows 上显示正常在其 Linux 上就出 现乱码的问题。 在 Vim 中设置文件的默认编码的参数是 encoding，比较常用的做法是设 置成通用的 utf-8 格式，如下： set encoding=utf-8 当然，如果你打开一个别人提供的文件，那么很有可能它使用的编码不是 utf-8，因为文件不是由你编辑，你无法指定它的编码格式。Vim 默认的会按 照 fileencodings 选项中列出的编码格式依次探测文件的格式。所以你可以 把这个选项设置成常用的格式列表： set fileencodings=utf-8,ucs-bom,GB2312,big5 当然如果你经常遇到乱码问题，你可以考虑使用 fencview.vim 插件，它 使用词汇频率统计的方式来猜测编码，成功率据说比较高。 其他常用选项还有一些常用的选项，有兴趣的也可以试一试。 &quot; 高亮当前行 set cursorline &quot; 智能补全命令行 set wildmenu &quot; 不使用代码折叠功能 set nofoldenable &quot; 不使用 swapfile set noswapfile 第一个设置可以高亮你的当前行，这样至少你不至于在神游回来之后找不到你的光标 所在位置。第二个设置可以让你在命令模式下把可用的补全列出来非常直观，对于命 令的输入还是有非常大的帮助的。第三个这是完全是个人喜好，因为有了个人很少用 到代码的折叠。最后一个选项是关于 swap 文件，Vim 默认的开启 swap 文件， 它会使得 Vim 在编辑一个文件的时候首先把文件拷贝成一个临时的 swap 文件， 只有你使用 :w 保存之后才写入源文件中。Vim 在打开一个文件之前会先查看是否 存在这个文件，如果存在会有类似于 swap file already exists 这样的提示信息 ，比如你同时开两个 Vim 进程编辑同一个文件就会出现前面这种情况， noswapfile 这个选项就是用来禁用 swap 文件。 有了基础的配置之后其实我们已经可以开始比较顺畅的使用 Vim 进行日常的 编辑了。下一篇文章中我会重点介绍 Vim 的快捷键设置，让你的在 Vim 中 感受飞一般的感觉。]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器系列之 —— 分屏利器 Tmux]]></title>
    <url>%2F2015%2F08%2F15%2Ftmux-tutorial%2F</url>
    <content type="text"><![CDATA[这篇文章中的 .tmux.conf 配置文件你可以在我的代码仓库中找到 为什么使用分屏工具在 C、C++ 开发过程中分屏是一项非常提高效率的功能，因为我们时常需要一边写代码 一边编译、测试。在脱离 IDE 的时代，通常我们需要开多个终端：一个终端编辑文件、 一个终端编译运行程序、一个终端查看相关的 man 文档…。多个终端管理起来其实是 非常不便的，因为你需要不停的在各个终端之间切换。终端分屏工具是解决这个问题 的绝佳办法，它可以把一个终端分成多个窗口，把所有需要做的事情放到一个终端里面， 让你不用再耗费大量的时间在不同的窗口之间切换。 为什么使用 Tmux分屏工具主要分成两类，其中第一类是自带分屏功能的终端模拟器：在 Ubuntu 下面有一个 终端模拟器 Terminator 自身就支持分屏，Deepin Linux 的深度终端也支持同样的功能。 但是这些终端模拟器的分屏功能可配置性太差，你没有太多的选择。他们最大的硬伤在于 你只能使用他们的终端，所以你得忍受这些终端模拟器的蹩脚的地方，比如深度终端卡到 爆的体验。此外如果你没有安装 X11 图形界面系统，你没有办法使用这些终端模拟器。 第二类是终端分屏软件，它不依赖于终端模拟器本身，可以在任何你喜欢的终端模拟器上 运行，这一类的软件中比较有名的包括：GNU Screen 以及 Tmux。 前者的历史非常的悠久比较稳定，以 GPL 协议发布。Tmux 是 2009 年才出现的产品， 以 BSD 协议发布。很多人戏称 Tmux 为 Screen 的 BSD 版本重写，因为它包含了 Screen 大部分的功能。从个人体验来说，Tmux 相对来说比 Screen 容易使用一些 （我试过使用Screen，但是由于太笨，怎么用都不顺手）所以这里只介绍 Tmux 的使用。 Tmux 能做什么Tmux 的功能非常非常的强大，使用它你可以： 在终端模拟器中虚拟出多个窗口 把一个窗口分成多个区域（panel）。 快速在各个区域中进行复制黏贴操作。 配置你喜欢的快捷键。 使用脚本控制 Tmux。 实现结对编程。 ….. 本文只是简单的介绍 Tmux 基础配置以及它的分屏和复制功能，其他的功能大家可以参考 《tmux: Productive Mouse-Free Development》一书。这本书非常的薄，值得通读。 Tmux 基本概念为了方便理解 Tmux 的使用，这里先介绍两个相关的概念。 窗口（windows）在没有 Tmux 这样的工具之前，如果我们需要在终端同时完成多项任务，比如同时听歌、 收邮件、查看文档、编辑代码，我们可能会需要开多个终端模拟器窗口来解决这个问题。 （如果连终端模拟器都没有，那估计就只能在不同的 tty 中不断的切换） Tmux 强大之处在于，它可以让你在一个终端模拟器窗口中完成原本需要多个终端模拟器 窗口来完成的事情。它的做法是在一个终端模拟器窗口中虚拟出多个窗口，让你在不同 的虚拟窗口中完成不同的工作，并能够非常方便的在各个窗口之间进行切换。 下面是一张 Tmux 多窗口运行界面图： 在上图中，我开了三个窗口，一个用来运行 VIM 编辑博客，一个用来查看 man 文档， 另一个运行 top 命令查看进程运行状况，而这些统统在 Tmux 的一个 session 中完成 （其实 Tmux 还可以运行多个 session，不过个人觉得用处不是特别大，有兴趣的可以 参考《tmux: Productive Mouse-Free Development》一书）。 面板大部分情况下我们会把不同的任务分派到不同的窗口中去。但是很多时候即使是一个任务 你也没有办法在单个窗口在很好的完成它。比如 coding 这项任务，你可能需要一边写代码 ，一边用 gdb 调试。又如 Git 提交这项任务，在进行 git add 提交之前我们通常是需要 知道哪些文件有改动，这个时候我通常会调用 git status 命令查看工作目录的状态， 调用 git diff 查看改动的地方。 通常我会一边参考 git status 的输出，一边查看 git diff 的输出，一边进行 git add 操作。我并不希望把这些操作分散到不同的窗口中去，因为我只是在完成一项 任务。解决这种问题可以使用 Tmux 的面板（panel），它把一个虚拟窗口分成多个可独立 操作的区域，让你在不同的区域之间协调工作完成同一项任务，如下图。 上面这两个功能是我在日常开发过程中用得最多的功能，所以下面主要讲这两个功能的一些 配置。其实 GNU Screen 也同样有前面提到的这些功能，Tmux 的优势在于它的易用和容易 配置上面。 Tmux 配置准备工作在进行真正的配置之前，你需要： 安装 Tmux （以 debian 系列为例）sudo apt-get install tmux 创建配置文件touch ~/.tmux.conf 去掉大写键大写键是一个历史遗留按键，它霸占了黄金位置，却很少使用。一种比较流行的做法是把 它替换成 Ctrl 键，或者和 Ctrl 键互换。在 EmacsWiki 中有一篇文章专门介绍各个 平台如何重新绑定这个键。 我比较习惯的做法是直接把 Caps Lock 按键替换成 Ctrl。方法很简单，在你的 .bashrc 或者 .zshrc 中加入： setxkbmap -option ctrl:nocaps 有了这个黄金位置，许多命令输入起来会简单很多，比如输入 shell 命令时用常用的 C-r、C-a、C-e，切换 VIM buffer 常用的 C-w C-w 等等。 如果你需要输入长串的大写字符，在 VIM 中你可以先输入小写然后输入 gUw 转为 大写，在 shell 命令行中可以使用 A-u 把输入的单词变成大写。 绑定快捷键前缀修改快捷键前缀是配置 Tmux 的第一步，因为 Tmux 中几乎所有的按键都是组合键，但是它 默认的前缀 C-b 输入起来有点吃力。许多人建议把它绑定到 GNU Screen 的 C-a 上去， 不过 C-a 在 shell 命令输入中是一个常用的快捷键（比如编辑一个问题突然发现没有 权限，可以通过 C-a 跳到命令行首加上 sudo 再执行），所以我把它绑定到了 C-f，因为 修改过大写键之后，这两个键输入起来是非常顺畅的。 修改前缀的方法非常简单，你只需要在 ~/.tmux.conf 中添加： set -g prefix C-f unbind C-b 当然无论你使用哪一个前缀你都有可能和其他的软件相冲突，比如 C-a 在 shell 中使用 较多，C-f 在 VIM 中也是一个快捷键。Tmux 为了解决这个问题提供了一个功能叫做 sendkey，就是绑定另外一个快捷键，输入这个快捷键可以把 PREFIX 键发送到其他的程序。 我把这个快捷键设置成了 PREFIX-PREFIX。也就是说连续按两遍 C-f 可以发送一个 C-f 按键。设置方法是在 ~/.tmux.conf 中加入： bind C-f send-prefix 注意，在 Tmux 配置中 bind 后面只需要写 PREFIX 后面的部分，所以 bind C-f 其实最终 是设置了 PREFIX-C-f） 当然这种方式并不算非常完美，因为你不得不输入两次 PREFIX，不过这个 tradeoff 我 觉得是值得的。 窗口（windows）的操作配置Tmux 的窗口操作快捷键设置的是比较合理的，并不需要额外的配置，你需要做的只是记住 它的快捷键： PREFIX-c : 创建新的窗口（create） EXIT,C-d : 关闭窗口，Tmux 中的窗口和终端模拟器中的窗口一样可以通过 exit、C-d 来关闭。 PREFIX-n : 切换到下一个窗口（next） PREFIX-p : 切换到前一个窗口（previous） PREFIX-w : 列出所有的窗口，以供快速切换 Tmux 创建的窗口默认是从 0 开始编号的，如果你希望从 1 开始编号可以在配置文件中 加入： set -g base-index 1 面板（panel）的操作配置个人感觉 Tmux 本身的 panel 快捷键配置是不太合理的，所以我修改了大部分的 panel 操作快捷键。这一小节分三个部分讲解 Tmux 的面板操作 —— 也就是传说中的分屏操作。 分屏Tmux 支持水平分屏和垂直分屏，但是 Tmux 默认的快捷键很难输入。默认垂直分屏是 C-&quot; 而默认水平分屏是 C-%。我习惯的做法是使用最直观的 - 表示水平分屏， | 表示垂直分屏，不过因为 | 和 \ 一般在同一个按键上而后者不需要按住 SHIFT 来转换，所以我一般直接把 \ 绑定为垂直分屏。 在你的 ~/.tmux.conf 文件中加入： unbind &apos;&quot;&apos; bind - splitw -v unbind % bind \ splitw -h 现在你可以使用 PREFIX--（按下 PREFIX 组合键之后按下 - 键）来进行水平分屏， 使用 PREFIX-\ 来进行垂直分屏。 和窗口一样，Tmux 分出来的 panel 默认是从 0 开始编号，你可以通过在配置文件中 加入： set -g pane-base-index 1 使编号从 1 开始。 切换面板分屏之后最重要的一个操作应该是在不同的 panel 之间切换，我是一个 VIM 重度患者， 所以习惯把涉及到方位操作的所有按键绑定到 hjkl 上面去。 我的配置如下： bind-key h select-pane -L bind-key j select-pane -D bind-key k select-pane -U bind-key l select-pane -R 使用 PREFIX-[hjkl] 就可以轻松的切换到不同方向的小窗口中去。 Tmux 还可以通过 PREFIX-q 在所有的面板上显示一个编号，输入这个编号可以直接 跳转到这个这个面板上去。 修改当前面板的大小Tmux 的默认分屏是对半分，不过更多的时候我们需要的是一个较大的主窗口和几个 小一点辅助窗口。比如一个大的 VIM 窗口编辑源代码，一个小的窗口用来编译源码。 修改完源码之后可以立即切换到小窗口进行编译是一件很幸福的事情。Tmux 提供了 改变 panel 大小的功能，我依旧把它绑定到 hjkl 四个按键上，只不过这一次使用的是 C-[hjkl]，也就是说最终可以通过 PREFIX-C-[hjkl] 来改变当前窗口的大小，配置如下 bind -r ^k resizep -U 5 bind -r ^j resizep -D 5 bind -r ^h resizep -L 5 bind -r ^l resizep -R 5 如果你是两个垂直并列的 panel，可以使用 PREFIX-C-[hl] 来调整它们的大小， 如果你是两个水平并列的 panel，可以使用 PREFIX-C-[jk] 来调整它们的大小。 你可以通过把上面的 5 改成你想要的值来调整单次 resize 的粒度。 此外如果你想要暂时把其中一个 panel 最大化，你可以使用 PREFIX-z Tmux 还为 panel 提供了几种默认的布局，你可以通过 PREFIX-space 来切换这些 布局。 复制黏贴的操作前面几个小节系统的介绍了窗口和面板的使用，下面重点介绍一些 Tmux 的拷贝模式 （copy-mode）。 我们经常需要在一个窗口（或者 panel）中复制代码黏贴到另一个窗口（或者 panel）中 （虽然这不是一个很好的习惯）。Tmux 提供了强大的的复制黏贴功能来帮助我们完成 这一任务。 在 Tmux 中复制是在拷贝模式下完成（copy-mode），进入拷贝模式的默认快捷键是 PREFIX-[，不过我习惯把它绑定到 PREFIX-C-v 上面去 bind ^v copy-mode 进入了拷贝模式之后可以使用 hjkl 移动光标到你想要拷贝的地方。找到需要复制的部分 之后按空格键开始复制，使用 hjkl 选择复制的区域，最终按回车完成复制退出拷贝模式。 同样这些按键，你也可以自己绑定快捷键。我习惯了 VIM 的复制黏贴，所以我把 v 绑定 为拷贝模式下复制的开始（默认是 SPACE），y 绑定为复制结束（默认是 ENTER）。 bind -t vi-copy v begin-selection bind -t vi-copy y copy-selection 复制完成之后你可以切换到你想要的黏贴的窗口，输入 PREFIX-] 完成黏贴操作，当然 这个按键你同样可以绑定，比如我把它绑定到 PREFIX-C-p 上面。 bind ^p pasteb Tmux 使用中的其他问题去掉鼠标Tmux 的一个口号是 mouse free，有了它之后你可以抛弃鼠标，如果你想要禁用鼠标 设置，你可以在你的 ~/.tmux.conf 文件中加入： set -g mode-mouse off 颜色问题Tmux 在很多终端下使用的时候会出现颜色错乱的问题，为了解决这个问题你需要设置 TERM 环境变量，最简单的做法是给 tmux 起一个别名，如下： alias tmux=&apos;TERM=xterm-256color tmux&apos; 把上面这句写到你的 .bashrc 或者 .zshrc 中即可。 Tmux 网上有很多相关的资料可以参考，最全面的资料应该是 《tmux: Productive Mouse-Free Development》一书，强烈推荐有兴趣了解 Tmux 的 人看一看这本书。聪明的你一定很容易找到这本书。]]></content>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 jekyll 中文换行变成空格的问题]]></title>
    <url>%2F2015%2F04%2F25%2Fhow-to-fix-the-markdown-newline-blank-problem%2F</url>
    <content type="text"><![CDATA[2015-4-27 更新查看 Liquid 文档发现它有一个默认过滤器 join，这和本文编写的过滤器插件名字有冲突 所以把插件中的 join 更名为 join_chinese。误导之处，海涵。 问题使用 github pages 搭建一个免费的个人博客是一项非常流行的技术，它有着安全， 免费，无流量限制等特点。 github pages 中的文章一般是使用 Markdown 编写的，github pages 会使用 jekyll 把 Markdown 编写的文章转换成 html 文档从而形成一个静态的博客网站。 在我正儿八经的用 markdown 写完一篇文章之前一切都很完美，但是当我开始打开 浏览器查看自己写的文章的时候，却发现了一个非常蛋疼的问题——文章的段落中间总是会 不时出现多余的空格，如下图： 这个问题的出现其实并不是 github pages 的引起的，它是由 Markdown 和 HTML 共同造成的。 markdown 保留段落中的换行符在把 .md 文档装换成 .html 文档的过程中，Markdown 会保留段落中间的换行符。 为了说明这一点，我们建立下面这个测试文档 test.md 这是同一个段落的第一行 这是同一个段落的第二行 使用markdown命令把它转换成html文档 markdown test.md &gt; test.html 最终得到的 test.html 的内容如下： &lt;p&gt;这是同一个段落的第一行 这是同一个段落的第二行&lt;/p&gt; 如果你用 cat -E test.html 命令查看该文档，会得到以下结果，其中的 $ 符号 表示换行。 &lt;p&gt;这是同一个段落的第一段$ 这是同一个段落的第二段&lt;/p&gt;$ HTML 会把换行符转换成空格浏览器在显示最终的 .html 文档的时候会把换行显示成空格，这是一个历史遗留问题。 因为 HTML 的语言规范中就是这么规定的。 An HTML user agent should treat end of line in any of its variations as a word space in all contexts except preformatted text 之所以这么规定是因为对于英文来说这是非常重要的一点。比如： &lt;p&gt; This is a same paragraph&lt;/p&gt; 最终的显示效果是 This is a same paragraph 在英文单词中间加入空格是必须的，因为单词需要通过空格来分界。然而在中文中间加入 空格却是一件非常别扭的事情。他将会导致 &lt;p&gt; 这是同一个 段落&lt;/p&gt; 被显示成 这是同一个 段落 这也就是你在 github pages 中用 Markdown 写的文章最终显示在浏览器上的时候 段落中间会时不时的出现空格的原因——Markdown保留换行符而 HTML 把换行转换成 空白符。 如何解决这个问题从上面的分析来看，解决这个问题可以四种思路： 在编写 .md 文档的时候不要换行，也就是说一个段落只写一行。这样一来就不会有 换行符的存在，问题也就不会出现。当然这种方式太过于笨拙，相信不会有人想要 使用它，因为 Markdown 设计的理念就是让你的文档易读，易写，这种方式和 Markdown 理念背道而驰。 这种方式的另外一个缺陷就是如果你使用的编辑器本身会在超过一定长度的时候自动 换行的话，而你又没有办法更改设置的话，你很难做到不换行。 修改 Markdown 实现，让它在生成 HTML 的时候去掉段落中间的换行。但是这个 难度太大，而且如果有 Markdown 更新的话，你就得重新修改，很不方便。 第三种解决方案是在浏览器中进行处理。也就是让浏览器不要把换行转换成空白符， 可选的方式是在 &lt;html&gt; 标签中加入 lang 属性 &lt;html lang=zh&gt;。另外一种 方式是通过设置 CSS3 的 text-spacing 属性，none 表示不用转换。 但是这两种方式都不一定有效。因为可能有浏览器不支持,而且 lang 属性的设置 可能会影响默认字体的选择，最终甚至会增加空白字符，因为如果默认字体中的空白 字符可能很宽[^1]。 我试过给 &lt;html&gt; 添加 lang 属性，但是并没有解决问题。 最后一个思路是在 Markdown 转换过后的 HTML 文件上做文章，把多余的换行符 清除掉。这也是这篇文章中主要想要介绍的方式。 解决方案github pages 使用 jekyll 来生成 html 文档，所以最好的方式是直接从 jekyll 入手解决问题。[解决 Markdown 转 HTML 中文换行变空格的问题][refblog] 一文中提到可以直接修改，jekyll 的 markdown 转换器，这种方式连作者自己都 不推荐。该文中还提到了另一种方式就是使用 jekyll 的 plugin 机制，这也是 这篇文章中要介绍的方式。可惜的是这篇文章中提到的 post_filter.rb 插件目前已经 不存在了，所以文章介绍的方式无法使用。我们只能自己重新编写插件。 jekyll 的插件分为四种，在[官方文档][jekyll]中有详细的介绍。插件是使用 ruby 语言编写的，我原来没有 ruby 编程经验，所以这里写的插件可能不太规范。关于如何 编写插件可以参考[Getting Started with Jekyll Plugins][plugin_how_to]一文。 我们需要使用到的插件类型是 Liquid filters，它的基本框架如下： 12345678module Jekyll module JoinChineseFilter def join_chinese(htmltxt) end endendLiquid::Template.register_filter(Jekyll::JoinChineseFilter) 这样我们可以通过 content 获得 html 文本后使用 pipeline 传递给我们编写的 join_chinese 进行处理（去掉多余的换行）, `{{content | join_chinese}}` join_chinese 最简单的实现方式可能是把所有的 \n 都去掉（如果只是想要简单的 去掉所有的行的话，根本不用使用插件，Liquid 自带的 strip_newlines 过滤器 就可以实现这一点了[^2]） 123def join_chinese(htmltxt) htmltxt.gsub(/\n/, '')end 这样的一个问题就是我们在 &lt;pre&gt;&lt;/pre&gt; 标签中写的 \n 也会变替换掉。最直接的 结果就是你引用的代码将会变得一团糟。 其实我们想要去掉的是文本中的换行符，而不是所有的换行符。但是如何才能得到文本 内容并且去掉换行符呢？我最初想要用正则表达式，但是功力不够没能够得到我想要的 结果。最后找到一个非常有用的东西 nokogiri。 nokogiri 可以把 html 转换成一个结构对象，相当于是 javascript 中的 DOM 对象。有了这个对象之后问题就容易解决的多了。nokogiri 的 API 比较的简单。 它的官方网站上提供了一个简单的[教程][noko_tutorial]。 最终插件代码如下： 123456789101112131415161718192021222324252627282930313233require 'nokogiri'require 'open-uri'module Jekyll module JoinChineseFilter def join_chinese(htmltxt) # 生成结构对象 html_doc = Nokogiri::HTML(htmltxt) # 去掉多余的换行 remove_newline(html_doc.xpath("//body")) html_doc.to_html end private def remove_newline(root) root.children.each do |child| # 跳过 pre 和 code next if child.name == 'pre' next if child.name == 'code' # 如果不是 text 文本节点，递归 if !child.text? remove_newline(child) else # 如果不是空白文本节点，去掉换行符 next if child.blank? child.content = child.text.gsub(/\n/, '') end end end endend 注册插件1Liquid::Template.register_filter(Jekyll::JoinChineseFilter) 把上面这段代码保存为 joinchinese.rb 放在 _plugins 目录下面，在 jekyll serve 启动的时候会自动加载这个插件。然后在我们的 _layout 中的各个 layout 中使用 `{{content | join_chinese}}` 最终便可以得到去掉了冗余的空白符的 html 文件。效果图如下： 最后一个难题问题总算是解决了，很遗憾的是 github pages 中的所有页面都是通过 --safe 选项 生成，所以你没有办法使用插件，也就是说上面的插件没有办法在 github pages 中 使用。 那是不是意味着我们这些努力都白费了呢？当然不是，问题的答案总是伴随着问题一起 诞生的。解决这个问题的方式是你在本地生成页面，然后把生成好的页面 push 到 github 上，同时使用 .nojekyll 文件让 github page 不再调用 jekyll 生成页面。 这种方法主要有两种实现方式，第一种是使用两个不同的 repo 一个放你的源文件 另一个放你生成的页面。第二种是通过一个 gh-pages 的分支来完成这一工作。 第一种方式相对来说简单一些，容易上手，而第二种方式更加优雅一些，不过需要有 一定的 git 基础知识。你可以参考下面这些文章 [使用两个 repo][two_ropo] [使用 gh-pages 分支][two_branch] [^1]: Prevent browser converting ‘\n’ between lines into space (for Chinese characters) [^2]: Liquid for Designers [refblog]: http://chenyufei.info/blog/2011-12-23/fix-chinese-newline-becomes-space-in-browser-problem/ [jekyll]: http://jekyllrb.com/docs/plugins/ [plugin_how_to]: http://tech.pro/tutorial/1299/getting-started-with-jekyll-plugins [noko_tutorial]: www.nokogiri.org [two_branch]: http://ixti.net/software/2013/01/28/using-jekyll-plugins-on-github-pages.html [two_ropo]: http://charliepark.org/jekyll-with-plugins/]]></content>
      <tags>
        <tag>markdown</tag>
        <tag>github pages</tag>
        <tag>jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 C++ 参数使用指针还是引用的总结]]></title>
    <url>%2F2015%2F03%2F28%2Fuse-pointer-or-reference-as-argument%2F</url>
    <content type="text"><![CDATA[问题在 C 语言中，所有的参数传递都是值传递，所以如果你需要在一个函数中改变函数外变量 值，你需要把函数的参数声明为指针（全局变量另当别论）。但是在 C++ 中存在传递引用， 它也可以用来改变变量值。此外引用也同时消除了拷贝对象带来的开销。 既然传递指针和引用都能到达到同样的效果，那么函数声明的时候应该使用引用呢还是 指针呢？ More Effective C++ 一书的总结这本书的第一条就是区分指针和引用。它们两者之间的最大区别是引用必须指向某个对象而 指针可以是NULL，此外引用一旦指定不能更改而指针可以。 这两个区别点导致引用有更加安全和高效的特性，但是指针却有无可比拟的灵活性。大部分 人出于安全性的考虑会推荐使用引用，这其实也是它设计的主要目的，但是如果你想要灵活 的设计，大部分时候你只能选用指针，比如设计模式种的大部分设计都是使用指针而不是使 用引用。引用在参数传递的时候用得多一些，而类内部的组合中可能会使用指针来提高设计 的灵活性（毕竟一旦设定就无法改变对于灵活性来说是个灾难）。 异常安全指针还存在的另一个优势是可以使用它实现 pimpl，这种手法可以达到很好的异常安全 性。引用在交换的时候实际上交换的是引用的内容，所以无法做到这一点。详见《More Exceptional C++》一书的第22条。 网上的讨论这个问题在 stackoverflow 中有非常多的讨论。下面是一些链接： Are there benefits of passing by pointer over passing by reference in C++? Pass by Reference v. Pass by Pointer — Merits? When to pass by reference and when to pass by pointer in C++? Pointers vs References: A Question on Style 网上观点的总结 尽量避免使用指针，可以用引用的时候尽量不要使用指针。 指针参数可以在调用的时候传递 NULL 而引用则不可以。所以如果你的参数是可选的话 选择传递指针。 指针参数在调用的时候会比引用要明显一些： int fun(val); int fuc(&amp;val); 前者比较难以看出是传递引用还是直接传递值，而第二个很明显是传递指针。 如果你需要在函数中重新绑定改变参数，你只能用指针。因为你没有办法重新绑定一个 引用。不过需要这么做的情况好像比较少。 如果你的参数需要传递数组的话，你只能使用指针。 其他情况下尽可能的使用引用。因为引用从语义上来说更直白一些，也更不容易出错。 引用一定是指向一个合法的对象，而指针需要在使用之前检查是否为 NULL 还有一些人觉得参数的传递如果是传递引用的话只使用 const refercence，把引用的 作用限制在避免参数拷贝的开销上。然后把改变变量内容的任务交给指针。这也是一个 非常不错的建议。]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单 C 程序的汇编代码分析]]></title>
    <url>%2F2015%2F03%2F26%2Fanalyse-asm%2F</url>
    <content type="text"><![CDATA[概述一个 C 程序它会编译时候产生什么样的汇编代码？这些汇编代码如何执行？函数的栈是如 何工作的？这里通过一个简单的 C 程序生成的汇编程序来分析上面的这些问题。 一段简单的 c 代码1234567891011121314int g(int x)&#123; return x + 3;&#125;int f(int x)&#123; return g(x);&#125;int main(void)&#123; return f(8) + 1;&#125; 得到的简化的汇编代码g: pushl %ebp movl %esp, %ebp movl 8(%ebp), %eax addl $3, %eax popl %ebp ret f: pushl %ebp movl %esp, %ebp pushl 8(%ebp) call g addl $4, %esp leave ret main: pushl %ebp movl %esp, %ebp pushl $8 call f addl $4, %esp addl $1, %eax leave ret 分析从 16 行的 main 函数开始执行：假设 ebp 目前指向 128, esp 目前指向 128 17 - pushl %ebp 把调用 mian 函数之前的 ebp 压入栈中， +-----+-----+ | 128 | 128 | 操作之前的寄存器 +-----+-----+ ebp esp +-----------+ 128 | ebp 128 | +-----------+ 124 | | +-----------+ 操作之后的栈 +-----+-----+ | 128 | 124 | 操作之后的寄存器 +-----+-----+ ebp esp 18 movl %esp, %ebp 把 esp 的值传递到 ebp 中，这样就形成了 main 函数的栈帧。 +-----+-----+ | 128 | 124 | 操作之前的寄存器 +-----+-----+ ebp esp +-----+-----+ | 124 | 124 | 操作之后的寄存器 +-----+-----+ ebp esp 19 pushl $8 —— 把函数 f 的参数 8 压入栈中 +-----+-----+ | 124 | 120 | 操作之后的寄存器 +-----+-----+ ebp esp +-----------+ 128 | ebp 128 | +-----------+ 124 | 8 | +-----------+ 120 | | +-----------+ 操作之后的栈 20 call f —— 调用函数 f +-----+-----+----+ | 128 | 124 | 21 | 操作之前的寄存器 +-----+-----+----+ ebp esp eip +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | | +-----------+ 操作之后的栈 +-----+-----+---+ | 124 | 116 | 9 | 操作之后的寄存器 +-----+-----+---+ ebp esp eip 9 pushl %ebp —— 保存 main 函数的栈基地址，和执行位置 eip 以便恢复 +-----+-----+ | 124 | 116 | 操作之前的寄存器 +-----+-----+ ebp esp +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | ebp 124 | +-----------+ 112 | | +-----------+ 操作之后的栈 +-----+-----+ | 124 | 112 | 操作之后的寄存器 +-----+-----+ ebp esp 10 movl %esp, %ebp —— 把 esp 的值传递到 ebp 中，形成函数 f 的新栈帧 +-----+-----+ | 124 | 112 | 操作之前的寄存器 +-----+-----+ ebp esp +-----+-----+ | 112 | 112 | 操作之后的寄存器 +-----+-----+ ebp esp 11 pushl 8(%ebp) —— 把 f 函数的参数 8 压入到 f 函数的栈中。因为 ebp 是 112，所以 8(%ebp) 120 中的值，也就是 8。 +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | ebp 124 | +-----------+ 112 | $8 | +-----------+ 108 | | +-----------+ 操作之后的栈 +-----+-----+ | 112 | 108 | 操作之后的寄存器 +-----+-----+ ebp esp 12 call g —— 调用 g 函数 +-----+-----+----+ | 112 | 108 | 13 | 操作之前的寄存器 +-----+-----+----+ ebp esp eip +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | ebp 124 | +-----------+ 112 | $8 | +-----------+ 108 | eip 13 | +-----------+ 104 | | +-----------+ 操作之后的栈 +-----+-----+---+ | 112 | 104 | 2 | 操作之后的寄存器 +-----+-----+---+ ebp esp eip 2 pushl %ebp —— 把 f 函数的基地址压入栈中以便返回 +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | ebp 124 | +-----------+ 112 | $8 | +-----------+ 108 | eip 13 | +-----------+ 104 | ebp 112 | +-----------+ 100 | | +-----------+ 操作之后的栈 +-----+-----+ | 112 | 100 | 操作之后的寄存器 +-----+-----+ ebp esp 3 movl %esp, %ebp —— 把 ebp 重置到 esp 的位置，形成 g 函数的栈帧。 +-----+-----+ | 112 | 100 | 操作之前的寄存器 +-----+-----+ ebp esp +-----+-----+ | 100 | 100 | 操作之后的寄存器 +-----+-----+ ebp esp 4 movl 8(%ebp), %eax —— 把 g 函数的参数 x 放到 eax 寄存器中。 +-----+-----+---+ | 100 | 100 | 8 | 操作之后的寄存器 +-----+-----+---+ ebp esp eax 5 addl $3, %eax +-----+-----+----+ | 100 | 100 | 11 | 操作之后的寄存器 +-----+-----+----+ ebp esp eax 6 popl %ebp —— 把栈顶部的元素弹出放入到 %ebp 中，恢复 f 函数的栈。 +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | ebp 124 | +-----------+ 112 | $8 | +-----------+ 108 | eip 13 | +-----------+ 104 | | +-----------+ 操作之后的栈 +-----+-----+----+ | 112 | 104 | 11 | 操作之后的寄存器 +-----+-----+----+ ebp esp eax 7 ret —— 恢复 f 函数中的 eip +-----+-----+----+---+ | 112 | 104 | 11 | 8 | 操作之前的寄存器 +-----+-----+----+---+ ebp esp eax eip +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | ebp 124 | +-----------+ 112 | $8 | +-----------+ 108 | | +-----------+ 操作之后的栈 +-----+-----+----+----+ | 112 | 108 | 11 | 13 | 操作之后的寄存器 +-----+-----+----+----+ ebp esp eax eip 13 addl $4, %esp —— 栈顶回退 4，相当与 pop 但是不需要栈顶值。 +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | ebp 124 | +-----------+ 112 | | +-----------+ 操作之后的栈 +-----+-----+----+ | 112 | 112 | 11 | 操作之后的寄存器 +-----+-----+----+ ebp esp eax 14 leave —— 相当于 move %ebp %esp, pop %ebp，恢复 main 函数的栈帧。 +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | eip 21 | +-----------+ 116 | | +-----------+ 操作之后的栈 +-----+-----+----+ | 124 | 116 | 11 | 操作之后的寄存器 +-----+-----+----+ ebp esp eax 15 ret —— 恢复 main 函数的 eip。 +-----+-----+----+----+ | 124 | 116 | 11 | 16 | 操作之前的寄存器 +-----+-----+----+----+ ebp esp eax eip +-----------+ 128 | ebp 128 | +-----------+ 124 | $8 | +-----------+ 120 | | +-----------+ 操作之后的栈 +-----+-----+----+----+ | 124 | 120 | 11 | 21 | 操作之后的寄存器 +-----+-----+----+----+ ebp esp eax eip 21 addl $4, %esp —— 去掉栈顶元素 +-----------+ 128 | ebp 128 | +-----------+ 124 | | +-----------+ 操作之后的栈 +-----+-----+----+ | 124 | 124 | 11 | 操作之后的寄存器 +-----+-----+----+ ebp esp eax 22 addl $1, %eax +-----+-----+----+ | 124 | 124 | 12 | 操作之后的寄存器 +-----+-----+----+ ebp esp eax 23 leave +-----+-----+----+ | 128 | 128 | 12 | 操作之后的寄存器 +-----+-----+----+ ebp esp eax 24 ret 结束 main 函数的调用，返回之前的栈帧。此时 eax 中包含返回值 12]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于 scanf() 函数格式字符串中的空白字符]]></title>
    <url>%2F2015%2F03%2F24%2Fblanks-in-scanf%2F</url>
    <content type="text"><![CDATA[问题最近重读 《The C Programing Language》 一书，7.4 节讲解格式化输入scanf，书中 关于 scanf() 函数的第一个参数——格式字符串的组成部分描述时有下面这样一句话。 Blanks or tabs, which are ignored. 然而使用 man 3 scanf 查看关于 scanf() 函数的文档时，同样关于格式字符串的 组成部分描述有下面这段话： A sequence of white-space characters (space, tab, newline, etc.; see isspace(3)). This directive matches any amount of white space, including none, in the input. K&amp;R 中说空白是被忽略的成分，而文档中给出的说法是空白会匹配输入流中任意空白字符 （包括 0 ）。那么到底那一种说法比较妥当呢？ 例子下面写两个例子比较一下： 12345678910111213#include &lt;stdio.h&gt;int main(void)&#123; int day = 0, year = 0; char monthname[20] = &#123;0&#125;; int sretval; sretval = scanf("Date: %d %s %d", &amp;day, monthname, &amp;year); printf("%d, %d, %s, %d\n", sretval, day, monthname, year); return 0;&#125; 这个程序输入：Date:28Dec 1998，输出的结果是： 3, 28, Dec, 1998 但是如果输入：&nbsp;&nbsp;&nbsp;Date:28Dec 1998，输出的结果是： 0, 0, , 0 注意第二个输入中在 Date: 之前有空格。 如果把上面的例子改写一下： 12345678910111213#include &lt;stdio.h&gt;int main(void)&#123; int day = 0, year = 0; char monthname[20] = &#123;0&#125;; int sretval; sretval = scanf(" Date: %d %s %d", &amp;day, monthname, &amp;year); /* 加空格*/ printf("%d, %d, %s, %d\n", sretval, day, monthname, year); return 0;&#125; 此时输入 Date:28Dec 1998 和输入 &nbsp;&nbsp;&nbsp;Date:28Dec 1998 得到的结果都是： 3, 28, Dec, 1998 从上面这两个例子来看，man 文档中的说法好像是妥当一些。]]></content>
  </entry>
  <entry>
    <title><![CDATA[LFS 中编译 Fcitx]]></title>
    <url>%2F2015%2F03%2F07%2Flfs-build-fcitx%2F</url>
    <content type="text"><![CDATA[LFS 教会我从无到有构建一个 Linux 系统，也让我对 Linux 系统的内部工作原理 有了更加深刻的理解。但是 LFS 和 BLFS 终究还是外国人写的，所以在中文支持方面 并不是特别让人满意。要想自己编译一个可以供日常使用的 Linux 系统对于我来说最大 的障碍在于 BLFS 中没有关于如何编译输入法的内容，而且网上能够找到的关于如何编译 输入法的资料几乎为零。 当然 BLFS 早就想到了这个问题，它不可能包含所有可能的包，所以它在开头第二章的 Going Beyond BLFS 一节中就提到了一些非常有用的建议，比如去下载你想要编译的软件 的 Arch 对应的包，解压之后查看里面的 PKGBUILD 文件以便得到如何编译你想要的包 的办法。 我根据这种方式成功的编译了 Fcitx 输入法框架以及 fcitx-googlepinyin 输入法。 因为网上关于如何编译输入法的资料较少，这里我把我的编译过程写下来希望对大家有帮助， 当然由于个人经验的缺乏，这个编译过程可能存在漏洞，如果你有更好的编译方法请 联系我 以便我及时更正，以免误人子弟。 本文将会采用 BLFS 的编写风格。我觉得这种风格比较适合阅读，如果文中没有特别提及， 那么你应该首先解压下载的源码包，然后切换到解压得到的目录内再执行后续的命令。编译 和安装完成之后，切换到源码包所在的同一级目录，删除解压出来的源码文件夹和编译时 新建的文件夹（如果存在的话）。 本文中提到的两个依赖包 Presage 和 opencc 并没有包含在 BLFS 中，请参考给出 的链接中的相关文档自行编译。 Fcitx-4.2.8.5fcitx 简介Fcitx 是一个支持扩展的输入法框架，目前支持 Linux 操作系统以及像 freebsd 这类的 Uniux 系统。它包含三个内置的输入法引擎 Pinyin，QuWei 和 基于 Table 的输入法。Fcitx 尽量在所有的桌面环境中都提供原生的体验以及轻量级 的引擎核心。你可以很容易的根据自己的需求来配置它。 这个包可以在 LFS-7.6 平台上 正常的编译和使用。 源码包信息 下载地址（HTTP）：http://download.fcitx-im.org/fcitx/fcitx-4.2.8.5_dict.tar.xz 下载包的 MD5 sum：8cf81a003a02b2f16d04dfec6e82e90a 下载包的大小：8.3 MB 预计需要的空间大小： 未知 预计需要的编译时间： 1 SBU 附加的下载 需要的补丁：https://projects.archlinux.org/svntogit/community.git/plain/trunk/custom-translation-install-dir.patch?h=packages/fcitx 需要的补丁：https://projects.archlinux.org/svntogit/community.git/plain/trunk/opencc-1.0.patch?h=packages/fcitx 配置工具：http://download.fcitx-im.org/fcitx-configtool/fcitx-configtool-0.4.8.tar.xz 谷歌拼音输入法： 库程序：https://libgooglepinyin.googlecode.com/files/libgooglepinyin-0.1.2.tar.bz2 fcitx-googlepinyin：http://download.fcitx-im.org/fcitx-googlepinyin/fcitx-googlepinyin-0.1.6.tar.xz Fcixt 的依赖需要的依赖LLVM-3.5.0（需要 Clang）， CMake-3.0.1， Xorg Libraries， GTK+-2.24.24， Qt-4.8.6， D-Bus-1.8.8， dbus-glib-0.102， ICU-53.1， Pango-1.36.7， Cairo-1.12.16， enchant-1.6.0， Presage， gobject-introspection-1.40.0， libxml2-2.9.1， ISO Codes-3.56 可选的依赖opencc（简繁体中文转换）和 GTK+-3.12.2 Fcitx 的安装首先打上必要的补丁： patch -p1 -i ../custom-translation-install-dir.patch &amp;&amp; patch -p1 -i ../opencc-1.0.patch &amp;&amp; cd .. Fcitx 文档中推荐建立 build 文件夹编译： mkdir fcitx-build &amp;&amp; cd fcitx-build 使用下面的命令编译 Fcitx： cmake ../fcitx-4.2.8.5 \ -DCMAKE_BUILD_TYPE=Release \ -DCMAKE_INSTALL_PREFIX=/usr \ -DSYSCONFDIR=/etc \ -DFORCE_PRESAGE=ON \ -DFORCE_ENCHANT=ON \ -DENABLE_TEST=ON \ -DENABLE_GTK2_IM_MODULE=ON \ -DENABLE_QT_IM_MODULE=ON &amp;&amp; make 编译完成之后通过以下命令测试编译结果： make test。 接写来使用超级用户权限执行以下命令以安装 Fcitx： make install &amp;&amp; gtk-update-icon-cache -q -t -f /usr/share/icons/hicolor &amp;&amp; update-desktop-database -q &amp;&amp; update-mime-database /usr/share/mime &amp;&gt; /dev/null &amp;&amp; cd src/frontend/gtk2 &amp;&amp; make install &amp;&amp; gtk-query-immodules-2.0 --update-cache &amp;&amp; cd ../../../ &amp;&amp; cd src/frontend/qt &amp;&amp; make install &amp;&amp; cd ../../../ &amp;&amp; cd tools/gui &amp;&amp; make install &amp;&amp; cd ../../ &amp;&amp; cd src/lib/fcitx-qt &amp;&amp; make install 如果你下载了 fcitx-configtool 可以执行下面的命令编译它： cmake -DCMAKE_INSTALL_PREFIX=/usr . &amp;&amp; make 编译完成之后以管理员身份执行： make install 安装这个包。 如果你下载了额外的谷歌拼音输入法，你可以通过下面的方式编译它。首先在解压的源文件 目录的同级目录下执行下面的命令编译库文件： rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake -DCMAKE_INSTALL_PREFIX=/usr . \ -DENABLE_STATIC=Off ../libgooglepinyin-0.1.2 &amp;&amp; make 以超级用户权限编译执行下面这个包以安装这个包： make install 然后通过下面的方式编译 fcitx-googlepinyin 程序，首先切换到 fcit-googlepinyin 解压后得到的目录中： rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake -DCMAKE_INSTALL_PREFIX=/usr -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; make 然后以超级用户权限执行以下命令安装： make install &amp;&amp; gtk-update-icon-cache -q -t -f /usr/share/icons/hicolor 安装的谷歌拼音输入法可以被 Fcitx 自动识别，不需要额外的配置。 包的内容 安装的程序： fcitx，fcitx4-config，fcitx-autostart，fcitx-configtool，fcitx-dbus-watcher，fcitx-diagnose，fcitx-remote，fcitx-skin-installer 安装的库： libfcitx*.so.* 安装的目录： /usr/include/fcitx，/usr/include/fcitx-config，/usr/include/fcitx-gclient，/usr/include/fcitx-utils 命令简介 fcitx: 用来启动 Fcitx 框架 fcitx-autostart: fcitx 命令的一个封装 fcitx-configtool： Fcitx 的配置程序，如果安装了 fcitx-configtool 包，它会调用 fcitx-config-gtk。 配置为了启动 Fcitx 框架，你可以执行 fcitx-autostart 命令，如果需要开机自启动可以 把这条命令加入到自启动脚本中，比如在 openbox 中可以把它加入到 ./config/openbox/autostart 文件中。 你可以直接调用 fcitx-configtool 命令来配置 Fcitx 本身。如果你安装了额外的 配置程序，这条命令会调用相应的配置程序；如果没有的话，它会调用 EDITOR 环境变量 指定的编辑器直接打开配置文件直接编辑配置文件以达到配置的目的。]]></content>
      <tags>
        <tag>LFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LKD 总结 —— 第三章]]></title>
    <url>%2F2015%2F02%2F26%2Flkd-chapter-three%2F</url>
    <content type="text"><![CDATA[概述这一章主要介绍的是进程的生命周期，包括进程如何表示，如何创建，如何销毁等等。第一 遍看这些内容的时候觉得有很多的地方都不太理解，重温一遍结合源代码理解之后有了更多 的领悟。文中引用的所有的源代码都是 linux-2.6.32.65 内核版本。 进程描述符在内核的内部，一个进程是由它的描述符来标识的，它包含了进程的所有信息。在其他的 操作系统教程中通常也会把它称为进程控制块（PCB）。Linux 内核的内部是通过 struct task_struct 结构体来表示进程描述符的，这是一个非常庞大而复杂的结构体。 书中简单的列举了它的一些这一章和下一章用到的重要字段： struct task_struct { unsigned long state; int prio; unsigned long policy; struct task_struct *parent; struct list_head tasks; pid_t pid; ... }; 从上面的结构体定义可以看出，在 Linux 中 process 其实和 task 应该是等价的。 此外因为 Linux 没有单独的结构体来表示线程，所以 thread 在内核的内部和 process 并没有什么本质的区别，也就和 task 没有本质的区别。 进程列表书中在这一章中多次提到了进程列表（task list）这个概念，但是书中并没有具体的介绍 它到底是什么东西，下面是我个人的理解： 要理解进程队列的概念首先还要理解内核链表的实现方式。 内核链表大部分教科书上提到的链表实现方式是把一个结构体变成链表，比如： struct node { int data; }; 改造成： struct node { int data; struct node *prev; struct node *next; } 而内核对于链表的实现方式是把链表的节点嵌入到结构体中去。所谓的链表节点就是两个 指向不同方向的指针。 struct list_head { struct list_head *prev; struct list_head *next; } 如果想要把数据连接起来，只要在结构体中加入一个链表节点就可以了： struct node { int data; struct list_head *list; } 乍一看两者没有区别，后面这种方式似乎还更加的复杂（node-&gt;prev 现在要通过 node-&gt;list-&gt;prev 才能访问）。但是仔细想想就会发现，这种做法有着极大的灵活性，因为 它实现了链表结构部分和数据部分解耦。 这个最直接的好处是，如果我需要把数据加入到一个新的链表中去的话，我只需要加入一个 新的链表节点。 struct node { int data; struct list_head *list1; struct list_head *list2; }; 如果不用这种方式你可能需要写下面这样的代码： struct node { int data; struct node *prev1; struct node *next1; struct node *prev2; struct node *next2; }; 如果你想要把节点加入到第三个、第四个、第五个 …… 链表中。 这样做还有另外一个好处就是，理论上你可以用不同的数据结构来形成一个链表。 struct foo { int foo1; int foo2; struct list_head *list; } foo_instance; struct bar { int bar1; int bar2; struct list_head *list; } bar_instance; 当然这种做法本身是一种非常糟糕的方式。 进程列表的实现在 tasks_struct 结构体中有一个字段 tasks 它的类型是 list_head，它相当于是 双向链表的一个节点。通过这个节点，每一个 task_struct 结构被链接在了进程列表中。 最终也就得到书中提到的进程列表。这一点可以在后面提到的 for_each_process() 函 数中体现。 进程描述符的分配在 2.6 内核之前 struct task_struct 结构体是固定在每个进程的内核栈的底部的，也 就是说分配一个内核栈就等于分配了一个进程描述符。这样就可以非常容易的获得这个 描述符，因为栈的指针存放在寄存器中。 +--------------------+ --- 高地址 | | ^ | | | | | 内核栈 |--------------------| | | struct task_struct | v +--------------------+ --- 低地址 现在 task_struct 是由 slab allocator 分配，也就是说 struct task_struct 结构体的地址并不固定，为了能够方便的获取进程描述符，在栈的底部存放了一个新的 结构体 struct thread_info 而这个结构体中存在一个指向 slab allocator 分配的 struct task_struct 结构体的指针。 +--------------------+ --- 高地址 +--------------------+ | | ^ | struct task_struct | | | | +--------------------+ | | 内核栈 ^ |--------------------| | +---------------------- | struct thread_info | v +--------------------+ --- 低地址 关于这两个结构体之间的相互引用关系可以查看后面关于新建进程描述符中的解释。 进程的标识对于应用程序来说，我们可以调用 getpid() 系统调用来得到一个进程的标识。而在内核 的内部，唯一确定一个进程的就是它的进程描述符，它可以通过调用 current 宏来实现。 因为 current 宏返回的是当前进程的进程描述符，所以这个宏只有在 进程上下文 中 才是有效的的，因为与子对应的 中断上下文 没有相关的进程存在，也就没有进程描述符。 进程树在 Linux 内核中，进程被组织成了一颗树的形式，所有的进程都是 init 进程的后代。 在 task_struct 结构体中存在一个指向父进程的 task_struct 的字段 parent[^1] 以及一个存放子进程的 children 字段。 书中的遍历进程的子进程的例子如下： list_for_each(list, &amp;current-&gt;children) { task = list_entry(list, struct task_struct, sibling); } 上面这个例子中比较奇怪的一点是 list_entry 函数使用的 sibling 字段而不是 children 字段。这里之所以写成 sibling 的原因是因为其实父进程的所有子进程是 通过子进程的 sibling 链接节点链接起来的，而父进程中的 children 字段是这个链表 的表头。在内核源码的 copy_process() 函数中创建完新的子进程进程描述符之后有下面 这段代码： if (likely(p-&gt;pid)) { list_add_tail(&amp;p-&gt;sibling, &amp;p-&gt;real_parent-&gt;children); ... } 也就是说 sibling 字段最终链接到的是 real_parent-&gt;children 链表。 但是因为 list_entry 其实就是 container_of 宏的一个别名，而 container_of 宏本身并不在乎使用的是哪一个字段。所以如果我的理解没有错误的话， 上面例子中的 sibling 可以替换成任何一个 task_struct 中的字段。 #define list_entry(ptr, type, member) \ container_of(ptr, type, member) #define container_of(ptr, type, member) ({ \ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ (type *)( (char *)__mptr - offsetof(type,member) );}) 在上一个小节中有提到，系统中存在一个进程列表连接所有的进程，这个列表是一个双向的 循环链表。遍历这个链表的方法是调用 for_each_process #define next_task(p) \ list_entry_rcu((p)-&gt;tasks.next, struct task_struct, tasks) #define for_each_process(p) \ for (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; ) 上面的 next_task 的实现也进一步证明 tasks 字段是用来链接整个进程列表的。 进程的创建在 Linux 内核中创建新进程通常是通过 fork() 系统调用实现的，它实际上则是调用 clone() 系统调用，进而调用 do_fork() 函数来完成这一工作。它实际上的工作就是 调用 copy_process() 复制父进程的进程描述符。copy_process() 函数主要完成以下 工作。 调用 dup_task_struct() 创建新的内核栈和以及 thread_info task_struct 结构体。 调用 alloc_task_struct() 函数使用 slab allocator 分配一个新的 struct task_struct 结构。 调用 alloc_thread_info() 获得一个新的 thread_info 结构体。这个函数在 x86 架构中的实现其实是调用 __get_free_pages() 函数。也就是说其实这个 函数分配了一页作为栈，而把这一页的开头强制转换成 struct thread_info。这 一点可以从后面的赋值语句：tsk-&gt;stack = ti; 中得知。这也可以解释为什了 struct thread_info 在内核栈的底部，因为内核栈是向下生长，所以页的开头 位置也就是栈的底部。 调用 arch_dup_task_struct() 函数复制原来的进程的 task_struct 结构体， 调用 setup_thread_stack() 函数复制原来的 struct thread_info 中的数据， 并设置新的 thread_info 的 task 字段，让他指向刚刚分配的 task_struct 结构。这样就形成了进程描述符的分配一节中提到的结构。 调用 copy_semundo() copy_files() copy_fs() copy_mm 等等 copy_**() 函数拷贝相关的进程资源。 调用 alloc_pid() 分配新的 PID。从随后的两个赋值语句 p-&gt;pid = pid_nr(pid); 和 p-&gt;tgid = p-&gt;pid; 可以看出对于一个普通的进程，它的 tgid 和 pid 是同一个 值。 Linux 中线程的实现方式在 Linux 没有单独的结构体用来表示 thread 这个概念，线程和进程没有本质的区别， 线程只不过是和其他线程共享资源的进程而已。 起 Solaris 和 Mircrosoft Windows 这些系统中，线程抽象出来只是为了能够实现轻量 级别的调度单元，而在 Linux 中线程是为了共享资源而存在因为 Linux 的线程本身就 已经足够轻量了，这是这两种操作系统在设计理念的区别。 因为在 Linux 中线程和进程本质上没有区别，都是使用 task_struct 来表示的，所以这 其中存在一个非常有趣的问题，那就是 PID 的问题。因为同一个进程的所有线程都应该 返回同一个 PID 而所有的线程都有自己独立的 task_struct 结构也就有不同的 pid 字段，也就是线程的 tid。 在 Linux 的实现中，task_struct 结构体中除了存在一个 pid 字段之外还存在一个 tgid 字段，也就是线程组的概念。从上一小节的第三点中我们知道，当一个进程创建为 普通的进程的时候，pid 和 tgid 属于同一个值，也就是说它属于一个只包含它自己的 线程组。但是从一个进程派生一个线程（比如通过 pthread_create() 函数）的时候， 新产生的 task_struct 会分配到一个新的 pid，但是它的 tgid 和它的父进程保持 一致，这样一来子进程（线程）就加入到了父进程的线程组中。 在 copy_process() 函数中有下面代码进一步的证明了上面这一点： if (clone_flags &amp; CLONE_THREAD) p-&gt;tgid = current-&gt;tgid; 所以当我们调用 getpid() 系统调用的时候，无论是进程还是线程都会放回 tgid ， 而调用 gettid() 的时候返回的才是 pid 字段。下面的代码是内核中这两个系统调用 的实现方式： /* Thread ID - the internal kernel &quot;pid&quot; */ SYSCALL_DEFINE0(gettid) { return task_pid_vnr(current); } /** * sys_getpid - return the thread group id of the current process * * Note, despite the name, this returns the tgid not the pid. The tgid and * the pid are identical unless CLONE_THREAD was specified on clone() in * which case the tgid is the same in all threads of the same group. * * This is SMP safe as current-&gt;tgid does not change. */ SYSCALL_DEFINE0(getpid) { return task_tgid_vnr(current); } 所以其实用户看到的 PID 和内核看到的 PID 并不是同一个值，在内核中使用 task_struct 结构体的 pid 字段而用户空间看到的则是 tgid。 新建进程（线程）的时候这两个值的赋值情况如下图： USER VIEW &lt;-- PID 43 --&gt; &lt;----------------- PID 42 -----------------&gt; +---------+ | process | _| pid=42 |_ _/ | tgid=42 | \_ (new thread) _ _ (fork) _/ +---------+ \ / +---------+ +---------+ | process | | process | | pid=44 | | pid=43 | | tgid=42 | | tgid=43 | +---------+ +---------+ &lt;-- PID 43 --&gt; &lt;--------- PID 42 --------&gt; &lt;--- PID 44 ---&gt; KERNEL VIEW 进程的终止进程的终止调用的是 exit() 系统调用，而这个系统调用实际上调用的是 do_exit() 函数： SYSCALL_DEFINE1(exit, int, error_code) { do_exit((error_code&amp;0xff)&lt;&lt;8); } 而 do_exit() 函数的框架如下： NORET_TYPE void do_exit(long code) { ... exit_signals(tsk); /* sets PF_EXITING */ ... tsk-&gt;exit_code = code; ... exit_mm(tsk); ... exit_sem(tsk); exit_files(tsk); exit_fs(tsk); exit_thread(); ... exit_notify(tsk, group_dead); tsk-&gt;state = TASK_DEAD; schedule(); } 这个函数最后会调用 schedule() 函数选择另一个进程运行，所以这个函数永远都不会 返回。在这个函数中比较值得关注的函数就是 exit_notify() 。这个函数会把当前进程 的所有子进程进行 reparent 并把当前进程的 task_struct 的 exit_state 设置成 EXIT_DEAD 或者是 EXIT_ZOMBIE。它的简化版本如下： static void exit_notify(struct task_struct *tsk, int group_dead) { ... forget_original_parent(tsk); ... tsk-&gt;exit_state = signal == DEATH_REAP ? EXIT_DEAD : EXIT_ZOMBIE; ... } do_exit() 函数并不会调用 free_task() 函数来释放进程描述符占用的空间，因为它 需要保留这些信息以便父进程调用 wait4() 来获取子进程的终止信息。 书中关于相关函数的介绍并不是非常的清晰，从源码的分析来看，这些函数有以下的调用 关系：sys_wait4()-&gt;do_wait()-&gt;do_wait_thread()-&gt;wait_consider_task()-&gt; wait_task_continued()-&gt;put_task_struct()-&gt;__put_task_struct()-&gt;free_task() 最终的 free_task() 会调用 free_thread_info() 和 free_task_struct 释放相关 结构体占用的空间。 reparent如果父进程在子进程之前结束了，那么它永远不会调用 wait4() 来获取子进程的终止信息 这样以来就会导致子进程的进程描述符得不到释放，浪费空间。为了解决这个问题，在进程 结束的时候需要对为它所有的子进程设置新的父进程，这一操作叫做 reparent。 exit_notify() 函数调用的 forget_original_parent() 会调用 find_new_reaper() 函数，这个函数查找该线程组中的其他进程作为 reaper 如果不存在这样的进程就使用 init 进程。 涉及到设置新的父进程的时候有另外一个地方比较难以理解，那就是在 task_struct 结 构体中存在两个不同的字段表示父进程 parent 和 real_parent 这两个字段的相关解释 可以参考 http://lists.kernelnewbies.org/pipermail/kernelnewbies/2012-February/004794.html 从该文中的解释来看，这个 real_parent 才是真正的指向父进程的进程描述符，而 parent 则是指向 ptrace 的进程描述符。 在 do_fork() 创建新的进程的时候，新进程的进程描述符有如下的设置： /* CLONE_PARENT re-uses the old parent */ if (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) { p-&gt;real_parent = current-&gt;real_parent; p-&gt;parent_exec_id = current-&gt;parent_exec_id; } else { p-&gt;real_parent = current; p-&gt;parent_exec_id = current-&gt;self_exec_id; } 这里都只是涉及到 real_parent 的设置。而在 __ptrace_link() 函数中有下面的设 置： child-&gt;parent = new_parent; 所以从这一点来看，书中在 The Process Family tree 一节中提到 task_struct 中的 parent 字段指向父进程的说法并不是特别妥当。]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>LKD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 Markdown 语法说明（简体中文版）]]></title>
    <url>%2F2015%2F02%2F20%2Fmarkdown-syntax-copy%2F</url>
    <content type="text"><![CDATA[这份文档来自网络，这里只是个人一个简单的备份，原文可以在 这个地址 找到。 Markdown 语法说明 (简体中文版) 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 概述 宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。 例子如下，在 Markdown 文件里加上一段 HTML 表格： 这是一个普通段落。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换 在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到： http://images.google.com/images?num=30&amp;q=larry+bird 你必须要把网址转换写为： http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写： &amp;copy; Markdown 会保留它不动。而若你写： AT&amp;T Markdown 就会将它转为： AT&amp;amp;T 类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写： 4 &lt; 5 Markdown 将会把它转换为： 4 &amp;lt; 5 不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。） 区块元素 段落和换行 一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。 如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。 的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 任何数量的 = 和 - 都可以有效果。 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： # 这是 H1 ## 这是 H2 ###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ###### 区块引用 Blockquotes Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表 Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue 等同于： + Red + Green + Blue 也等同于： - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish 很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为： &lt;ol&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;McHale&lt;/li&gt; &lt;li&gt;Parish&lt;/li&gt; &lt;/ol&gt; 如果你的列表标记写成： 1. Bird 1. McHale 1. Parish 或甚至是： 3. Bird 1. McHale 8. Parish 你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。 如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： * Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. * Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt; 标签包起来，举例来说： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;Bird&lt;/li&gt; &lt;li&gt;Magic&lt;/li&gt; &lt;/ul&gt; 但是这个： * Bird * Magic 会被转换为： &lt;ul&gt; &lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. 2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： * This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;re only required to indent the first line. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. * Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符： * 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法： 1986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 1986\. What a great season. 代码区块 和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入： 这是一个普通段落： 这是一个代码区块。 Markdown 会转换成： &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如： Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 会被转换为： &lt;p&gt;Here is an example of AppleScript:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beep end tell &lt;/code&gt;&lt;/pre&gt; 一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。 在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如： &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; 会被转换为： &lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation &amp;lt;/div&amp;gt; &lt;/code&gt;&lt;/pre&gt; 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。 分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： * * * *** ***** - - - --------------------------------------- 区段元素 链接 Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用 [方括号] 来标记。 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如： This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. 会产生： &lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt; an example&lt;/a&gt; inline link.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no title attribute.&lt;/p&gt; 如果你是要链接到同样主机的资源，你可以使用相对路径： See my [About](/about/) page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： This is [an example][id] reference-style link. 你也可以选择性地在两个方括号中间加上一个空格： This is [an example] [id] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： [id]: http://example.com/ &quot;Optional Title Here&quot; 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同： [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) 请注意：有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。 链接网址也可以用尖括号包起来： [id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： [id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的： [link text][a] [link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成： [Google][] 然后定义链接内容： [Google]: http://google.com/ 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit [Daring Fireball][] for more information. 然后接着定义链接： [Daring Fireball]: http://daringfireball.net/ 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用链接名称的方式写： I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面两种写法都会产生下面的 HTML。 &lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot; title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用： I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;) than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or [MSN](http://search.msn.com/ &quot;MSN Search&quot;). 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。 使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如： *single asterisks* _single underscores_ **double asterisks** __double underscores__ 会转成： &lt;em&gt;single asterisks&lt;/em&gt; &lt;em&gt;single underscores&lt;/em&gt; &lt;strong&gt;double asterisks&lt;/strong&gt; &lt;strong&gt;double underscores&lt;/strong&gt; 你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： un*frigging*believable 但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： \*this text is surrounded by literal asterisks\* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the `printf()` function. 会产生： &lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： ``There is a literal backtick (`) here.`` 这段语法会产生： &lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` 会产生： &lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; &lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段： Please don&apos;t use any `&lt;blink&gt;` tags. 转为： &lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以这样写： `&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以产生： &lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 图片 很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式的图片语法看起来像是： ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。 参考式的图片语法则长得像这样： ![Alt text][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： [id]: url/to/image &quot;Optional title attribute&quot; 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 其它 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： &lt;http://example.com/&gt; Markdown 会转为： &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &lt;address@example.com&gt; Markdown 会转成： &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65; &amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111; &amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61; &amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。 （这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠： \*literal asterisks\* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版目录]]></title>
    <url>%2F2015%2F02%2F18%2Flibnl-translation%2F</url>
    <content type="text"><![CDATA[这是libnl库的官方开发者文档教程的中文翻译，原文可以在这个地址中 找到。该文档由郭荣飞翻译，希望可以给开源世界贡献一份自己微薄的力量。本人非专业翻 译因此文中必然有翻译不当之处，如果您发现了这样的问题，请联系 &#103;&#117;&#x6f;&#x72;&#111;&#110;&#103;&#x66;&#x65;&#105;&#x40;&#49;&#x32;&#x36;&#x2e;&#99;&#111;&#x6d;。 目录 引言 1.1. 如何阅读这份文档 1.2. 如何链接到这个库 1.3. 调试 Netlink 协议基础 2.1. 寻址 2.2. 消息格式 2.3. 消息类型 2.4. 序列号 2.5. 多播组 Netlink 套接字 3.1. 套接字结构体 3.2. 序列号 3.3. 多播组订阅 3.4. 修改套接字回调配置 3.5. 套接字属性 消息或数据的发送和接收 4.1. 发送消息 4.2. 接收消息 4.3. Auto-ACK 模式 消息的解析和构造 5.1. 消息格式 5.2. 解析消息 5.3. 构建消息 属性 6.1. 属性格式 6.2. 属性解析 6.3. 属性的构造 6.4. 属性数据类型 6.5. 示例程序 回调配置 7.1. 回调函数挂钩点 7.2. 内部函数的覆盖 高速缓存系统 8.1. 高速缓存的分配 8.2. 高数缓存管理器 抽象数据类型 9.1. 抽象地址 9.2. 抽象数据]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第九部分]]></title>
    <url>%2F2015%2F02%2F17%2Flibnl-translation-part9%2F</url>
    <content type="text"><![CDATA[9. 抽象数据类型 libnl 的核心库中实现了一些大多数 neltink 协议都会用到的高层的抽象数据类型。 如果需要的话，未来可能还会实现更多。 9.1 抽象地址 大部分的 neltink 协议都是处理网络相关问题的，所以处理网络地址是一项常见的工作。 目前已经支持下面这些网络地址簇： AF_INET AF_INET6 AF_LLC AF_DECnet AF_UNSPEC 地址分配 nl_addr_alloc() 分配一个新的空地址。maxsize 参数定义了一个网络地址的最长 字节数。一个地址的大小和地址簇相关。如果一个地址簇和地址数据在分配的时候就已经 知晓的话，你可以选择使用 nl_addr_build() 函数。你也可以通过调用 nl_addr_clone() 函数来克隆一个地址。 #include &lt;netlink/addr.h&gt; struct nl_addr *nl_addr_alloc(size_t maxsize); struct nl_addr *nl_addr_clone(struct nl_addr *addr); struct nl_addr *nl_addr_build(int family, void *addr, size_t size); 如果地址是通过 netlink 属性传递的，你可以通过 nl_addr_alloc_attr() 函数根据 提供的属性的载荷分配一个新的地址。family 参数是用来指定一个地址簇的，如果你 不知道的话请把它设置成 AF_UNSPEC。 #include &lt;netlink/addr.h&gt; struct nl_addr *nl_addr_alloc_attr(struct nlattr *attr, int family); 如果地址是由用户提供的，它通常是存储在一个易于人类阅读的格式中的。nl_addr_parse() 可以用来解析一个代表地址的字符序列然后基于它分配一个新的地址。 #include &lt;netlink/addr.h&gt; int nl_addr_parse(const char *addr, int hint, struct nl_addr **result); 如果分配成功的话，这个函数会返回 0 并新分配的地址存放在 *result 中。 注意： 记得在使用完地址之后使用 nl_addr_put() 函数解除对它的引用以释放空间。 例子：把字符串转换成抽象地址 struct nl_addr *a = nl_addr_parse(&quot;::1&quot;, AF_UNSPEC); printf(&quot;Address family: %s\n&quot;, nl_af2str(nl_addr_get_family(a))); nla_addr_put(a); a = nl_addr_parse(&quot;11:22:33:44:55:66&quot;, AF_UNSPEC); printf(&quot;Address family: %s\n&quot;, nl_af2str(nl_addr_get_family(a))); nl_addr_put(a); 地址引用计数 抽象地址使用引用计数器来统计某个地址的使用总数。当最后一个用户解除对地址的引用 之后这个地址会被释放掉。 如果你把一个地址对象传递给另一个函数而你不知道这个函数将要使用这个地址多长时间， 这个时候确保你调用 nl_addr_get() 来活取一个额外的引用，然后让那个函数或者是代码 执行路径在用完地址之后尽可能早的调用 nl_addr_put()。 #include &lt;netlink/addr.h&gt; struct nl_addr *nl_addr_get(struct nl_addr *addr); void nl_addr_put(struct nl_addr *addr); int nl_addr_shared(struct nl_addr *addr); 你可以在任何时候通过调用 nl_addr_shared() 函数来检查自己是不是这个地址的唯一 使用者。 地址属性 地址簇通常是在分配的时候就已经设置好了的。但是如果那时这个地址还不确定的话，你 可以在之后调用 nl_addr_set_family() 函数来设置它，同样你可以调用 nl_addr_get_family() 函数来取得地址信息。 #include &lt;netlink/addr.h&gt; void nl_addr_set_family(struct nl_addr *addr, int family); int nl_addr_get_family(struct nl_addr *addr); 这一点对于地址的实际数据同样是成立的，它通常是在分配的时候就给出了。但是如果没有 在那时指定的话，你可以之后通过调用 nl_addr_set_binary_addr() 来设置或者是覆盖它。 需要注意的是新设置的值的长度不能超过地址分配的时候给出的最大值。地址数据是通过 nl_addr_get_binary_addr() 函数取得而它的长度则可以通过调用 nl_addr_get_len() 获得。 #include &lt;netlink/addr.h&gt; int nl_addr_set_binary_addr(struct nl_addr, void *data, size_t size); void *nl_addr_get_binary_addr(struct nl_addr *addr); unsigned int nl_addr_get_len(struct nl_addr *addr); 如果你只想检验地址数据是否全是由零组成的。你可以调用 nl_addr_iszero() 函数来 轻松的完成这项任务。 #include &lt;netlink/addr.h&gt; int nl_addr_iszero(struct nl_addr *addr); 9.1.1 地址前缀长度 虽然从功能性上来说它属于只和路由相关的功能，但是它是在核心库[^1]中实现的。地址 可以绑定一个前缀长度，这个长度表示只有前面的 n 个位是重要的。这可以用来实现 诸如子网之类的功能。 使用 nl_addr_set_prefixlen() 和 nl_addr_get_prefixlen() 函数来操控前缀长度。 #include &lt;netlink/addr.h&gt; void nl_addr_set_prefixlen(struct nl_addr *addr, int n); unsigned int nl_addr_get_prefixlen(struct nl_addr *addr); 注意： 默认的前缀长度被设置为（地址长度 × 8） 地址辅助函数 库中还存在其他的辅助函数帮助处理地址问题，nl_addr_cmp() 函数会忽略前缀长度 比较两个地址，并返回一个小于、等于或者大于 0 的整数。如果你需要考虑前缀长度的话， 你可以使用 nl_addr_cmp_prefix()。 #include &lt;netlink/addr.h&gt; int nl_addr_cmp(struct nl_addr *addr, struct nl_addr *addr); int nl_addr_cmp_prefix(struct nl_addr *addr, struct nl_addr *addr); 如果你需要把地址呈现给用户，那么你需要以一种易于人类阅读的格式呈现它，这个格式对于 不同的地址簇来说是不一样的。nl_addr2str() 函数会通过在内部调用合适的转换函数来 应对这一点。它接收一个 size 长的 buf 来存储输出的字符串并返回 buf 的指针以 方便 printf() 函数的调用。 #include &lt;netlink/addr.h&gt; char *nl_addr2str(struct nl_addr *addr, char *buf, size_t size); 如果不知道地址簇的话，地址数据会以十六进制的格式打印出来 AA:BB:CC:DD:.. 通常唯一能够得知地址簇的方式是查看地址的长度。nl_addr_guess_family() 函数使用 这种方式基于地址长度返回猜测的地址簇。 #include &lt;netlink/addr.h&gt; int nl_addr_guess_family(struct nl_addr *addr); 在分配地址之前你可能会想要检查给出的字符序列是否真的能代表你期望的地址簇中的一个 合法地址。nl_addr_valid() 函数可以用来完成这一个任务，如果给出的是地址簇中的 合法地址，这个函数会返回 1。关于合法的地址格式的更多信息，请查看 inet_pton(3) 、dnet_pton(3)。 #include &lt;netlink/addr.h&gt; int nl_addr_valid(char *addr, int family); 9.2. 抽象数据 抽象数据类型是一种简单的数据类型，它的主要目的是简化任意长度的 netlink 属性的 使用。 数据对象的分配 nl_data_alloc() 函数会分配一个新的抽象数据对象，然后使用提供的数据填充它。 nl_data_alloc_attr() 完成同一项工作，只不过它是基于 netlink 属性的载荷中的 数据的。新的数据对象也可以通过调用 nl_data_clone() 函数克隆已有的数据而得到。 struct nl_data *nl_data_alloc(void *buf, size_t size); struct nl_data *nl_data_alloc_attr(struct nlattr *attr); struct nl_data *nl_data_clone(struct nl_data *data); void nl_data_free(struct nl_data *data); 访问数据 nl_data_get() 函数返回一个指向数据的指针，数据的大小是通过 nl_data_get_size() 函数返回的。 void *nl_data_get(struct nl_data *data); size_t nl_data_get_size(struct nl_data *data); 数据处理的辅助函数 nl_data_append() 函数会重新分配内部的数据缓冲区，然后把给定的 buf 中的数据 添加到已有的数据末尾。 int nl_data_append(struct nl_data *data. void *buf, size_t size); 注意： 任何 nl_data_append() 函数的调用都会使得所有 nl_data_get() 函数 返回的同一数据对象的指针失效。 int nl_data_cmp(struct nl_data *data, struct nl_data *data); version 3.2 最后一次更新事件是 2014-07-16 12:04:02 CEST [^1]: libnl 库分为多个子库，请参考文档的第一部分，这份文档是核心库的开发者文档。【译者注】]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第八部分]]></title>
    <url>%2F2015%2F02%2F16%2Flibnl-translation-part8%2F</url>
    <content type="text"><![CDATA[8. 高速缓存系统 8.1. 高速缓存的分配 基本上所有的子系统都提供了一个函数用来分配一个某种形式的高速缓存。这个函数通常 是像这个样子的： struct nl_cache *&lt;object name&gt;_alloc_cache(struct nl_sock *sk); 这个函数为自己的对象类型分配一个新的高速缓存、适当的初始化它，然后对它进行更新 以便同步主存储区的当前状态。比如，一个链路高速缓存将会包含目前内核中已经配置的 所有的链路。 有些分配函数还会接收额外的参数以确定高速缓存中应该包含什么数据。 所有的这些函数都会返回一个新分配的高速缓存，或者是在出错的时候返回一个 NULL。 8.2. 高速缓存管理器 高速缓存管理器的作用是跟踪缓存区并自动接收事件通知以便保持缓存和内核状态的同步。 每一个高速缓存管理器都只有一个 neltink 套接字与之关联，这就把每个管理器限制在 一个 netlink 协议簇内。所以所有交给管理器的高速缓存都必须是同一个 netlink 协议簇的某一部分。管理器本身的特性决定了一个高速缓存无法同时维护同一个类型的缓存 的两个实例。与之关联的套接字会订阅每一个高速缓存的事件通知组并处于非阻塞模式。 库中存在许多函数不断的对套机字进行轮询（poll()）来等待新的事件的到来。 App libnl Kernel | | +-----------------+ [ notification, link change ] | | Cache Manager | | [ (IFF_UP | IFF_RUNNING) ] | | | | | +------------+| | | [ notification, new addr ] &lt;-------|---| route/link |&lt;-------(async)--+ [ 10.0.1.1/32 dev eth1 ] | | +------------+| | | | +------------+| | &lt;---|---|---| route/addr |&lt;------|-(async)--------------+ | +------------+| | | +------------+| | &lt;-------|---| ... || | | +------------+| | +-----------------+ | | 创建新的高速缓存管理器 struct nl_cache_mngr *mngr; // 为 RTNETLINK 分配一个新的高速缓存管理器并且自动提供 // 添加到管理器中的高速缓存 err = nl_cache_mngr_alloc(NULL, NETLINK_ROUTE, NL_AUTO_PROVIDE, &amp;mngr); 高速缓存的跟踪 struct nl_cache *cache; // 为链路/接口（links/interfaces）分配一个新的高速缓存并要求管理器为我们 // 维护它的更新。这将会发送一个全新的复制请求以初始化填充这个缓冲区。 cache = nl_cache_mngr_add(mngr, &quot;route/link&quot;); 使得管理器接收更新 // 使得管理器可以接收更新，这将会没 5 秒中调用一个 poll() 函数。 if (nl_cache_mngr_poll(mngr, 5000) &gt; 0) { // 管理器至少收到了一个更新，需要复制高速缓存吗？ nl_cache_dump(cache, ...); } 释放缓存管理器 nl_cache_mngr_free(mngr);]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第七部分]]></title>
    <url>%2F2015%2F02%2F15%2Flibnl-translation-part7%2F</url>
    <content type="text"><![CDATA[7. 回调配置 为了控制一些函数的行为， libnl 库在许多地方都设置了回调函数挂钩点并允许某些函数 的覆写。所有的回调和覆写函数都是封装在 struct nl_cb 结构体中，这个结构存在于 netlink 套接字中或者作为函数的参数直接传递。 7.1. 回调函数挂钩点 回调函数挂钩点散布在库中的各个角落中以提供消息处理的入口，同时它们也用于响应某些 事件。 回调函数可能会返回下面这些返回值： 返回值 描述 NL_OK 已经处理. NL_SKIP 跳过当前处理的消息继续解析接收缓冲区中下一个消息的处理。 NL_STOP 停止解析并丢弃接收缓冲区中的所有数据。 回调函数的默认实现 这个库提供了回调函数集的三个默认实现：默认的 NL_CB_DEFAULT 集合。它是默认的处理流程。 NL_CB_VERBOSE 集合，这个函数集基于默认的函数集但是它会把错误消息，非法消息， 泛滥（overrun）的消息和没有处理的合法消息的错误信息输出到 stderr 上。nl_cb_set() 函数 和 nl_cb_err() 函数参数中的指针可以用来提供一个 FILE* 用来覆盖 stderr。 *NL_CB_DEBUG 函数集则是出于调试目的而实现的。这个函数集基于 verbose 集合但是 它会解码和复制发送或接收到的每一个消息，并把数据发送了控制台（console）。 nl_sendmsgs() 回调函数挂钩点： 回调 ID 描述 默认返回值 NL_CB_MSG_OUT 发送出去的每一个消息 NL_OK 任何被 NL_CB_MSG_OUT 调用的函数都会可以返回一个负的错误码以达到阻止消息发送 出去并返回错误码的目的。 nl_recvmsgs() 回调函数挂钩点（按照优先级排序）： 回调 ID 描述 默认返回值 NL_CB_MSG_IN 接收到的每一个消息 NL_OK NL_CB_SEQ_CHECK 可以重新设置序列号检查算法 NL_OK NL_CB_INVALID 非法消息 NL_STOP NL_CB_SEND_ACK 含有 NLM_F_ACK 标志的消息 NL_OK NL_CB_FINISH 类型为 NLMSG_STOP 的消息 NL_STOP NL_CB_SKIPPED 类型为 NLMSG_NOOP 的消息 NL_SKIP NL_CB_OVERRUN em&gt;类型为 NLMSG_OVERRUN 的消息 NL_STOP NL_CB_ACK ACK 消息 NL_STOP NL_CB_VALID 所有的合法消息 NL_OK 所有的这些函数都可能返回 NL_OK,NL_SKIP,NL_STOP。 消息处理回调函数是通过 nl_cb_set() 函数设置的： #include &lt;netlink/handlers.h&gt; int nl_cb_set(struct nl_cb *cb, enum nl_cb_type type, emum nl_cb_kind kind, nl_recvmsg_msg_cb_t func, void *arg); typedef int(*nl_recvmsg_msg_cb_t)(struct nl_msg *msg, void *arg); 错误消息的回调函数 错误消息的回调函数挂钩点使用了一个特殊的函数原型： #include &lt;netlink/handler.h&gt; int nl_cb_err(struct nl_cb *cb, enum nl_cb_kind, nl_recvmsg_err_cb_t func, void *arg); typedef int(* nl_recvmsg_err_cb_t)(struct sockaddr_nl *nla, struct nlmsgerr *nlerr, void *arg); 例子：设置回调函数集合 #include &lt;netlink/handlers.h&gt; /* 分配一个回调函数集合并且通过默认的 verbose 接合来初始化它 */ struct nl_cb *cb = nl_cb_alloc(nl_cb_verbose); /* 修改函数集合让它多所有合法的消息都调用 my_func() */ nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, my_func, NULL); /* * 设置错误消息处理器为 verbose 的默认实现，并设置它把所有的错误 * 输出到给定的文件描述符中。 */ FILE *file = fopen(...); nl_cb_err(cb, NL_CB_VERBOSE, NULL, file); 7.2. 内部函数的覆盖 当库需要通过高层（high level）接口来发送和接收 neltink 消息的时候，它实际上是 调用自己的低层（low level）接口来完成这一任务的。如果默认的特性并不符合应用程序 的需求的话，你可以使用自己的私有实现来覆盖许多内部函数。 覆盖 recvmsgs() 函数 关于库的内部什么时候以及如何调用 recvmsgs() 函数更多的信息，请参考 接收 netlink 消息 一节。 #include &lt;netlink/handlers.h&gt; void nl_cb_overwrite_recvmsgs(struct nl_cb *cb, int (*func)(struct nl_sock *sk, struct nl_cb *cb)); 如果想要你的 recvmsgs() 实现和高层接口相融合的话,下面这些条件必须得到满足： 一定要考虑回调配置 cb,因此： 一定要对所有的合法消息调用 NL_CB_VALID 回调函数 一定要对所有的 ACK 消息调用 NL_CB_ACK 回调函数 一定要正确的处理多段式消息，对于每一个消息直到收到了 NLMSG_DONE 才调用 NL_CB_VALID 回调函数 一定要在收到了 NLMSG_OVERRUN 和 NLMSG_ERROR 消息的时候报告错误码。 覆盖 nl_recv() 函数 通常我们只需要覆盖负责从套接字中接收实际数据的 nl_recv() 函数而不需要完全替换整个 recvmsgs() 函数逻辑。 请查看 接收特性 以便获得内部函数如何以及何时调用 nl_recv() 函数。 #include &lt;netlink/handlers.h&gt; void nl_cb_overwrite_recv(struct nl_cb *cb, int (*func)(struct nl_sock *sk, struct sockaddr_nl *addr, unsigned char **buf, struct ucred **cred)) 一个私有的 nl_recv() 函数实现必须满足下面这些条件： 一定要返回读取的字节数目或者是在遇到错误时返回负的错误码。这个函数也可以返回 0 表示没有读取到任何的数据。 一定要把 *buf 设置成一个包含读取到的数据的缓冲区。实现必须保证调用者可以 从中安全的读取作为返回值的字节数。 可以把 addr 设置成发送数据的对等方的 netlink 地址。 可以把 *cred 设置成一个新分配的包含信用值的 struct ucred 结构体。 覆盖 nl_send() 函数 关于库的内部如何以及何时调用 nl_send() 函数，请参考 发送 netlink 消息 一节。 #include &lt;netlink/handlers.h&gt; void nl_cb_overwrite_send(struct nl_cb *cb, int(*func)(struct nl_sock *sk, struct nl_msg *msg)); 私有实现必须负责发送 netlink 消息，并在成功发送的时返回 0 或在错误时返回负的错误码。]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第六部分]]></title>
    <url>%2F2015%2F02%2F12%2Flibnl-translation-part6%2F</url>
    <content type="text"><![CDATA[6. 属性 如果可能的话，无论什么时候你都应该把 netlink 消息的有效载荷编码成 netlink 属 性。使用属性可以使得日后对任何 netlink 协议进行扩展的时候都不会破坏它的二进制 兼容性。比如：假设你的设备现在可能使用一个 32 位的计数器来统计数据，但是几年后设 备改成维护一个 64 位的计数器来记录更快的网络硬件。如果你的协议使用了属性，那么过 度到 64 位计数器是一个非常简单的事情，你只是需要发送一个新的属性来包含这个 64 位 的变量，与此同时仍然提供旧的 32 位的计数器。如果你的协议没有使用属性的话，你将无 法在不祸及已有的协议使用者的前提下转化这个数据类型。 属性嵌套的概念也允许你的协议的子系统实现和维护自己的属性模式。假如现在引入了新一 代的网络设备，而它需要设置一系列的协议设计之初没有考虑到的新的配置选项。通过使用 属性，新一代的设备可以定义一个新的属性然后用自己的子属性结构来填充这个属性，这些 子属性可以扩展甚至是完全废弃原来的属性。 所以，请始终使用属性，即便是在你几乎可以肯定你的消息格式永远都不会改变的情况下 也是如此。 6.1 属性格式 netlink 属性允许你往 neltink 消息中添加任意数量的任意长度数据段。关于属性在 消息中的存放位置请参考 【core_msg_attr】 一节。 nlmsg_attrdata() 函数返回的属性数据的格式如下： &lt;----------- nla_total_size(payload) -----------&gt; &lt;---------- nla_size(payload) -----------&gt; +-----------------+- - -+- - - - - - - - - +- - -+-----------------+- - - | struct nlattr | Pad | Payload | Pad | struct nlattr | +-----------------+- - -+- - - - - - - - - +- - -+-----------------+- - - &lt;---- NLA_HDRLEN -----&gt; &lt;--- NLA_ALIGN(len) ---&gt; &lt;---- NLA_HDRLEN --- 每一个属性都应该在 NLA_ALIGNTO （4 字节）倍数的偏移量上开始。如果你想知道属性 的末尾是否需要进行填充，你可以使用 nla_padlen() 函数，它返回需要添加的填充的字 节数。 每一个属性都是和一个类型及长度字段一起编码，这两个字节都是 16 个字节，它们存储在 属性的有效载荷前面的属性头部中（struct nlattr）。属性的长度是用来计算下一个属性 的偏移量的。 6.2 属性解析 把属性流分割成属性集 库中存在一个手动分割属性流的接口，虽然大部分的应用程序都会使用 nlmsg_parse() 家族的函数之一（参考 core_attr_parse_easy）来完成这项工作。 在【属性格式】 一节中提到，属性段中包含了不定数量的属性序列。 nlmsg_attrdata() 函数返回的指针指向第一个属性的头部。任何后续的属性都可以通过 在前一个属性头部上调用 nla_next() 来获得。 123#include &lt;netlink/attr.h&gt;struct nlattr *nla_next(const struct nlattr *attr, int *remaining); 这个函数的使用场景和 nlmsg_next() 函数是一样的，所以 nla_next() 函数也会从属 性流的剩余字节数中减去前一个属性的大小。 和消息一样，属性中并没有包含接下来是否还有其他属性的指示器。唯一可以用来判别的是 属性流的剩余字节数。nla_ok() 函数可以用来判断剩余字节数中是否还存在其他的属性 。 123#include &lt;netlink/attr.h&gt;int nla_ok(const struct nlattr *attr, int remaining); nla_ok() 和 nla_next() 函数的惯常用法如下： nla_ok()/nla_next()用法 1234567891011#include &lt;netlink/msg.h&gt;#include &lt;netlink/attr.h&gt;struct nlattr *hdr = nlmsg_attrdata(msg, 0);int remaining = nlmsg_attlen(msg, 0);while(nla_ok(hdr, remaining)) &#123; /* 在此解析属性 */ hdr = nla_next(hdr, &amp;remaining);&#125; 注意：nla_ok() 只有在剩余字节数中包含包括属性有效载荷在内的完整属性的时候 才会返回 true 访问属性的头部和属性的有效载荷 无论是使用分割属性流的方式还是还是使用其他接口，只要找出来一个属性你就可以访问它 的载荷和头部。 &lt;- nla_len(hdr) -&gt; +-----------------+- - -+- - - - - - - - - +- - -+ | struct nlattr | Pad | Payload | Pad | +-----------------+- - -+- - - - - - - - - +- - -+ nla_data(hdr) ---------------^ nla_len() 函数和 nla_type() 函数可以用来访问属性的头部。nla_len() 会返回不 包括填充字节在内的载荷的长度。nla_type() 函数则会返回属性的类型。 1234#include &lt;netlink/attr.h&gt;int nla_len(const struct nlattr *hdr);int nla_type(const struct nlattr *hdr); nla_data() 函数会返回指向属性有效载荷的指针。需要注意的是因为 NLA_ALIGENTO 是 4 个字节所以直接转型或解引用任何大于 32 位的数据类型的指针都是不安全的做法， 这依赖于应用程序所运行的平台。 123#include &lt;netlink/attr.h&gt;void *nla_data(struct nlattr *hdr); 注意： 千万不要断定载荷的大小是你期望的大小，务必自己检查载荷的长度的来确 认它满足你的要求 属性检验 当接收到一个 netlink 属性的时候，接收者对属性应该是什么样子有自己的期望。这种 期望必须被定义出来以保证发送方满足我们的期望。出于这个目的，库中提供了一个属性验 证的接口，它必须在访问任何的载荷之前使用。 任何提供属性验证的函数都是基于 struct nla_policy 结构体的： 12345struct nla_policy &#123; uint16_t type; uint16_t minlen; uint16_t maxlen;&#125;; type 字段指定了属性的数据类型，比如：NLA_U32、NLA_STRING、NLA_FLAG，它的 默认值是 NLA_UNSPEC。minlen 字段定义了合法属性的最小的有效载荷长度。minlen 的值对于大部分诸如整型、标志这类的基本数据类型来说都是隐含的。maxlen 字段则定 义了合法属性的最大有效载荷长度。 注意： 当我们把结构体编码到一个属性中去的时候，指定最大的有效载荷长度并非明 智之举因为这不利于日后扩展该结构体。而在 neltink 协议中一项常见任务就是扩展协 议而不会破坏它的向后兼容性 nla_validate() 是使用 struct nla_policy 结构体的函数之一。这个函数接收一个 struct nla_policy 数组并使用属性类型作为下标访问数组。如果一个属性类型越界的话 这个属性会被当做是合法的属性。这个为了使旧的应用程序在无法识别新引入的属性的情况 下能正常工作而特意进行的处理。 123#include &lt;netlink/attr.h&gt;int nla_validate(struct nlattr *head, int len, int maxtype, struct nla_policy *policy) 如果属性合法 nla_policy() 函数返回 0，否则它返回一个和错误相关的错误码。 大部分应用程序不会直接使用 nla_validate() 而是使用 nla_parse() 函数。这个函 数以同样的方式验证属性，但是在验证的同时它还会解析属性。 [core_attr_parse_easy][attr_parse_eray] 一节中有更多的信息以及一个例子程序。 验证属性的详细步骤如下： 1. 如果属性类型是 0 或者大于最大的属性值，返回 0。 2. 如果属性的有效载荷长度小于 minlen，返回 -NLE_ERANGE。 3. 如果定义了 maxlen 而有效载荷长度超过了这个值， 返回 -NLE_ERANGE。 4. 检验数据类型相关的规则，参考属性数据类型一节。 5. 如果上面的全部条件都满足的话返回 0。 解析属性的便捷方式 大部分的应用程序不会想要按照core_attr_parse_split 中提到的方式自己分割属性流 。一种更加便捷的方式是使用 nla_parse() 函数。 #include &lt;netlink/attr.h&gt; int nla_parse(struct nlattr **attrs, int maxtype, struct nlattr *head, int len, struct nla_policy *policy); nla_parse() 函数会迭代一条属性流，按照 core_attr_validation 中提到的方式验证每一个属性，如果所有的属性都通过了验证的话，指向每一个属性的指针 会被存放在属性数组的 attrs[nla_type(attr)] 位置中。 除了 nla_parse() 函数之外你也可以使用 nlmsg_parse() 函数把解析消息和解析消息 的属性的工作在一个步骤中完成。关于如何使用这些函数请参考 core_attr_parse_easy 一节。 例子 下面的例子展示了如何解析一个通过 neltink 协议发送的不包含协议头部的 neltink 消息。但是这个例子强制使用了属性规则（policy），MY_ATTR_FOO 必须是 32 位的整数 而 MY_ATTR_BAR 必须是一个最多包含 16 个字符的字符串。 #include &lt;netlink/msg.h&gt; #include &lt;netlink/attr.h&gt; enum { MY_ATTR_FOO = 1, MY_ATTR_BAR, __MY_ATTR_MAX, }; #define MY_ATTR_MAX (__MY_ATTR_MAX - 1) static struct nla_policy my_policy[MY_ATTR_MAX+1] = { [MY_ATTR_FOO] = { .type = NLA_U32 }, [MY_ATTR_BAR] = { .type = NLA_STRING, .maxlen = 16 }, }; void parse_msg(struct nlmsghdr *nlh) { struct nlattr *attrs[MY_ATTR_MAX+1]; if (nlmsg_parse(nlh, 0, attrs, MY_ATTR_MAX, my_policy) &lt; 0) /* 出错处理 */ if (attrs[MY_ATTR_FOO]) { /* 消息中存在 MY_ATTR_FOO 类型的属性 */ printf(&quot;value: %u\n&quot;, nla_get_u32(attrs[MY_ATTR_FOO])); } } 定位单个属性 如果一个应用程序只在乎单个属性，那么它可以使用 nla_find() 函数和 nlmsg_find_attr() 函数。这些函数会迭代所有的属性，找到一个符合条件的属性然后发 挥这个属性头部的指针。 #include &lt;netlink/attr.h&gt; struct nlattr *nla_find(struct nlattr *head, int len, int attrtype); #include &lt;netlink/msg.h&gt; struct nlattr *nlmsg_find_attr(struct nlmsghdr * hdr, int hdrlen, int attrtype); 注意： nla_find() 和 nlmsg_find_attr() 不会搜索嵌套的属性，参考 嵌套属性 一节 迭代属性流 有些时候为属性流中的每一个属性都设置一个唯一的属性类型并不太合理。比如一个列表可 以通过一系列的属性来传输，即便每一个属性的属性类型是都是递增的，使用 nlmsg_parse() 或者 nla_parse() 函数填充一个数组的做法也是不合理的^1。 因此库中提供了迭代属性流的方法： #include &lt;netlink/attr.h&gt; nla_for_each_attr(attr, head, len, remaining) nla_for_each_attr() 是一个宏，你可以在代码块之前使用： #include &lt;netlink/attr.h&gt; struct nlattr *nla; int rem; nla_for_each_attr(nla, attrstream, streamlen, rem) { /* 验证并解析属性 */ } if (rem &gt; 0) /* 没有解析的数据 */ 6.3. 属性的构造 往 neltink 消息中添加属性的接口是建立在普通的消息构建接口之上的。这里假设消息 的头部和实际的 netlink 协议的头部已经添加到消息中了。 struct nlattr * nla_reserve(struct nl_msg *msg, int attrtype, int len); nla_reserve() 函数在消息的末尾添加一个属性头部并且为属性载荷预留 len 字节的 空间。这个函数会返回消息中的属性载荷段的指针。为了保证下一个属性正确的对齐，这个 函数还会在添加的属性的末尾进行必要填充。 int nla_put(struct nl_msg *msg, int attrtype, int attrlen, const void *data); nla_put() 函数以 nla_reserve() 函数为基础，只不过它还接收一个指向包含属性载荷 的缓冲区的指针。这个函数会自动把数据从缓冲区拷贝到消息中去。 例子 struct my_attr_sturct { uint32_t a; uint32_t b; }; int my_put(struct nl_msg *msg) { struct my_attr_sturct obj = { .a = 10, .b = 20, }; return nla_put(msg, ATTR_MY_STRUCT, sizeof(obj), &amp;obj); } 关于数据类型相关的属性构造请查看 属性数据类型 一节。 基于异常的属性构造 和内核 API 类似，这个库提供了基于异常的接口。这些宏的行为和他们对应的方法是一致的， 不同之处在出错时这些宏会跳转到 nla_put_failure 位置。 例子[^2] #inlcude &lt;netlink/msg.h&gt; #include &lt;netlink/attr.h&gt; void construct_attrs(struct nl_msg *msg) { NLA_PUT_STRING(msg, MY_ATTR_FOO1, &quot;some text&quot;); NLA_PUT_U32(msg, MY_ATTR_FOO2, 0x1010); NLA_PUT_FLAG(msg, MY_ATTR_FOO3, 1); return 0; nla_put_failure: /* NLA_PUT 系列的宏会在出错的时候跳转到这个位置 */ return EMSGSIZE; } 关于数据类型相关的异常处理变种请查看 属性数据类型 一节。 6.4. 属性数据类型 为了简化属性的访问和验证库中定义了许多基本数据类型。属性的数据类型并没有编码在 属性中，所以发送方和接收方对于哪一个属性属于何种数据类型要有一致的定义。 类型 描述 NLA_UNSPEC 不确定的属性 NLA_U{8|16|32} 整型 NLA_STRING 字符串 NLA_FLAG 标志 NLA_NESTED 嵌套属性 这些数据类型除了能够简化属性访问之外，最大的优势在于对于每个属性会基于一个 policy 自动进行合法性检验。这种检验会通过检查载荷的最小长度（对某些数据类型也会进行载荷 最大长度的检验）来保证访问载荷的安全性。 6.4.1. 整型属性 使用得最多的数据类型是整型。整型有四种不同的大小： NLA_U8 8 位的整数 NLA_U16 16 位的整数 NLA_U32 32 位的整数 NLA_U64 64 位的整数 注意由于对齐需求的存在，使用 NLA_U8 和 NLA_U16 规格的整型起不到节省 nelink 消息空间的作用，使用它们只是为了限制属性值的范围。 解析整型属性 #include &lt;neltink/attr.h&gt; uint8_t nla_get_u8(struct nlattr *hdr); uint16_t nla_get_u16(struct nlattr *hdr); uint32_t nla_get_u32(struct nlattr *hdr); uint64_t nla_get_u64(struct nlattr *hdr); 例子： if (attrs[MY_ATTR_FOO]) uint32_t val = nla_get_u32(attrs[MY_ATTR_FOO]); 构建整型属性 #include &lt;neltink/attr.h&gt; int nla_put_u8(struct nl_msg *msg, int attrtype, uint8_t value); int nla_put_u16(struct nl_msg *msg, int attrtype, uint16_t value); int nla_put_u32(struct nl_msg *msg, int attrtype, uint32_t value); int nla_put_u64(struct nl_msg *msg, int attrtype, uint64_t value); 基于异常的对应函数： NLA_PUT_U8(msg, attrtype, value); NLA_PUT_U16(msg, attrtype, value); NLA_PUT_U32(msg, attrtype, value); NLA_PUT_U64(msg, attrtype, value); 验证 如果你在在填充一个 struct nl_policy 数组的时候使用 NLA_U8、NLA_U16、NLA_U32 或者 NLA_U64 来定义整数类型，libnl 库会保证这些 policy 使用正确的的最小载荷 长度。 验证并不区分有符号和无符号整数，唯一的决定因素是数据的大小。如果应用程序需要保证 数据在某个特定的范围的话，它需要自己完成这一项检验。 static struct nla_policy my_policy[ATTR_MAX+1]={ [ATTR_FOO]={.type=NLA_U32}, [ATTR_BAR]={.type=NLA_U8}, }; 上面这段代码等价于： static struct nla_policy my_policy[ATTR_MAX+1]={ [ATTR_FOO]={.minlen=sizeof(uint32_t)}, [ATTR_BAR]={.minlen=sizeof(uint8_t)}, }; 6.4.2. 字符串属性 字符串类型用来标识一个以 NUL 结尾的不定长字符序列。它不是用来标识二进制数据流。 字符串属性的有效载荷可以通过调用 nla_get_string() 函数来获得。nla_strdup() 函数会对属性载荷调用 strdup() 函数并返回新分配的字符串。 #inlcude &lt;neltink/attr.h&gt; char *nla_get_string(struct nlattr *hdr); char *nla_strdup(struct nlattr *hdr); 字符串属性是通过 nla_put_string() 或者对应的 NLA_PUT_STRING() 宏分配的。属性 的长度是 strlen() + 1，因为末尾的 NUL 字符也会包括在内。 int nla_put_string(struct msg, int attrtype, const char *data); NLA_PUT_STRING(msg, attrtype, data); 为了验证字符串属性，你可以在定义 struct nla_policy 时使用 NLA_STRING 类型。 这个类型意味着载荷的最短长度是 1 字节，并且会检查 NUL 字符的存在。此外你可以 使用 maxlen 字段来定义字符序列的最大长度（包括末尾的 NUL 字符）。 static struct nla_policy my_policy[] = { [ATTR_FOO] = { .type = NLA_STRING, .maxlen = IFNAMSIZ, }, }; 6.4.3 标志属性 标志属性代表一个布尔数据类型。如果属性存在则表示值为真，不存在则表示值为假。所以 标志属性的载荷长度永远都是 0。 int nla_get_flag(struct nlattr *hdr); int nla_put_flag(struct nl_msg, int attrtype); 为了方便验证，库中也定义了 NLA_FLAG 属性。它表示 maxlen 为 0 也就保证了最大 的载荷长度是 0。 例子 /* nla_put_flag() 在消息中添加一个长度为 0 的属性。*/ nla_put_flag(msg, ATTR_FOO); /* 没有对应的接收方法，因为属性的存在与否代表了属性的值 */ if (attrs[ATTR_FOO]) /* 标志存在 */ 6.4.4 嵌套属性 在 属性 一节中已经提到，属性可以嵌套以表达属性之间的复杂树形结构。属性 嵌套也通常也用来表示一个子系统在消息中的子段。嵌套属性通常还会用来传输对象的列表。 当进行属性嵌套的时候，嵌套的属性作为父属性（容器属性-container）的有效载荷而存在。 注意： 当使用 nlmsg_validate()、nlmsg_parse()、nla_validate() 或者 nla_parse() 函数来验证属性的时候，它们只会验证第一层的属性。这些函数都不会递归 的验证属性。所以你必须对每一层的嵌套属性显式的调用 nla_validate() 或者 nla_parse_nested() 当定义一个嵌套属性的 struct policy 结构的时候你应该使用 NLA_NESTED 类型。它 不会强制使用任何最小载荷长度，除非你自己提供了这个字段。这是因为某些 neltink 协议允许空的容器属性。 static struct nla_policy my_policy[] = { [ATTR_FOO] = {.type = NLA_NESTED}, }; 嵌套属性的解析 nla_parse_nested() 函数可以用来解析嵌套属性。它的行为和 nla_parse() 函数是 一致的，只不过它接收一个 struct nlattr 作为参数并且会使用这个属性的有效载荷作为 属性流进行解析。 if (attrs[ATTR_OPTS]) { struct nlattr *nested[NESTED_MAX+1]; struct nla_policy nested_policy[] = { [NESTED_FOO] = {.type = NLA_U32}, }; if (nla_parse_nested(nested, NESTED_MAX, attrs[ATTR_OPTS], nested_policy) &lt; 0) /* 错误*/ if (nested[NESTED_FOO]) uint32_t val = nla_get_u32(nested[NESTED_FOO]); } 嵌套属性的构造 属性的嵌套是通过在代码前后分别调用 nla_nest_start() 和 nla_nest_end() 来完成的。 nla_nest_start() 函数会在消息中添加一个没有实际载荷的属性头部，在此之后添加的 数据都会成为容器属性的载荷部分直到调用 nla_nest_end() 为止，它的调用“关闭”了 容器属性并校正它的载荷长度以包含所有的数据长度。 int put_opts(struct nl_msg *msg) { struct nlattr *opts; if (!(opts = nla_nest_start(msg, ATTR_OPTS))) goto nla_put_failure; NLA_PUT_U32(msg, NESTED_FOO, 123); NLA_PUT_STRING(msg, NESTED_BAR, &quot;some text&quot;); nla_nest_end(msg, opts); return 0; nla_put_failure: nla_nest_cancle(msg, opts); return -EMSGSIZE; } 6.4.5 不定属性 这是默认的属性类型，它在没有合适的基本数据类型的时候使用。它用来表示任意长度任意 类型数据。 库中存在一个特殊的接口允许基于 netlink 属性分配抽象的地址对象，这个对象包含某种 形式的网络地址。请参考 地址分配 一节以便获取更多的信息。 关于如何基于 neltink 属性分配抽象数据对象的更多信息请查看 抽象数据分配 一节。 这种类型的属性可以使用 nla_get() 和 nla_put() 函数来获取和构造属性。请查看 属性构造 一节中的例子。 6.5. 示例程序 6.5.1. 使用属性构造 netlink 消息 struct nl_msg *build_msg(int ifindex, struct nl_addr *lladdr, int mtu) { struct nl_msg *msg; struct nlattr *info, *vlan; struct ifinfomsg ifi = { .ifi_family = AF_INET, .ifi_index = ifindex, }; /* 使用默认大小分配一条消息 */ if (!(msg = nlmsg_alloc_simple(RTM_SETLINK, 0))) return NULL; /* 添加协议相关的头部 (struct ifinfomsg)*/ if (nlmsg_append(msg, &amp;ifi, sizeof(ifi), NLMSG_ALIGNTO) &lt; 0) goto nla_put_failure /* 使用一个 32 位整型的属性来承载 MTU */ NLA_PUT_U32(msg, IFLA_MTU, mtu); /* 使用一个不定类型属性来承载链路层地址 */ NLA_PUT_ADDR(msg, IFLA_ADDRESS, lladdr); /* 添加一个容器属性以便使用嵌套属性来承载链路信息 */ if (!(info = nla_nest_start(msg, IFLA_LINKINFO))) goto nla_put_failure; /* 往容器属性中添加一个字符串属性 */ NLA_PUT_STRING(msg, IFLA_INFO_KIND, &quot;vlan&quot;); /* * 在打开的容器属性中再添加一个容器用来携带 * vlan 相关的属性 */ if (!(vlan = nla_nest_start(msg, IFLA_INFO_DATA))) goto nla_put_failure; /* 在此添加和 vlan 相关的信息... */ /* 完成 vlan 相关信息的填充并关闭第二个容器. */ nla_nest_end(msg, vlan); /* 完成 link 信息属性的嵌套并关闭第一个容器. */ nla_nest_end(msg, info); return msg; nla_put_failure: nlmsg_free(msg); return NULL; } 6.5.2 解析包含属性的 netlink 消息 int parse_message(struct nlmsghdr *hdr) { /* * policy 定义了两个属性: 一个 32 位整数和一个用来进行属性 * 嵌套的容器属性。 */ struct nla_policy attr_policy[] = { [ATTR_FOO] = { .type = NLA_U32 }, [ATTR_BAR] = { .type = NLA_NESTED }, }; struct nlattr *attrs[ATTR_MAX+1]; int err; /* * nlmsg_parse() 函数会保证消息的有效载荷至少足够容纳协议头部 * (struct my_hdr), 验证消息中包含的所有属性然后把属性的头部指针 * 按照属性类型存储在 attrs[] 数组中。 */ if ((err = nlmsg_parse(hdr, sizeof(struct my_hdr), attrs, ATTR_MAX, attr_policy)) &lt; 0) goto errout; if (attrs[ATTR_FOO]) { /* * 你现在可以安全的直接访问属性载荷而不用进行任何的检查 * 因为 nlmsg_parse() 函数会保证 policy 得到满足 */ uint32_t foo = nla_get_u32(attrs[ATTR_FOO]); } if (attrs[ATTR_BAR]) { struct *nested[NESTED_MAX+1]; /* * 嵌套在容器中的属性可以和顶层属性一样解析。 */ err = nla_parse_nested(nested, NESTED_MAX, attrs[ATTR_BAR], nested_policy); if (err &lt; 0) goto errout; // 在此处理嵌套属性。 } err = 0; errout: return err; } [^2]: 原文中的例子里面 MY_ATTR_FOO2 写成了 MY_ATTR_FOO1 个人认为是笔误。【译者注】]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第五部分]]></title>
    <url>%2F2015%2F01%2F31%2Flibnl-translation-part5%2F</url>
    <content type="text"><![CDATA[5. 消息的解析和构建 5.1 消息格式 关于 netlink 协议以及它的消息格式请查看 netlink 协议基础 一 节。 对齐 大部分的 netlink 协议对所有的边界都有严格的对齐方案。对齐值是由 NLMSG_ALIGNTO 定义的，这个值固定为 4 个字节。所以所有的 netlink 消息头部、有 效载荷段的开头、协议相关头部和属性段都必须从一个是 NLMSG_ALIGNTO 倍数的偏移量 开始。 1234#include &lt;netlink/msg.h&gt;int nlmsg_size(int payloadlen);int nlmsg_total_size(int payloadlen); 这个库提供了一系列的函数来自动处理对齐问题。nl_total_size() 函数返回一个消息总 长度，这个长度包括了确保下一个消息头部已经正确对齐的填充（padding）长度。 &lt;----------- nlmsg_total_size(len) ------------&gt; &lt;----------- nlmsg_size(len) ------------&gt; +-------------------+- - -+- - - - - - - - +- - -+-------------------+- - - | struct nlmsghdr | Pad | Payload | Pad | struct nlsmghdr | +-------------------+- - -+- - - - - - - - +- - -+-------------------+- - - &lt;---- NLMSG_HDRLEN -----&gt; &lt;- NLMSG_ALIGN(len) -&gt; &lt;---- NLMSG_HDRLEN --- 如果你想知道是否需要在一个消息的尾部进行填充处理，nlmsg_padlen() 函数会返回对 于一个给定的有效载荷长度需要进行填充的字节数目。 123#include &lt;netlink/msg.h&gt;int nlmsg_padlen(int payloadlen); 5.2 解析一个消息 这个库提供了两套完全不同的方法来解析 netlink 消息。它为那些需要手动完成所有解 析的应用程序提供了一套低层（low level）的 API。这种方式会在下面进行介绍。此外该 库也提供了另外一套接口用于把解析器实现成高速缓存（cache[^1]）操作的一部分，如果 你的协议是用来处理诸如网络链路、路由的任何类型的对象的时候这种方式将会非常有用。 这套高层（hight level）接口会在 高速缓存系统 一节中介绍。 把字节流拆分成多条消息 通常从一个网络套接字中接收下来的是消息流。你将会得到一个缓冲区以及它的长度，这个 缓冲区可能包含任意数量的 netlink 消息。 第一个消息头部位于消息流的开始处。任何后续的消息都是通过在前一个头部的基础上调用 nlmsg_next() 函数来获得。 123#include &lt;netlink/msg.h&gt;struct nlmsghdr *nlmsg_next(struct nlmsghdr *hdr, int *remaining); nlmsg_next() 会自动从剩余字节数中减掉前一个消息的大小。 需要注意的是，在前一个消息中并没有指示是否存在下一个消息，你必须假设有更多的消息 存在直到消息流中的所有数据都被解析完成为止。 为了简化这个工作，libnl 库提供了另一个函数 nlmsg_ok()，如果消息流中的剩余字 节中还存在另一个消息的话，这个函数会返回 true。nlmsg_valid_hdr() 是一个类似 的函数，它检查的是一个给定的 netlink 消息中是否至少包含某个最小长度的有效载荷 。 1234#include &lt;netlink/msg.h&gt;int nlmsg_valid_hdr(const struct nlmsgdhr *hdr, int payload);int nlmsg_ok(const struct nlmsghdr *hdr, int remaining); 这些函数的一个典型使用方式如下： 1234567891011#include &lt;netlink/msg.h&gt;void my_parse(void *stream, int length)&#123; struct nlmsghdr *hdr = stream; while(nlmsg_ok(hdr, length)) &#123; // Parse message here hdr = nlmsg_next(hdr, &amp;length); &#125;&#125; 注意： nlmsg_ok() 只会在剩余缓冲区长度足够容纳包括消息有效载荷在内的整个消息 的时候才会返回 true 。如果只是包含部分消息的话它会返回 false 上面的例子可以使用 nlmsg_for_each() 迭代器改写： 1234567#include &lt;netlink/msg.h&gt;struct nlmsghdr *hdr;nlmsg_for_each(hdr, stream, length) &#123; /* 处理消息 */&#125; 消息有效载荷 消息的有效载荷是附加在消息头部的末尾的，而且它一定是在 NLMSG_ALIGNTO 的倍数位 置开始。前面这点是通过在消息头部的末尾进行必要的填充来保证的。nlmsg_data() 函 数会根据消息计算好必要的偏移量然后返回消息有效负载开始处的指针。 12345#include &lt;netlink/msg.h&gt;void *nlmsg_data(const struct nlmsghdr *nlh);void *nlmsg_tail(const strcut nlmsghdr *nlh);int nlmsg_datalen(const struct nlmsgdhr *nlh); 消息有效负载的长度是通过 nlmsg_datalen() 返回的。 &lt;--- nlmsg_datalen(nlh) ---&gt; +-------------------+- - -+----------------------------+- - -+ | struct nlmsghdr | Pad | Payload | Pad | +-------------------+- - -+----------------------------+- - -+ nlmsg_data(nlh) ---------------^ ^ nlmsg_tail(nlh) --------------------------------------------------^ 有效负载可能包含任意的数据，但是可能会有严格的对齐以及格式标准，这一切都由实际的 netlink 协议决定。 消息属性 大部分的 netlink 协议都使用了 netlink 属性。它不但可以使得协议自身更容易理解 而且可以使得协议在日后扩展更加方便。新的协议可以在任意时刻添加而旧的属性也可以被 新的属性废弃掉而不会破坏协议的二进制兼容性。 &lt;---------------------- payload -------------------------&gt; &lt;----- hdrlen ----&gt; &lt;- nlmsg_attrlen(nlh, hdrlen) -&gt; +-------------------+- - -+----- ------------+- - -+--------------------------------+- - -+ | struct nlmsghdr | Pad | Protocol Header | Pad | Attributes | Pad | +-------------------+- - -+-------------------+- - -+--------------------------------+- - -+ nlmsg_attrdata(nlh, hdrlen) -----------------------------^ nlmsg_attrdata() 函数会返回一个属性段的指针。属性段的长度可以通过调用 nlmsg_attrlen() 函数得到。 #include &lt;netlink/msg.h&gt; struct nlattr *nlmsg_attrdata(const struct nlmsghdr *hdr, int hdrlen); int nlmsg_attrlen(const struct nlmsgdhr *hdr, int hdrlen); 关于如何使用 netlink 的属性请查看 属性 一节。 解析消息的便捷方式 nlmsg_parse() 函数一步完成一个完整的 netlink 消息的检验。如果 hdrlen &gt; 0 的话，这个函数首先会调用 nlmsg_valid_hdr() 来检验这个消息中是否能容纳下协议头 部。如果还有有效载荷需要解析的话，该函数会假设这些有效载荷是属性然后按照属性来解 析有效载荷。当用于属性解析的时候，这个函数和 nla_parse() 函数是完全一样的，更 多详情请查看 core_attr_parse_easy。 int nlmsg_parse(struct nlmsghdr *hdr, int hdrlen, struct nlattr **attrs, int maxtype, struct nla_policy *policy); 在 core_attr_parse_easy 中还有一个额外的例子，以及更加 详细的信息。 5.3. 构建消息 关于 netlink 消息格式以及对齐需求方面的信息请参考 消息格式 一节 。 消息的构建是基于 struct nl_msg 结构体的，它使用内部缓冲区来存储实际的 netlink 消息。struct nlmsg 结构体并不指向与 netlink 消息的头部。请使用 nlmsg_hdr() 来获取这条 netlink 消息的头部指针。 在分配结构体的时候，可以指定最大的消息长度。它的默认大小是一页（PAGE_SIZE）。构 造消息应用程序将会不断地从这个最大消息长度中为每个添加的头部和属性预留空间。这种 方式可以让构建一个跨越多个层代码的消息时下层不用知道上层需要的空间。 为什么需要设置最大消息长度呢？这个问题经常和被推荐的方法——使用 realloc() 函数 动态的重新分配消息有效载荷缓冲区——一起被提出来。虽然在构建消息时可以使用 nlmsg_expand() 函数重新分配缓冲区，但这会导致所有指向消息缓冲区的指针失效。这 会使得 nlmsg_hdr()、nla_nest_start() 和 nla_nest_end() 函数出错，所以这种 方式无法作为默认方式。 分配 struct nl_msg 结构体 构建一条新的 netlink 消息的第一步是分配一个 struct nl_msg 结构体来承载消息头 部和有效载荷。为了简化各种各样的操作，库中存在多个这类的函数。 1234#include &lt;netlink/msg.h&gt;struct nl_msg *nlmsg_alloc(void);void nlmsg_free(struct nl_msg *msg); nlmsg_alloc() 函数是默认的分配函数，它使用默认的最大消息长度，也就是一页的大小 （PAGE_SIZE）来分配一条新的消息。应用程序可以通过调用 nlmsg_set_defualt_size() 函数来更改默认大小。 1void nlmsg_set_defualt_size(size_t); 注意： 调用 nlmsg_set_default_size()并不会改变已经分配了的消息的最大消息长度 。 1struct nl_msg *nlmsg_alloc_size(size_t max); 除了改变默认消息长度之外，你也可以使用 nlmsg_alloc_size() 函数使用一个给定的最 大消息长度来来分配一条消息。 如果 netlink 消息头部在分配的时候就已经确定，应用程序可以考虑使用[^2] nlmsg_inherit() 函数。这个函数会使用默认的最大消息长度分配一条消息，然后把头部 拷贝到这条消息中去。以 NULL 为参数调用 nlmsg_inherit() 就等于是调用 nlmsg_alloc() 函数。 1struct nl_msg * nlmsg_inherit(struct nlmsghdr *hdr); 除了上面的方式之外，你也可以调用 nlmsg_alloc_simple() ，这个函数接收消息类型和 消息标志为参数。它的作用和 nlmsg_inherit() 其实是一样的，只不过前者把两个常用 的头部字段作为参数而后者使用使用整个头部作为参数。 123#include &lt;netlink/msg.h&gt;struct nl_msg *nlmsg_alloc_simple(int nlmsg_type, int flags); 附加 netlink 消息头部 分配了 struct nl_msg 结构体之后，你需要添加 netlink 消息头部，除非你使用了 nlmsg_alloc_simple() 或者 nlmsg_inherit() 函数。如果你使用了前面两个方法之后 还进行这一步操作的话，这一步操作给出的头部会覆盖前面两个函数中的头部。 1234#include &lt;netlin/msg.h&gt;struct nlmsghdr *nlmsg_put(struct nl_msg *msg, uint32_t port, uint32_t seqnr, int nlmsg_type, int payload, int nlmsg_flags); nl_put() 函数会根据提供的 nlmsg_type、nlmsg_flags、seqnr、port 参数构 建一个消息头部，然后把数据拷贝到 netlink 消息中。seqnr 可以设置成 NL_AUTO_SEQ，这表示自动使用下一个可用的序列号。为了使用这一特性，这条消息必须 通过 nl_send_auto() 函数发送出去。和 seqnr 参数一样，port 参数可以被设置为 NL_AUTO_PORT，这表示使用套接字中的本地端口号作为源端口。这通常是一个不错误的主 意，除非你是在回复一个请求[^3]。关于如何填充消息头部的更多信息请参考 Netlink 协 议基础 一节。 注意： 应用程序可以使用 payload 参数在头部后面为额外的数据预留空间。如果 payload 的值大于 0 的话，这相当于是调用 nlmsg_reserve(msg, payload, NLMSG_ALIGNTO)。关于为数据预留空间的更多信息请参考 「core_msg_reserve」 示例: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;netlink/msg.h&gt;struct nlmsghdr *hdr;struct nl_msg *msg;struct myhdr &#123; uint32_t foo1, foo2;&#125; hdr = &#123; 10, 20 &#125;;/* 使用默认大小分配一条消息 */msg = nlmsg_alloc();/* * 使用类型 MY_MSGTYPE, 标志 NLM_F_CREATE 构造消息头部， * 让库来填充端口号和序列号并且为 struct myhdr 预留空间。 */hdr = nlmsg_put(msg, NL_AUTO_PORT, NL_AUTO_SEQ, MY_MSGTYPE, sizeof(hdr), NLM_F_CREATE);/* 把自己的消息头部拷贝到刚刚预留的空间 */memcpy(nlmsg_data(hdr), &amp;hdr, sizeof(hdr));/* * 消息的格式如下: * +-------------------+- - -+----------------+- - -+ * | struct nlmsghdr | Pad | struct myhdr | Pad | * +-------------------+-----+----------------+- - -+ * nlh -^ / \ * +--------+---------+ * | foo1 | foo2 | * +--------+---------+ */ 在消息的末尾预留空间 虽然后面介绍的大部分函数都会为添加到 neltink 消息尾部的数据自动预留空间，但是 有些情况下，应用程序还是需要直接预留空间。 123#include &lt;netlink/msg.h&gt;void *nlmsg_reserve(struct nl_msg *msg, size_t len, int pad); nlmsg_reserve() 函数在 netlink 消息的默认预留 len 字节的空间，然后返回一个 指向这块预留空间开始位置的指针。pad 参数可以用来在预留空间之前把 len 对齐到 任意字节。 下面这个例子请求在消息末尾预留一块 17 字节的空间并对齐到 4 字节处，因此最后预留 的空间总共是 20 个字节。 123#include &lt;netlink/msg.h&gt;void *buf = nlmsg_reserve(msg, 17, 4); 注意： nlmsg_reserve() 不会对齐缓冲区的开头，任何对齐需求都必须由前面的消息 段的所有者来。 在消息的尾部添加数据 nlmsg_append() 函数在消息的末尾添加 len 字节的数据，并在请求了填充且需要填充 的情况下进行填充。 123#include &lt;netlink/msg.h&gt;int nlmsg_append(strcut nl_msg *msg, void *data, size_t len, int pad); 这个方法等同于调用 nlmsg_reserve() 函数然后调用 memcpy() 函数把数据拷贝到刚 刚预留的空间中去。 注意： nlmsg_reserve() 不会对齐缓冲区的开头，任何对齐需求都必须由前面的消息 段的所有者来。 在消息中添加属性 关于如何构建属性和把属性添加到消息将会在 属性 一节中介绍。 [^1]: 这里的 cache 不是计算机组成原理里面提供的硬件，不要混淆。「译者注」 [^2]: 原文中使用 sue 一词应该是 use 一词的笔误。「译者注」 [^3]: 前面两句在是按照原文中的顺序翻译的，个人觉得顺序有颠倒。因为是使用自动序列号在应答消息中不适用（应答消息的序列号可能和请求一致）。「译者注」]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第四部分]]></title>
    <url>%2F2015%2F01%2F27%2Flibnl-translation-part4%2F</url>
    <content type="text"><![CDATA[4. 消息或数据的发送和接收 4.1 发送消息 使用 netlink 套接字发送一条 netlink 消息的标准方式是调用 nl_send_auto() 函数。 这个函数会通过填充缺失的字段以及填充 netlink 消息头部自动完成这条 netlink 消息的 构建。此外这个函数还会根据 netlink 套接字设置的选项和地址来处理寻址问题。之后这 个消息会被传递给 nl_send() 函数。 如果 nl_send() 实现的默认函数逻辑并不适合你的应用程序，你可以通过调用 nl_cb_overwirte_send() 来指定你自己的实现方式以覆盖原本的接收函数 nl_send() nl_send_auto(sk, msg) + | | +--------&gt;nl_complete(sk, msg) | | | 通过 nl_cb_overwrite_send() 指定的接收函数 +-----------------------------------+ | | v v nl_send(sk, msg) send_func() 使用 nl_send() 如何你不需要任何的消息自动补全功能，你可以直接使用 nl_send() 函数，但是需要注 意的是，libnl 库内部调用 nl_send_auto 来发送数据的时候还是会调用 nl_send() 函数。因此如果你想要使用任何的高层（higher level）的接口但又不喜欢 nl_send() 的的行为的话，你需要调用 nl_cb_overwrite_send() 函数来覆写 nl_send() 函数。 nl_send() 函数的目的是把 netlink 消息嵌入到一个 iovec 结构体中然后把这个结 构体传递给 nl_send_iovec() 函数。 nl_send(sk, msg) | v nl_send_iovec(sk, msg, iov, iovlen) 使用 nl_send_iovec()函数 nl_send_iovec() 接收一个最终的 netlink 消息然后用它来填充一个用来发送的 struct msghdr 结构。这个函数首先查看 struct nl_msg 结构是否设置了特殊的对等 端（查看 nlmsg_set_dst() 函数）。如果没有的话，它会尝试取得在套接字中设定的对 等端地址（查看 nl_socket_peer_port()）。如果上面两个都没有找到地址的的话，这个 消息会以非定址（unaddressed）状态发送，把寻找正确的对等端的任务交给内核。 如果存在并且启用了信用度机（credentials）制的话 nl_send_iovec() 还会增加信用度 ，更多信息请查看 core_sk_cred。 接下来消息会被传递给 nl_sendmsg()。 nl_send_iovec(sk, msg, iov, iovlen); | v nl_sendmsg(sk, msg, msghdr) 使用 nl_sendmsg() nl_sendmsg() 函数接收一个最终的 netlink 消息和一个可能包含对等节点地址的 struct msghdr 结构体[^1]。这个函数会把套接字中定义的本地端口（参考 nl_socket_set_local_port()）拷贝到 netlink 消息的头部中去。 至此消息构造完成，可以准备发送出去了。 nl_sendmsg(sk, msg, msghdr) | |---------------------------+ | v | NL_CB_MSG_OUT() |&lt;--------------------------+ v sendmsg() 在发送之前，应用程序还有最后一次机会更改消息。这个消息会被传递给 nl_cb_msg_out 回调函数，这个函数可能会检查或者修改消息并返回一个错误码。如果错误码是 nl_ok 这个消息会通过 sendmsg() 函数发送出去，这个函数的返回值是发送的字节数。否则的 话中止这个消息的发送处理并且返回回调函数提供的错误码。关于如何设置回调函数请参考 修改套接字回调配置 一节。 使用 nl_sendto()发送原始数据 如果你希望通过 netlink 套接字发送一个原始数据，下面这个函数会把提供给它的任何缓 冲区直接传递给 sendto() 函数： #include &lt;netlink/netlink.h&gt; int nl_sendto(struct nl_sock *sk, void *buf, size_t size); 发送简单消息 libnl 库中存在一个特殊的接口用来发送简单的消息。这个函数接收 netlink 消息类 型、可选的 netlink 消息标志以及可选的数据缓冲区和数据长度。 #include &lt;netlink/netlink.h&gt; int nl_send_simple(struct nl_sock *sk, int type, int flags, void *buf, size_t size); 这个函数会根据提供的消息的类型和标志构造一个 netlink 消息头部然后把数据缓冲区 作为消息的有效负载。新构建的消息会调用 nl_send_auto() 发送出去。 在下面这个例子[^2]中，我们将会发送一个请求消息，这个消息会导致内核复制一份所有的 网络链路的列表到用户空间。 #include &lt;netlink/netlink.h&gt; struct nl_sock *sk; struct rtgenmsg rt_hdr = { .rtgen_family = AF_UNSPEC, }; sk = nl_socket_alloc(); nl_connect(sk, NETLINK_ROUTE); nl_send_simple(sk, RTM_GETLINK, NLM_F_DUMP, &amp;rt_hdr, sizeof(rt_hdr)); 接收消息 接收 netlink 消息最简单的方式就是调用 nl_recvmsgs_default() 函数。它会根据套 接字中定义的场景来接收消息。虽然这个函数的默认行为对大多数的应用程序都适用，你的 应用程序也可以调整其中的细节。 nl_recvmsgs_default() 这个函数也会在 libnl 库内部需要接收和解析 netlink 消 息的时候被调用。 这个函数会读取在套接字中的回调配置，然后调用 nl_recvmsgs() 函数： nl_recvmsgs_default(sk) | | cb = nl_socket_get_cb(sk) v nl_recvmsgs(sk, cb) 使用 nl_recvmsgs() 函数 nl_recvmsgs() 函数实现了实际的接收循环，除非这个套接字被设置成了非阻塞模式，否 则的话这个函数会一直阻塞直到接收到 netlink 消息为止。 在一些极端的场景下，某些接收特性没办法通过修改回调配置（参考 修改套接字回调配置 一节）调整内部的消息接收函数这种方式来获得。这时应用程序可以通 过调用 nl_cb_overwrite_recvmsgs() 函数提供自己的完整的实现方案以便覆盖所有的 nl_recvmsgs() 函数的调用。 nl_recvmsgs(sk, cb) | | 通过 nl_cb_overwrite_recvmsgs() 提供的自己的消息接收函数 |-----------------------------------+ v v internal_recvmsgs() my_recvmsgs() 接收特性 如果应用程序没有通过 nl_cb_overwrite_recvmsgs() 提供自己的 recvmsgs() 函数的 实现。从一个 netlink 套接字接收数据将会有下面这些特性。 internal_recvmsgs() | +--------------&gt;| 使用 nl_cb_overwrite_recv() 函数指定的接收函数 | |- - - - - - - - - - - - - - - - | v v | nl_recv() my_recv() | |&lt;- - - - - - - - - - - - - - -+ | |&lt;- - - - - - -+ | v | 是否还有更多的消息需要解析? (nlmsg_next()) | Parse Message | | |- - - - - - - + | v +------- NLM_F_MULTI set? | v (SUCCESS) 首先调用函数 nl_recv() 函数从 netlink 套接字中接收数据。这个函数也可能被应用 程序调用 nl_cb_overwrite_recv() 提供的私有实现覆盖掉。如果 netlink 字节流实 际上是从文件或者其他数据源读取到而不是直接从套接字接收下来的话，这种覆盖是非常有 用的。 如果数据已经被读取出来了的话，internal_recvmsgs() 函数将会尝试解析数据。这个解 析过程会一直重复直到遇到 NL_STOP 类型的数据或者遇到错误又或者是没有可以解析的 数据为止。 如果最后一个成功解析的消息是一个多段式数据（参考 分段式数据） 并且解析器没有因为遇到错误或者接收到 NL_STOP 消息而退出的话，nl_recv() 函数 或者应用程序的实现的私有接收函数会被再次调用，而解析器也会再次启动。 关于如何从解析器中取出有效的 netlink 消息以及如何控制解析器的行为的详细信息请 参考 [core_parse_character]。 消息解析特性 从一个 netlink 套接字中读取下来每一个 netlink 消息都会调用内部的解析器进行解 析。它通常是被 nl_recv() 调用（参考 [core_recv_character]）。 解析器首先确定数据流的长度足够容纳一个 netlink 消息头部，然后确定消息头部中提 供的消息长度没有超过数据流的总长。 如果上面的条件都满足的话，分配一个新的 strutct nl_msg 然后把消息传递给回调函数 NL_CB_MSG_IN（如果提供了的话）。和其他的回调函数一样，它可能会返回 NL_SKIP 来忽略当前的消息然后继续解析下一个消息也可能返回 NL_STOP 从而完全停止解析过程 。 下一步是检查消息的序列号和当前期望的序列号是否一致。应用程序可以通过把回调函数 NL_CB_SEQ_CHECK 设置成自己的私有实现来提供自己的序列号检验算法。事实上调用 nl_socket_disable_seq_check() 函数来取消序列号检测只不过是把 NL_CB_SEQ_CHECK 回调函数设置成了一个永远返回 NL_OK 的函数而已。 此外还存在一个回调函数挂钩点 NL_CB_SEND_ACK，这个函数会在收到含有 NLM_F_ACK 标志的消息之后被调用。虽然我并不知道有哪一个用户空间的 netlink 套接字需要给发 送方发送ACK消息，但是应用程序还是有可能会需要这么做（参考 ACKs 一节） parse() | v nlmsg_ok() --&gt; Ignore | |- - - - - - - - - - - - - - - v | NL_CB_MSG_IN() |&lt;- - - - - - - - - - - - - - -+ | |- - - - - - - - - - - - - - - v Sequence Check NL_CB_SEQ_CHECK() |&lt;- - - - - - - - - - - - - - -+ | | Message has NLM_F_ACK set |- - - - - - - - - - - - - - - v | NL_CB_SEND_ACK() |&lt;- - - - - - - - - - - - - - -+ | Handle Message Type Auto-ACK 模式 TODO [^1]: 这句话的原文是 optioanl struct msgdhr containing the peer address 从语法上翻译的话应该是说 struct msghdr 结构体是可选的。但是这本身是解释不通的，因为 nl_sendmsg() 这个函数的函数原型中参数 struct msghdr * hdr 是固定的参数而并非可选的，这一点可以参考API文档中的 相关介绍。从上一段关于 nl_send_iovec() 函数的寻址处理中提到地址可能最终不确定，所以这里翻译成了msgdhr 可能包含地址，如果有更合理的解释，请联系我 &#x67;&#117;&#111;&#x72;&#111;&#x6e;&#103;&#x66;&#x65;&#105;&#64;&#49;&#50;&#54;&#46;&#99;&#111;&#109;。「译者注」 [^2]: 这个例子在的最后一条语句中 nl_send_simple 函数的第一个参数写成了 sock，个人认为这是笔误。]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第三部分]]></title>
    <url>%2F2015%2F01%2F26%2Flibnl-translation-part3%2F</url>
    <content type="text"><![CDATA[3. Netlink 套接字 为了使用 netlink 协议，我们首先需要一个 netlink 套接字[^1]。每个套接字都定义了一 个独立的消息发送和接收的上下文环境。一个应用程序可以使用多个套接字，比如一个套接 字用于发送请求消息和接受应答消息另一个套接字用来订阅某个多播组以便接收通知消息。 3.1. 套接字结构体（struct nl_sock） netlink 套接字以及和他相关的包括实际的文件描述符在内的所有属性都使用 nl_sock 结构体表示的。 1234#include &lt;netlink/socket.h&gt;struct nl_sock *nl_socket_alloc(void)void nl_socket_free(struct nl_sock) 应用程序必须为它想要使用的每一个 netlink 套接字分配一个 struct nl_sock 结构体 实例。 3.2. 序列号 libnl 库会自动为应用程序管理序列号。在套接字结构体内部存储了一个序列号计数器，如 果你发送了一个期望得到回复的请求消息，而且这个回复是诸如错误消息或者是其他任何需 要用到相关的原始消息的消息，那么这个计数器会自动递增。 此外，这个计数器也可以直接通过 nl_socket_use_seq() 函数使用。这个函数会返回计 数器当前的值然后自增一。 123#include &lt;netlink/socket.h&gt;void nl_socket_use_seq(struct nl_sock *sk); 当然大部分的应用程序都不会想要自己处理序列号，是调用 nl_send_auto() 函数的时候 ，序列号会自动填充并在收到回复信息的时候再次匹配。更多信息请参考 消息/数据的发 送和接收 一节 如果 netlink 协议的实现不需要使用请求/应答模式，比如当一个套接字是用来接收通知消 息的时候，序列号的这种行为可以也必须取消掉. 123#include &lt;netlink/socket.h&gt;void nl_socket_disable_seq_check(struct nl_sock *sk); 关于 nelink 序列号背后的的更多理论知识，请参考 序列号 一节。 3.3. 多播组的订阅 每一个套接字都可以订阅它连接的 netlink 协议的任意数量的多播组，之后这个套接字将 会接收到发送到其中任何一组的任何一条消息的拷贝。多播组一般是用来实现事件通知。 在 2.6.14 版本之前的内核中组的订阅是通过一个位掩码（bitmask）来实现的，这就限制 了每个协议簇最多能够使用 32 个组。虽然在新的代码中不建议再使用这个过时的接口，你 还是可以通过 nl_join_groups() 来访问它。 123#include &lt;netlink/socket.h&gt;void nl_join_groups(struct nl_sock *sk, int bitmask); 2.6.14 内核引入了新的实现方式，这使得你可以订阅几乎是无限数量的多播组。 1234#include &lt;netlink/socket.h&gt;int nl_socket_add_memberships(struct nl_sock *sk, int group, ...);int nl_socket_drop_memberships(struct nl_sock *sk, int group, ...); 3.3.1 多播示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;netlink/netlink.h&gt;#include &lt;netlink/socket.h&gt;#include &lt;netlink/msg.h&gt;/* * 每次 nl_recvmsgs_default() 每次收到有效消息都会调用这个函数 */static int my_func(struct nl_msg *msg, void *arg)&#123; return 0;&#125;struct nl_sock *sk;/* 分配新的套接字 */sk = nl_socket_alloc();/* * 通知消息不是用序列号，取消序列号的自动检测 */nl_socket_disable_seq_check(sk);/* * 定义一个在每次收到通知消息都会调用的回调函数 */nl_socket_modify_cb(sk, NL_CB_VALID, NL_CB_CUSTOM, my_func, NULL);/* 连接到路由 netlink 协议 */nl_connect(sk, NETLINK_ROUTE);/* 订阅链路通知组 */nl_socket_add_memberships(sk, RTNLGRP_LINK, 0);/* * 开始接收消息。函数 nl_recvmsgs_default() 在接收到一个或者多个消息（通知） * 之前会一直阻塞，接收到的消息会被传递给 my_func() 回调函数。 */while (1) nl_recvmsgs_default(sock);```cpp&lt;H2 id = "callback_config"&gt;3.4. 修改套接字回调配置&lt;/H2&gt;关于回调拦截点和它的重写能力请参考 [回调函数配置][cbk_cfg] 一节。每一个套接字都有一个控制套接字行为的回调配置。这在某些情况下是必须要这么做的，比如需要给每个套接字单独定义消息接收函数时候。当然在套接字之间共享回调配置也是完全合法的操作。下面这些函数可以用来读取或者设置一个套接字的回调配置：```cpp#include &lt;netlink/socket.h&gt;struct nl_cb *nl_socket_get_cb(const struct nl_sock *sk);void nl_socket_set_cb(struct nl_sock *sk, struct nl_cb *cb); 此外还有一个直接修改套接字回调配置的快捷函数： 1234#include &lt;netlink/socket.h&gt;int nl_socket_modify_cb(struct *sk, enum nl_cb_type type, enum nl_cb_kind kind, nl_recvmsgs_msg_cb_t func, void *arg); 示例 1234#include &lt;netlink/socket.h&gt;// 对套接字 sk 接收到的所有有效的消息都调用 my_input() 函数nl_socket_set_cb(sk, NL_CB_VALID, NL_CB_CUSTOM, my_input, NULL); 3.5. 套接字属性 本地端口号 本地端口唯一的标识了一个套接字的同时也被用来在寻址的时候锁定该套接字。一个本地端 口号是在分配套接字的时候自动生成的。它由进程ID（22位）和一个随机数（10位）组合而 成，所以每个进程可以使用1024个套接字。 1234#include &lt;netlink/socket.h&gt;uint32_t nl_socket_get_local_port(const struct nl_sock *sk);void nl_socket_set_local_port(struct nl_sock *sk, uint32_t port); 关于端口号的更多的信息，请查看 寻址 一节。 注意： 你可以重新设置端口，但是你必须要保证你提供的值是唯一的，此外你还需要 保证没有其他的应用程序的套接字使用了这个值。 对等端口 一个套接字可以设置一个对等端口，这将会导致所有通过这个套接字发送的单播消息都会发 送到这个对等节点。如果没有设置对等节点，消息会被发送到内核，而内核会自动尝试把这 个套接字和内核里面同一个 netlink 协议簇下的套接字绑定在一起。人们通常不会把套接 字绑定到一个对等端口，因为通常一个在同一个 netlink 协议簇中只存在一个内核端套接 字。 1234#include &lt;netlink/socket.h&gt;uint32_t nl_socket_get_peer_port(const struct nl_sock *sk)void nl_socket_set_peer_port(struct nl_sock *sk, uint32_t port); 关于端口号的更多的信息，请查看 寻址 一节。 文件描述符 Netlink 使用的是 BSD 套接字的接口，所以在每个套接字背后都有一个你可以直接使用的 文件描述符。 123#include &lt;netlink/socket.h&gt;int nl_socket_get_fd(const struct nl_sock *sk); 如果一个套接字只是用来接收通知消息的，那么最好把它设置成非阻塞模式，然后周期性的 轮询新的通知消息。 123#include &lt;netlink/socket.h&gt;int nl_socket_set_nonblocking(const struct nl_sock *sk); 发送和接收缓存区大小 套接字的缓冲区被用来在发送方和接收方之间充当 netlink 消息队列。这个缓冲区的大小 决定了你可以调用 write() 函数向 netlink 套接字写入的最大长度，也就是说它间接的定 义了最大消息的长度。这个缓冲区的默认大小是 32KiB。 123#include &lt;netlink/socket.h&gt;int nl_socket_set_buffer_size(struct nl_sock *sk, int rx, int tx); Enable/Disable Credentials TODO [^2] 123#include &lt;netlink/socket.h&gt;int nl_socket_set_passcred(struct nl_sock *sk, int state); 启用/禁用 Auto-ACK 模式 下面的这些函数可以用来在一个套接字中启用或是禁用 Auto-Ack 模式。关于这个模式的 含义的详细信息请参考 Auto-Ack 模式 一节。Auto-Ack 模式是默认 开启的。 1234#include &lt;netlink/socket.h&gt;void nl_socket_enable_auto_ack(struct nl_sock *sk);void nl_socket_disable_auto_ack(struct nl_sock *sk); 启用/禁用消息窥视 如果启用了消息窥视功能，nl_rcv() 函数将会尝试使用 MSG_PEEK 来读取收到的下一 个消息的大小，并分配一个同样大小的缓存区。消息窥视功能是默认启用的但你可以使用下 面的函数禁用它： 1234#include &lt;netlink/socket.h&gt;void nl_socket_enable_msg_peek(struct nl_sock *sk);void nl_socket_disable_msg_peek(struct nl_sock *sk); 启用/禁用数据包信息的接收 如果这项功能启用了的话，从内核中收到的每一条 netlink 消息都会在控制消息中额外包 含一个 struct nl_pkinfo 结构体。下面这些函数可以用来启用或禁用数据包信息的接收 。 123#include &lt;netlink/socket.h&gt;int nl_socket_recv_pktinfo(struct nl_sock *sk, int state); 注意： NETLINK_PKINFO 的处理目前还没有实现。 [^1]: 这篇文章中的套接字基本上都是指 libnl 库中的套接字结构体 struct nl_sock 而不是BSD 套接字接口中的套接字概念。 [^2]: 在原文中这一段没有任何内容只有标题和下面的函数，所以很难判断这个函数的作用，个人也没有相关的知识背景所以没有翻译标题。「译者注」]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第二部分]]></title>
    <url>%2F2015%2F01%2F23%2Flibnl-translation-part2%2F</url>
    <content type="text"><![CDATA[2. Netlink 协议基础 Netlink 协议是基于套接字的进程间通信（IPC）机制，它可用于用户空间进程和内核之间 或者用户空间进程之间的通信。Netlink 协议基于 BSD 套接字并使用 AF_NETLINK 地址簇。 每一个 Netlink 协议都有自己的协议号（比如：NETLINK_ROUTE，NETLINK_NETFILTER， 等等）。它的寻址方案是基于 32 位的端口号（之前被称为 PID），这个端口号用来唯一的 标识每一个对等通信节点。 2.1. 寻址 Netlink 地址（端口）由一个 32 位的整数组成。端口（port）零保留给内核使用，代表每 个 Netlink 协议簇中内核部分的套接字。虽然不是强制规定，其他的端口则通常指的是用 户空间的套接字。 注意： 一开始，我们通常都是使用进程标识符（PID）作为本地端口号。这种方式随着 线程化的 netlink 应用程序的引入而失效，因为这种进程需要多个套接字。因此 libnl 以进程标识符为基数再加上一个偏移量的来生成唯一的端口号，这种方式可以让一个进程 使用多个套接字。出于向后兼容方面的考虑，第一个套接字还是以进程标识符作为端口号。 上面这幅图中用户空间有三个应用程序，而内核空间则存在两个套接字。这幅图展示了 netlink 的常见的应用场景： 用户空间和内核之间通信 用户空间之间通信 监听内核的多播通知 用户空间和内核之间的通信 Netlink 最常见的应用场景就是用户空间的应用程序发送请求给内核，然后处理内核返回的 信息，这个回复信息要么是请求出错的信息，要么就是请求成功的通知信息。 App1 App2 App3 | | | | request(src=11,dst=0) | +--------------------+------------------------&gt; | | | | reply(src=0,dst=11) | &lt;--------------------+------------------------+ | | | | | | | | | | | request(src=21,dst=0) | | +------------------------&gt; | | | | | reply(src=0,dst=21) | | &lt;------------------------+ | | | | | | 用户空间之间通信 Netlink 也可以直接作为用户空间应用程序之间的进程间通信机制。这种通信并不限制在两 个对等通信节点之间，任意一个节点都可以和其他的对等点进行通信。此外因为 Netlink 支持多播，一条消息可以由多个节点同时接收到。 为了让套接字对通信双方可见，这两个套接字必须在同一个 netlink 协议簇下创建。 App2 App3 | | | request(src=22,dst=31) | +---------------------------------------&gt; | | | reply(src=31,dst=22) | &lt;---------------------------------------+ | | | | 监听内核的通知信息 这一类 netlink 通信的典型使用者是用户空间那些需要处理特定内核事件的的守护进程。 这些守护进程通常会订阅内核使用的某个多播组，内核则在某些事件发生的时候通过它来 通知那部分订阅过该组的进程。 Kernel App3 | | | notification(src=0,group=foo) | +--------------------------------------&gt; | | | | | | 相对于直接寻址来说，使用多播是一个更好的方式，因为它有更高的灵活性。我们可以在不 通知内核的情况下随时更改用户空间的相关组件。 2.2. 消息格式 一个 Netlink 协议通常是基于消息的，消息则通常是由 netlink 消息头部（struct nlmsghdr）加上有效载荷组成。虽然有效载荷可以由任何数据组成，但是它通常的格式是一 个固定大小的协议相关头部后面紧跟一系列的属性。 Netlink 消息头部（struct nlmsghdr） 总长度（32 位） 消息包括 netlink 消息头部在内的总字节数 消息类型（16 位） 消息类型指明了消息的有效载荷的类型。netlink 协议定义了多个标准的消息类型。每个协 议簇都可能定义了额外的消息类型。详细信息请参考 消息类型 一节。 消息标志（16 位） 消息标志可以用来更改消息类型的行为。标准消息标志列表请参见 消息标志 一节。 序列号（32 位） 序列号的使用是可选的，它可以用来引用前一条消息。比如一条错误消息中可以引用导致错 误的那条请求消息。 端口号 端口号指明了这条消息需要发往哪个对等节点。如果没有指定端口号，那么这条消息会被投 递给同一个协议簇中第一个匹配的内核端套接字。 2.3. 消息类型 Netlink 在请求消息（requests）、通知消息（notifications）和应答消息（replies）的 处理上是有区别的。请求消息设有 NLM_F_REQUEST 标志位，它用来向接收方请求某种响应 。一般来说请求消息都是从用户空间发送到内核的。虽然不是强制规定，但每次发送的请求 消息序列号都应该是上一个序列号加一。 由于请求自身的特性，接收方在收到请求消息之后可能会发送另一条 netlink 消息来响应 这个请求。应答消息的序列号必须和它响应的那条请求消息的序列号一致。 通知消息则没有那么严谨，它不需要应答，所以序列号通常是被设置成 0 的。 A B | | | GET(seq=1,NLM_F_REQUEST) | +-------------------------------------&gt; | | | PUT(seq=1) | &lt;-------------------------------------+ | | . . . . | NOTIFY(seq=0) | &lt;-------------------------------------+ | | 消息的类型主要是由消息头部中 16 位的消息类型字段确定的。Netlink 定义了下面这些标 准的消息类型： NLMSG_NOOP - 无需任何操作，消息必须被丢弃 NLMSG_ERROR - 错误消息或者是 ACK，参考 错误消息 和 ACKs 这两个小节 NLMSG_DONE - 分段序列的结束，参考 分段消息 一节 NLMSG_OVERRUN - 通知信息越界（错误）[Overrun notification] 每个 netlink 协议都可以自由的定义自己的消息类型。需要注意的是小于 NLMSG_MIN_TYPE(0x10) 的类型是保留的，所以不能使用。 通常我们会定义自己的消息类型来实现 RPC 模式。假设你的 netlink 协议的目的是允许你 配置一个网络设备的某些部分，所以你想要提供各种配置选项的读/写访问。完成这项任务 典型的 “netlik 解决方案” 是定义两种消息类型 MSG_SETCFG，MSG_GETCFG： #define MSG_SETCFG 0x11 #define MSG_GETCFG 0x12 发送一条 MSG_GETCFG 请求消息通常会收到一条包含当前配置信息的类型为 MSG_SETCFG 的应答消息。用面向对象的术语来说这叫做“内核在用户空间设置了配置信息 的本地拷贝” A B | | | MSG_GETCFG(seq=1,NLM_F_REQUEST) | +-------------------------------------&gt; | | | MSG_SETCFG(seq=1) | &lt;-------------------------------------+ | | 配置信息可以通过发送一条 MSG_SETCFG 信息来更改，这条消息会收到一条 ACK 响应信息 （参考 ACKs 一节）或是一条错误信息（参考 错误消息 一节）。 A B | | | MSG_SETCFG(seq=1,NLM_F_REQUEST,NLM_F_ACK) | +-------------------------------------------&gt; | | | ACK(seq=1) | &lt;-------------------------------------------+ | | | | 此外，内核也可以在配置信息发生改变的时候发送通知信息，这样用户空间应用程序就可以 使用监听而不是频繁轮询的方式来获取改变信息。通知消息通常是使用目前已有的消息类型 这就需要应用程序使用不同的套接字处理请求消息和通知消息，当然你也可以使用特殊的消 息类型来单独表示通知信息。 A B | MSG_SETCFG(seq=0) | &lt;-----------------------------+ | | 2.3.1 分段式消息 虽然理论上一条 netlink 消息的最大长度是 4GiB，套接字的缓冲区一般不太可能有这么大 的空间来容纳这么长的消息。所以通常情况下，消息的长度被限制在页的大小（PAGE_SIZE ）之内，然后通过使用分段机制把大的数据切分成多个消息。分段式消息设有 NLM_F_MULTI 标志位，接收者需要不断的接收和解析消息直到收到一个消息类型为 NLMSG_DONE 的特殊消 息为止。 和分片之后的 ip 包不一样的是分段之后的消息不需要重新组合，不过如果协议需要这么做 的话，重组当然也是完全合法的。分段式消息经常会被用来发送对象列表或者是对象树，这 种情况下消息段只是简单的承载几个对象，这也就允许每个消息段被单独处理。 A B | | | GET(seq=1,NLM_F_REQUEST) | +--------------------------------&gt; | | | PUT(seq=1,NLM_F_MULTI) | &lt;--------------------------------+ | | . . . . | PUT(seq=1,NLM_F_MULTI) | &lt;--------------------------------+ | | | NLMSG_DONE(seq=1) | &lt;--------------------------------+ | | | | 2.3.2 错误消息 错误消息可以作为请求消息的响应发送出去，错误消息必须使用标准的消息类型 NLMSG_ERROR，它的有效载荷是由错误码和原来的请求消息头部组成。 错误消息的序列号必须是导致错误发生的请求消息的序列号。 2.3.3 ACKs 发送方可以通过设置 NLM_F_ACK 标志位来要求接收方为处理过的每一个请求消息都发送一 个 ACK 消息。这种方式通常是用来让发送方在请求被接收方处理之后同步下一步的操作。 ACK 消息和错误消息使用一样的消息类型（NLMSG_ERROR）和负荷格式，不同的是 ACK 消息 的错误代码被设置为 0。 2.3.4 消息标志 标准的消息标志包括下面这些： #define NLM_F_REQUEST 1 #define NLM_F_MUL 2 #define NLM_F_ACK 4 #define NLM_F_ECHO 8 NLM_F_REQUEST - 这个消息是请求消息，参考 消息类型 一节。 NLM_F_MULTI - 这个消息是分段式消息，参考 分段式消息 一节。 NLM_F_ACK - 请求了 ACK 回复，参考 ACKs 一节。 NLM_F_ECHO - 请求回应这个请求消息。 NLM_F_ECHO 标志和 NLM_F_ACK 标志类似，它可以和 NLM_F_REQUEST 标志位一起使 用，使得发送者能够收到作为这条请求消息的响应而产生的通知信息，无论发送者是否订阅 过相应的多播组。参考 多播组 一小节。 对于 GET 请求还定义了一些额外的通用标志位： #define NLM_F_ROOT 0x100 #define NLM_F_MATCH 0x200 #define NLM_F_ATOMIC 0x400 #define NLM_F_DUMP (NLM_F_ROOT|NLM_F_MATCH) NLM_F_ROOT - 返回树的根节点。 NLM_F_MATCH - 返回所有匹配的节点。 NLM_F_ATOMIC - 已废弃，以前用来请求一个原子操作 NLM_F_DUMP - 返回一个含有所有对象的列表（NLM_F_ROOT|NLM_F_MATCH） 这些标志的使用是完全可选的，许多 netlink 协议都只使用 NLM_F_DUMP 标志。这个标 志通常用来请求接收者发送一个包含所有对象的列表，而这个列表则通常是一系列的消息断 （参考分段式消息一节）。 还有一些和 NEW 或者是 SET 请求相关的标志。这些标志和 GET 的那些标志是彼此互斥的 ： #define NLM_F_REPLACE 0x100 #define NLM_F_EXCL 0x200 #define NLM_F_CREATE 0x400 #define NLM_F_APPEND 0x800 NLM_F_REPLACE - 如果对象存在的话，替换它。 NLM_F_EXCL - 如果这个对象存在的话，就不用更新它。 NLM_F_CREATE - 如果对象不存在的话，创建它。 NLM_F_APPEND - 在对象列表的末尾添加新的对象。 这些标志含义在不同的 netlink 协议中可能会有细微的差别。 2.4. 序列号 Netlink 允许通过序列号来关联回复和请求。需要注意的是，这里的序列号和 TCP 这类的 协议的序列号是不一样的，Netlink 的序列号并不强制使用。序列号唯一的用途就是把一条 应答消息和相应的请求消息联系起来。更多信息详见 消息类型 一节。 序列号是以单个套接字为基础来管理的，关于如何使用序列号，请参考第三章中的 序列号 一小节。 2.5. 多播组 TODO 参考 多播组订阅 一节。]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netlink 库 -- 官方开发者教程中文版第一部分]]></title>
    <url>%2F2015%2F01%2F20%2Flibnl-translation-part1%2F</url>
    <content type="text"><![CDATA[1. 引言 核心库（core library）提供了使用 netlink 套接字进行通信的基础功能。它处理套接 字的连接建立和断开、发送和接收数据、构造和解析消息、提供可配置的接收状态机。除此 之外它还提供了一套抽象数据类型的框架，这套框架使得基于对象的 netlink 协议实现 起来更加的简单，在这种协议中，对象可以通过基于 netlink 的协议来添加、删除、 或者修改。 库的层次结构 这工程被分割成了下面几个库： Netlink Library(libnl) 套接字的处理、发送和接收数据、消息的构造和解析、…… Routing Family Library(libnl-route) 地址、链路、邻居节点、路由、流量控制、邻居节点表、…… Netfilter Library(libnl-nf) 连接追踪、记录日志、排队（queueing） Generice Netlink Library(libnl-genl) 控制器的 API，协议簇（family）和命令的注册 1.1. 如何阅读这份文档 这些库提供了大量的 API，通常大部分的应用程序都只需要用到其中的一小部分。有些用户 可能只会关心低层（low level）的 netlink 消息处理 API，而其他用户可能主要使用高层 （high level）的 API，这些主要依赖于你的应用程序的类型。 无论你是属于那种情况，我们都推荐你首先熟悉下 netlink 协议。 Netlink 协议基础 低层 API 在下面两部分中有详细介绍： Netlink 套接字 发送和接收消息/数据 1.2. 如何链接到这个库 使用 autoconf 检查库是否存在 那些使用 autoconf 的项目可以使用 PKG_CHECK_MODULES() 来检测系统中是否存在某个特定 版本的 libnl。下面这个例子同时也展示了如何取得链接到 libnl 库所需要的 CFLAGS 和 链接依赖。 下面这个例子展示 了如何检查特定版本的 libnl 是否存在。如果存在，这个例子也展示了 如何正确的扩展 CFLAGS 和 LIBS 变量： 12345PKG_CHECK_MODULES(LIBNL3,libnl3-3.0&gt;=3.1,[have_libnl3]=yes,[have_libnl3=no])if (test "$(have_libnl3)"="yes"); then CFLAGS+="$(LIBNL3_CFLAGS)" LIBS+="$(LIBNL3_LIBS)"fi 注意： pkgconfig 被命名成 libnl-3.0.pc 是遗留问题，它实际上也包含了版本号大于 3.1 的库。 头文件 需要包含的头文件主要是 &lt;netlink/netlink.h&gt; 这个文件。根据你使用的子系统和组件的 不同，你可能还需要在你头文件中添加一些额外的头文件。 123#include &lt;netlink/netlinl.h&gt;#include &lt;netlink/cache.h&gt;#include &lt;netlink/route/link.h&gt; 依赖于版本号的代码 如果你希望能在你的代码中链接 libnl 的多个版本，你可以让编译器根据你想要链接的 libnl 库的特定版本来编译你代码中包含的特定部分的代码。 12345#include &lt;netlink/version.h&gt;#if LIBNL_VER_NUM &gt;= LIBNL_VER(3.1) /* include code if compiled with libnl version &gt;= 3.1 */#end if 链接 1$gcc myprogram.c -o myprogram $(pkgconfig --cflags --libs libnl-3.0) 1.3. 调试 这个库在编译的时候包含了调试语句，这使得它可以在你把 NLDBG 这个环境变量的值设置为 0 的值的时候往 stderr 中打印调试信息。 1$ NLDBG=2 ./myprogram 表 1. 调试级别 级别 描述 0 关闭调试 (默认) 1 警告信息、重要的事件和通知信息 2 多一些更不重要的信息 3 导致调试信息刷屏重复性事件 4 比上面的信息还更不重要的消息 Netlink 协议的调试 通常查看套接字之间交换的 netlink 消息流是非常有用的。把环境变量 NLCB 的值设置为 debug（NLCB=debug）可以运行调试消息处理器，它会把交换的 netlink 消息打印成易于 我们阅读的格式并输出到 stderr 上。 $ NLCB=debug ./myprogram -- Debug: Sent Message: -------------------------- BEGIN NETLINK MESSAGE --------------------------- [HEADER] 16 octets .nlmsg_len = 20 .nlmsg_type = 18 &amp;lt;route/link::get&amp;gt; .nlmsg_flags = 773 &amp;lt;REQUEST,ACK,ROOT,MATCH&amp;gt; .nlmsg_seq = 1301410712 .nlmsg_pid = 20014 [PAYLOAD] 16 octets 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ --------------------------- END NETLINK MESSAGE --------------------------- -- Debug: Received Message: -------------------------- BEGIN NETLINK MESSAGE --------------------------- [HEADER] 16 octets .nlmsg_len = 996 .nlmsg_type = 16 &amp;lt;route/link::new&amp;gt; .nlmsg_flags = 2 &amp;lt;MULTI&amp;gt; .nlmsg_seq = 1301410712 .nlmsg_pid = 20014 [PAYLOAD] 16 octets 00 00 04 03 01 00 00 00 49 00 01 00 00 00 00 00 ........I....... [ATTR 03] 3 octets 6c 6f 00 lo. [PADDING] 1 octets 00 . [ATTR 13] 4 octets 00 00 00 00 .... [ATTR 16] 1 octets 00 . [PADDING] 3 octets 00 00 00 ... [ATTR 17] 1 octets 00 . [...] --------------------------- END NETLINK MESSAGE ---------------------------]]></content>
      <tags>
        <tag>netlink</tag>
        <tag>libnl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket API 实现（五）—— connect 函数]]></title>
    <url>%2F2014%2F10%2F30%2Fsocket-connect%2F</url>
    <content type="text"><![CDATA[概述通常在 CS 通信模式中，服务端通过 socket-&gt;bind-&gt;listen-&gt;accept 流程开始监听客户 端的连接。而在客户端则是通过 socket-&gt;connect 流程来建立和服务端的连接。我们在 前面的文章中已经分析过服务器端使用到的 4 个 API，这篇文章开始我们将会分析客户端 用到的 API。 首先要分析的第一个 API 是 connect，因为客户端创建 socket 的函数和服务端是一个 样的，都是使用 socket 函数。connect 函数的原型如下： 1int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 其中 sockfd 是客户端建立的 socket，addr 参数是服务端的地址，addrlen 则是服 务端地址的长度。下面分析 connect API 的具体实现。 图解下图是 connect 函数的函数调用关系图，这里之列出重要的函数，其中带有 * 表示是 通过函数指针间接引用 详细说明connect API 的实现可能是目前位置见过最复杂的，因为前面的 API 无论是 socket, bind, listen 还是 accept 基本生都是只涉及到本机的数据结构设置。而 connect API 的实现则涉及到服务器端和客户端的通信，也就是 3 次握手的具体实现。涉及到数据发送 则不可避免的涉及到 IP 层的相关处理，因此内容非常的多。 这篇文章主要讲解 connect 的实现逻辑，至于涉及到的 3 次握手的具体实现和 IP 层处 理在后面的文章中再讲解。 哈希表 —— 在 socket API 实现（二）—— bind 函数 一文中我们提到在内核中有一个哈希 结构包含三个不同的哈希表用来索引不同的状态的 sock 结构，这个哈希结构就是 inet_hashinfo。它包含的三个哈希表中，bhash 用来存放绑定了本地地址的 sock， listening_hash 用来存放处于监听状态 sock 结构，而 TCP_ESTABLISHED &lt;= sk-&gt;sk_state &lt; TCP_CLOSE 的 sock 就是存放在最后一个哈希表 ehash 中。 在上图的 inet_hash_connect 函数有两个功能，第一个就是给 socket 分配端口，这个 我们在 socket API 实现（二）—— bind 函数 一文的 “端口选择” 一节中有提 到具体的方法。第二个功能就是把这个 sock 加入到 ehash 哈希表中。 SYN 包的构建和发送connect 函数开始了三次握手中的第一次握手，也就是 SYN 包的发送，这个工作是 tcp_connect 完成的。它主要完成以下几件事情： 调用 alloc_skb_fclone 分配新的包的空间。任何数据包都是通过 sk_buff 结构 来表示的，通常我们称之为 SKB，alloc_skb_fclone 的空间分配其实也是分为两部 分的：分配 sk_buff 本身的结构体信息，它相当于是这个数据断的元数据（meta）也 就是数据的描述和控制信息；分配 data 空间，用于存放具体的数据（其实还包括一个 skb_shared_info 的空间，暂时不知道它的作用是什么）。 初始化各类控制信息。主要是调用 tcp_init_nondata_skb 初始化 TCP_SKB_CB 中的 字段以及在 sock 中的相关字段。 调用 __tcp_add_write_queue_tail 把 SYN 包放入到 sock 的发送队列中去，也就 是 sk_write_queue 队列。 调用 tcp_transmit_skb 把数据发送出去。 等待链接和 socket API 实现（四）—— accept 函数 中提到的 accept 函数一样，其 实 connect 函数需要等待连接完成。因为连接的建立中间涉及到 3 次握手的完成，所以 connect 函数并不会在发送完成 SYN 包之后就立即返回，而是调用 inet_wait_for_connect 函数进入等待状态。和 socket API 实现（四）—— accept 函 数 中提到的 accept 一样，当前进程会进入 sk-&gt;sk_sleep 这个等待队列 等待连接建立完成，不同的是对于 accept 来说 sk-&gt;sk_sleep 里面的进程在等待连接的 到来，而对于 connect 来说 sk-&gt;sk_sleep 中的进程等待连接的完成。对于同一个 socket 来说这两个状态不可能同时出现（不可能在 connect 的同时会 accept），所以使 用同一个等待队列不会出现问题。关于这个等待队列的初始化可以查看 socket API 实现 （四）—— accept 函数 一文的等待队列一小节。]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket API 实现（四）—— accept 函数]]></title>
    <url>%2F2014%2F10%2F29%2Fsocket-accept%2F</url>
    <content type="text"><![CDATA[注：本文基于 2.6.32 版本的内核 概述正常的 socket 编程函数调用顺序一般是 socket -&gt; bind -&gt; listen -&gt; accept。我们在前面的文章中分析了前面三个函数，现在我们分析第四个函数 accept。 1accept(server_fd, (struct sockaddr *))&amp;client_addr, client_len); 这个函数在 socket 开始监听之后调用，如果成功接受链接请求，则返回新的客户端 socket 文件描述符，并把客户端的地址放入到 client_addr 表示的地址中去。 我们将在这篇博文中详细的讲解 accept 函数在内核内部的处理流程。 图解按照惯例，我们首先给出函数调用关系的图解，带 * 表示这个函数是通过函数指针简介引用： 重点函数说明accept 实际使用到系统调用是 sys_accept4，它首先创建一个新的 socket 结构（ sock_alloc）以及 file 结构和新的文件描述符（sock_alloc_fd），之后设置 socket 结构和 file 结构的相互引用（sock_attach_fd）。在函数的最后调用 fd_install 使 得 fd 绑定 file 结构。这些函数的功能在 socket API 实现（一）—— socket 函数 一文中就已经讲解过了。这里不在重复。 sys_accept4 最主要的操作是调用 inet_accept 进而调用 inet_csk_accept 等待连 接的到来，然后返回新连接的 sock 结构。 等待连接的到来这个操作是通过调用 inet_csk_wait_for_connect 这个函数来完成的， 它使用到的工具就是 “wait queue”。 等待队列“wait queue” 在实现中主要涉及两个结构。wait_queue_head_t 用来代表一个等待队列 以及 wait_queue_t 用来代表一个等待的进程。 在每一个 sock 结构中都有一个 wait_queue_head_t 类型的字段 sk_sleep 用来表示 在这个 sock 上等待事件发生。比如对于服务器的 sock 来说，它等待连接的到来。 sock 中的 sk_sleep 在 sock_init_data 函数（socket API 实现（一）—— socket 函数）中有如下初始化： 1sk-&gt;sk_sleep = &amp;sock-&gt;wait; 也就是说，其实 sock 结构的等待队列其实就是 socket 结构的 wait 字段。而 socket 结构的 wait 字段在 socket 的创建过程函数 sock_alloc_inode 中初始化的： 1234567891011static struct inode *sock_alloc_inode(struct super_block *sb)&#123; struct socket_alloc *ei; ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL); if (!ei) return NULL; init_waitqueue_head(&amp;ei-&gt;socket.wait); &lt;-- return &amp;ei-&gt;vfs_inode;&#125; 在 inet_csk_wait_for_connect 函数中，调用了 prepare_to_wait_exclusive 把当前 的进程加入到 sock 的 sleep 队列中。然后使用 schedule_timeout 来设置超时定时器 。 在系统中会有定时的时间中断，定时器的原来就是通过记录中断次数知道已经过去来多长时 间。关于定时器到更多讲解请参考 《Linux Kernel Development》第三版中的第十一章。 schedule_timeout 最终会在设置定时器之后调用 schedule 函数选择其他的进程运行 ，而当前的进程则会进入睡眠。这也是为什么我在函数调用图的中间插入了一条分割线的原 因。 连接队列我们在 socket API 实现（三）—— listen 函数 一文中有提到过， listen 会创建 sock 的连接队列，它分为全连接队列和半连接队列。当连接建立好了之后 半连接状态到 request_sock 就会被移到全连接队列中。对于 tcp_sock 来说，这个连 接队列是 inet_connection_sock 的 icsk_accept_queue 字段，它是 request_sock_queue 类型，其定义如下： 123456struct request_sock_queue &#123; struct request_sock *rskq_accept_head; struct request_sock *rskq_accept_tail; ...... struct listen_sock *listen_opt;&#125;; rskq_accept_head 就是全连接队列到头部，而 listen_opt 是管理半连接状态请求的 结构。如果连接建立成功，一个连接请求将会从 listen_opt 的相关字段中移到 rskq_accept_head 指向的队列中。 在 accept 的函数调用图中的 reqsk_queue_get_child 函数就是在有连接到来（ rskq_accept_head 队列不空）之后从全连接队列中取出一个连接请求 request_sock， 其定义如下： 123456struct request_sock &#123; struct request_sock *dl_next; /* Must be first member! */ ...... struct sock *sk; ......&#125;; 这个结构体中的 dl_next 字段用来链接所有的请求，而代表单个请求的 sock 结构放在 sk 字段中。这个字段最终会被当成返回值传递给 inet_accept 函数，并通过 sock_graft 函数设置好新的 socket 和新的 sock 结构之间到相互引用关系。 地址设置最终函数返回到 sys_accept4 中，调用 inet_getname 得到地址，其实也就是读取 sock 结构中的相应值而已。读取完地址之后通过 move_addr_to_user 把地址返回到用户 空间。 总结其实 accept 的作用就是有新的客户端连接到来的时候创建一个新的 socket 而已。 sys_accept4 首先创建好 socket 结构，file 结构，并分配好文件描述符。之后获 取 socket 结构对应的 sock 结构。形成一个完整的 socket 结构之后把 socket 文件 描述符返回用户空间，这样服务器就可以通过这个新的 socket 和客户端进行通信了。]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket API 实现（三）—— listen 函数]]></title>
    <url>%2F2014%2F10%2F27%2Fsocket-listen%2F</url>
    <content type="text"><![CDATA[概述前两篇文章中，我们已经分析了 socket API 中用来创建 socket 的 socket 函数和用来 绑定地址的 bind 函数。正常到服务器程序在地址绑定之后就会在这个地址上开始监听等 待链接，这一工作可以调用 listen 函数来完成，代码如下： 1listen(server_fd, 10); 这篇文章将要分析上面这条语句在内核中的具体实现流程。 图解和前面的文章一样，我们首先看看函数调用关系的图解。带 * 的函数表示是通过函数指 针引用而不是直接调用 listen 函数到逻辑比 socket 和 bind 到函数逻辑要简单许多。 sockfd_lookup_light 函数在 bind 函数到讲解中提到过，这里不再重复。如果你不是 了解其中到机制，可以参考我的另外两篇文章 socket API 实现（一）—— socket 函数 和 socket API 实现（二）—— bind 函数。 这篇文章将会重点讲解 inet_listen 函数和 socket 中和监听相关的数据结构。 连接请求队列连接请求队列分为半连接队列和全链接队列，这两个队列处于同一个结构体中，也就是 request_sock_quue inet_connection_sock 结构的 icsk_accept_queue 字段就是这 个类型，用来存储一个 sock 的连接请求。request_sock_quue 的结构定义如下： 12345678struct request_sock_queue &#123; struct request_sock *rskq_accept_head; struct request_sock *rskq_accept_tail; rwlock_t syn_wait_lock; u8 rskq_defer_accept; /* 3 bytes hole, try to pack */ struct listen_sock *listen_opt;&#125;; 其中前面两个字段用来全连接队列，而最后一个字段用来存储半连接队列。全连接队列是随 着连接请求不断到来并且被处理之后才逐步建立起来的。半连接队列则在 listen 函数中 创建，因为 listen 的第二个参数 backlog 指定了同时允许的最大半连接状态的连接 数，也就确定了半连接队列的长度，比如 listen(fd, 10) 中的 10。 在 inet_listen 中调用了 reqsk_queue_alloc 函数创建 sock 的半连接队列，也就是 分配和初始化 listen_sock 结构空间。代码如下： 12345678910111213size_t lopt_size = sizeof(struct listen_sock);struct listen_sock *lopt;nr_table_entries = min_t(u32, nr_table_entries, sysctl_max_syn_backlog);nr_table_entries = max_t(u32, nr_table_entries, 8);nr_table_entries = roundup_pow_of_two(nr_table_entries + 1);lopt_size += nr_table_entries * sizeof(struct request_sock *);if (lopt_size &gt; PAGE_SIZE) lopt = __vmalloc(lopt_size, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);else lopt = kzalloc(lopt_size, GFP_KERNEL); 这段代码比较的晦涩，主要是因为 listen_sock 结构的定义非常的灵活： 12345struct listen_sock &#123; ...... u32 nr_table_entries; struct request_sock *syn_table[0];&#125;; 在结构体定义到末尾有一个零长数组，当我们分配的空间大于 sizeof(struct listen_sock) 的时候，syn_table 字段会指向超出结构体大小空间的第一个字节。关于 零长数组到更多介绍，可以参考我写的另外一片文章 C 语言的趣味用法。 在上面到空间分配代码中，lopt_size 首先是 sizeof(struct listen_sock) 因为在 request_sock_queue 中表示半连接队列的 listen_opt 是一个指针，它到空间我们也 许要分配。之后 lopt_size += nr_table_entries * sizeof(struct request_sock *); 表示在 listen_sock 空间之后还有额外的 nr_table_entries * sizeof(struct request_sock *) 空间，也就是我们前面提到的 syn_table 指向的空间。 从这段空间到分配我们可以看出，每一个连接请求都是一个 requset_sock 结构，半连接 状态的 request_sock 的指针存放在 syn_table 中，这种连接请求最都有 nr_table_entries 个。它的最大值由下面三个中的最小值决定：参数 backlog， sysctl_max_syn_backlog 变量， sock_net(sock-&gt;sk)-&gt;core.sysctl_somaxconn。其 中 backlog 和 somaxconn 的比较在 sys_listen 中就已经完成并把较小的一个作为 参数传递给了 reqsk_queue_alloc。剩下两个的比较则在前面的分配代码中完成。 分配空间之后 sock 的内存空间结构大致如下： reqsk_queue_alloc 函数的主要工作就是分配上图中 listen_sock 的结构空间。 端口重用在 inet_listen_start 中会调用 inet_csk_get_port 函数。这看起来不可思议，因为 端口绑定的工作是在 bind 函数中进行的，inet_csk_get_port 函数我们在 socket API 实现（二）—— bind 函数 一文中已经提过，这里不再解释它的代码。我 看过的资料大部分都说这里调用 inet_csk_get_port 是为了检查是否绑定了端口，是否 端口占用等等。个人认为这些说法都有失偏颇。 其实这里调用 inet_listen_start 主要是有两个作用。第一如果没有绑定端口，那么先 进行端口绑定，如果绑定了端口则需要更改 inet_bind_bucket 中的 fastreuse 字段 ，把他设置成否定值。这个字段的作用我们在socket API 实现（二）—— bind 函数 一文中已经解释过，在 inet_csk_start_listen 中设置了 sock_state 为 TCP_LISTEN 状态，这就使得端口可重用的第二个判断条件不成立了，也就是说 fastreuse 字段失效。调用 inet_csk_get_port 函数可以让可重用再次得到修正。以 下是简化的代码： 12345678910111213141516171819202122232425262728if (!snum) &#123; ......&#125; else &#123; ...... inet_bind_bucket_for_each(tb, node, &amp;head-&gt;chain) if (ib_net(tb) == net &amp;&amp; tb-&gt;port == snum) goto tb_found; (1)&#125;tb_found: (2)if (!hlist_empty(&amp;tb-&gt;owners)) &#123; if (... &amp;&amp; sk-&gt;sk_state != TCP_LISTEN ) &#123; ...... &#125; else &#123; if (inet_csk(sk)-&gt;icsk_af_ops-&gt;bind_conflict(sk, tb)) &#123; (3) ...... &#125; &#125;&#125;if (!tb &amp;&amp; ...) == NULL) ......if (hlist_empty(&amp;tb-&gt;owners)) &#123; ....&#125; else if (tb-&gt;fastreuse &amp;&amp; (!sk-&gt;sk_reuse || sk-&gt;sk_state == TCP_LISTEN)) tb-&gt;fastreuse = 0; (4) 如果地址已经绑定，那么最开始的判断 !sum 不成立所以执行 else（1）。因为地址已 经绑定了所以可以找到 inet_bind_bucket 结构，跳到 tb_found:（2）。以为已经绑 定地址所以 tb-&gt;owners 不会为空（绑定的时候调用 inet_bind_hash 会把 sk 添加 到 tb-&gt;owners 中），所以接下来的 if 中会判断是否地址冲突，如果之后自己在 owners 队列中的话不会冲突（3）的判断为假不会执行。所以最后的流程到（4）设置 fastreuse 为假。 所以从上面的代码来看， 在 inet_csk_start_listen 中调用 inet_csk_get_port 主 要作用有三点： 如果没有绑定端口，先绑定端口 如果端口已经绑定检查是否有冲突 如果没有冲突把端口可重用的判断标志设置为否 加入监听哈希表在 socket API 实现（二）—— bind 函数 一文中我们说过，为了快速的找 到 sock 结构，内核设置了三个哈希表，这三个哈希表在同一个结构 inet_hashinfo 之 中。和上一篇文章主题——绑定相关的哈希表是 bhash 字段，而和这篇文章的主题——监听 相关的哈希表是 listening_hash 函数调用关系图中的最后一个函数 inet_hash 就是 用来把 sock 加入到 listening_hash 队列中去的。 1234567if (sk-&gt;sk_state != TCP_LISTEN) &#123; __inet_hash_nolisten(sk); return;&#125;ilb = &amp;hashinfo-&gt;listening_hash[inet_sk_listen_hashfn(sk)];__sk_nulls_add_node_rcu(sk, &amp;ilb-&gt;head); 在《追踪 Linux TCP/IP 代码运行》一书的第七章 242 页中分析 __inet_hash_nolisten 的运行显然牛头不对马嘴。因为此时 sk-&gt;sk_state == TCP_LISTEN。这个函数的作用其 实是找打该 sock 对应的哈希桶（ilb），然后把这个 sock 链接到这个哈希桶的哈希链中 。 struct sock 中对应的 sk_nulls_node 字段被用来链接这个哈希链，但是内核的代 码中说是提供给 udp/udp-lite 协议似乎有点误导的嫌疑。 123456789101112* @skc_nulls_node: main hash linkage for UDP/UDP-Lite protocolstruct sock_common &#123; union &#123; struct hlist_node skc_node; struct hlist_nulls_node skc_nulls_node; &#125;;&#125;;struct sock &#123; struct sock_common __sk_common;#define sk_nulls_node __sk_common.skc_nulls_node&#125;; 从上面的代码可以看出 sock 的 sk_nulls_node 来自 sock_common，而 sock_common 对于 skc_nulls_node 的注释说它是提供给 udp/udp-lite 协议使用的 。]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket API 实现（二）—— bind 函数]]></title>
    <url>%2F2014%2F10%2F24%2Fsocket-bind%2F</url>
    <content type="text"><![CDATA[注：本文基于 2.6.32 版本的内核 概述上一篇 文章中说明了使用 socket() 函数创建一个 socket 在内核中 的处理流程。再经过一些来到处理之后，返回 socket 的文件描述符。通常应用程序下一步 调用的函数就是 bind() 比如： 1bind(server_fd, (struct sockaddr*)&amp;server_address, server_len); 那么这一条语句在内核中到处理又是如何呢？我们将在这篇博文中进行分析。和上一篇文章 一样，这篇文章不打算过多的分析代码，而是从总体结构上给出一个较为宏观的图解分析。 图示bind() 函数最终在内核中的函数调用关系如下图所示： 注：上图中带星号的函数表示是通过函数指针间接引用的 sys_bind 调用的前两个函数逻辑非常到简单，如何从文件描述符（fd）得到 socket 结 构我在 socket API 实现（一）—— socket 函数 文章中已经提过，这里 不再赘述。而第二个 move_addr_to_kernel 只是对 copy_form_user 的一次封装。 inet_bind 的函数关系较为复杂，我们在下一小节中分析。 端口绑定一般设置端口分为两种，指定端口和不指定端口。如果指定了端口，则尝试使用这个端口， 如果没有指定则随机分配一个端口。无论是那一种绑定，我们都必须知道这个端口是否能用 。 那么系统如何知道那些端口能用，那些端口不能用呢？这一切都靠一个哈希表的存在—— inet_hashinfo。对于一个 tcp socket 来说，它是定义在 net/ipv4/tcp_ipv4.c 中的全 局变量 tcp_hashinfo。 哈希表inet_hashinfo 里面并不是只包涵一个哈希表，而是三个哈希表的集合。分别是： ehash - 用来索引 TCP_ESTABLISHED &lt;= sk-&gt;sk_state &lt; TCP_CLOSE 的 sock bhash - 用来索引绑定本地地址的 sock listening_hash - 用来索引 sk-&gt;sk_state 为 TCP_LISTEN 状态的 sock 在这三个哈希表中，前面两个是动态分配的，后面一个则是静态分配到数组。它们的创建和 初始化是在 tcp_init() 函数中完成的，而这个函数会在 inet_init() 中调用，后者 则是通过 fs_initcall(inet_init); 调用在编译期间注册到初始化端中，所以会在内核 启动到时候执行。 和我们本文主题相关的就是第二个哈希表 bhash。 inet_hashinfo 中和它相关的字段有 三个： 123struct inet_bind_hashbucket *bhash;unsigned int bhash_size;struct kmem_cache *bind_bucket_cachep; 第一个字段定义哈希表，第二个字段记录哈希表的长度，而第三个字段是一个 SLAB 高速缓 存，作用我们在后面再说。从第一个字段的定义可以知道整个哈希表是一个指针数组。数组 的每一个元素都是一个 inet_bind_hashbuchet 指针。 inet_bind_hashbucket 的定义 如下： 1234struct inet_bind_hashbucket &#123; spinlock_t lock; struct hlist_head chain;&#125;; chain 字段用来链接具有同一哈希值的哈希元素，也就是 inet_bind_bucket。它的定 义如下。 12345678910struct inet_bind_bucket &#123;#ifdef CONFIG_NET_NS struct net *ib_net;#endif unsigned short port; signed short fastreuse; int num_owners; struct hlist_node node; struct hlist_head owners;&#125;; 他们之间通过内部的 node 字段链接起来。而 inet_bind_habuchket 中的 lock 字 段则是用来同步 chain 字段的访问。 inet_bind_bucket 结构就是用来描述端口和 sock 之间的绑定关系的。它的 port 字 段表示一个绑定的端口，而 owners 则表示绑定到这个端口之上的所有 sock，因为端口可 以重用，所以同一端口可能有多个 sock 绑定。 所以这个 bhash 哈希表的结构大概如下： 这张图我们在后续的讲解中会继续用到。 端口的选择我们前面提到，端口绑定分为两种，一个中指定端口，一种者随机选择。如果给 bind 传 递的地址参数中，port 字段为 0，那么就会自动选择参数。步骤如下： 使用 inet_get_local_port_range 取得端口的可用区间（目前是 [32768, 61000] ），随机选择区间内部的一个端口。 找到端口对应的 inet_bind_hashbucket，遍历它的 chain，如果 chain 中没有元 素或者有元素可以重用，把这个随机端口作候选端口为跳转到第 4 步。否则跳转到第 3 步。 递增随机端口，如果随机端口超过上界，返回下界重新开始。同时递减可用端口数量 ，如果可用端口数量为 0 失败返回。否则执行第 2 步。 如果还没有 inet_bind_bucket 那么先调用 inet_bind_bucket_creat 新建一个 结构，新建使用到的缓存就是前面提到的 inet_hashinfo 中的 bind_bucket_cachep 。 调用 inet_bind_hash 绑定端口，也就是设置 inet_bind_bucket 中 port 字段 ，以及 inet_sk(sk) 中的 num 字段，然后把 sk 加入到 inet_bind_bucket 的 owners 队列中。结构可以参考上图。 如果给定了端口，那么直接从上面的第 4 步开始执行。只不过如果 inet_bind_bucket 结构如果已经存在，那么需要检查是否可重用，不可重用的话表示端口冲突，调用 inet_sk(sk) 的 icsk_af_ops 字段中的 bind_conflick 函数处理冲突。这个函数在 sock 建立的时候被初始化为 inet_csk_bind_conflict。关于 sock 的创建可以参考我的 上一篇文章 socket API 实现（一）—— socket 函数。 端口复用关于什么时候能够端口复用，在 /net/ipv4/inet_hashtable.c 中有详细的注释，下面这一 段是从注释中截取下来的。 1) Sockets bound to different interfaces may share a local port. Failing that, goto test 2. 2) If all sockets have sk-&gt;sk_reuse set, and none of them are in TCP_LISTEN state, the port may be shared. Failing that, goto test 3. 3) If all sockets are bound to a specific inet_sk(sk)-&gt;rcv_saddr local address, and none of them are the same, the port may be shared. Failing this, the port cannot be shared. 关于第二点，内核做了优化，为了避免每次都遍历 inet_bind_bucket 的 owners 字段 来获知是否所有的 sock 都设置了 sk_reuse 字段，并且不是在 TCP_LISTEN 状态。在 inet_bind_bucket 结构体中设置了 fastreuse 字段。如果 owners 没有元素，那么这 个字段为真。此后每次添加一个新的 sock 到 owners 中的时候，如果它设置了 sk_reuse 并且不在 TCP_LISTEN 状态，就维持 fastreuse 为真，否则设置它为假。 所以测试一个端口是否可以复用，只需要测试i fastreuse 字段就可以判断上面的第二点 了。 总结经过前面的处理之后，在一个 tcp socket 的 inet_sock 中，设置了以下这些字段： 12345inet-&gt;rev_saddr = inet-&gt;saddr = addr-&gt;sin_addr.s_addr (传递进来的 IP)inet-&gt;num = snum (传递进来的端口)inet-&gt;sport = htons(inet-&gt;num) (转换了字节序的端口)inet-&gt;daddr = 0;inet-&gt;dport = 0; 注意： 在一个 tcp_sock 中包含 inet_sock。他们之间的关系请参考我的上一篇文章 中关于 sock,inet_sock,inet_connetion_sock,tcp_scok 关系的讨论]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket API 实现（一）—— socket 函数]]></title>
    <url>%2F2014%2F10%2F23%2Fsocket-create%2F</url>
    <content type="text"><![CDATA[注：文中使用到内核版本是 2.6.32.63，其他版本可能会有些许出入 概述如果我们在应用程序中创建一个 socket，我们一般使用类似下面这样的语句： 1tcp_scokt = socket(AF_INET, SOCK_STREAM, 0); 那么这条语句在内核的内部到底做了什么呢？这一类到文章和书籍已经非常的多，讲解的也 非常的透彻，所以这篇文章并不想讲解过多的代码，如果你需要了解具体的代码，可以查看 我给出的参考链接[^1][^2]。 参考链接里面的资料为求透彻，基本上都是跟踪代码的运行，通过一层层的函数调用关系来 解析 socket 创建到整个流程。这种做法在虽然在深度上能够让读者有抽丝剥茧的感觉，但 是最终因为代码的复杂性使得读者容易迷失在代码之中。 这篇文章以总结、概括到方式，从数据结构之间的关系和重要的全局变量入手，给大家搭建 一个基本的框架。你可以在阅读完具体的代码之后回过头来看这篇文章，从整体上有个把握 。也可以在阅读代码之前先看看这篇文章从而有一个总体的把握。 图示首先给一张简单到草图，概括 socket 创建到整个流程，这里只列出关键的函数： 在上图中标有 * 号的函数表示不是直接调用，而是通过函数指针间接调用的。 struct socket、struct sock、struct file 的关系在 上一篇 文章中我们提到，socket 它在层次结构上来说是位于 用户程序和内核协议栈之间的一个接口，而在实现上它是一种特殊的文件。 socket 的实现其实非常的复杂，对于不同的层次抽象出了不同的接口和数据结构。对于 socket layer 有 struct socket 这个结构，而对于内核具体的实现则存在 struct sock 这个结构。这两个结构可以说是一个概念的两面，struct socket 结构体很简单，因为它是 开放出来的接口^3，越简单越好；而 struct sock 这个接口则用于具体的协议栈内部内 部实现。它们两个是一一对应的关系，互相引用。在上图中的 sock_init_data 中存在下 面两行代码： 12sk_set_socket(sk, sock);sock-&gt;sk = sk; 其中第一句最终执行的代码是 sk-&gt;sk_socket = sock; 用来使 sock 结构体指向 socket 结构体而第二句的作用是使得 socket 结构体指向 sock结构体。如此一来，它们两者就一 一对应了。 不过 socket 结构不是给用户的接口，对于用户来说 socket 是文件，访问 socket 是通过 文件描述符来完成的。而面向文件系统，表达文件的概念不是 socket 结构而是 struct file 结构。对于 socket 来说，这两个结构也是一一对应的，在上图的 sock_attach_fd 函数中有下面两条语句： 12sock-&gt;file = file;file-&gt;private_data = sock; 第一条语句让 socket 结构体得到对于的 file 结构体的引用，而第二条语句则让 file 结 构保存对 socket 结构体的引用。所以最后的结果是任意给出其中的一者都可以访问到其他 两者。 不过对于用户空间的程序来说， 它们看到的 socket 是一个文件描述符而不是 struct file 结构，这中间还有一层转换。那就是在每个进程的进程描述符中都可以找到文件描述 符 fd 和 struct file 结构体之间的映射表，用不是非常精确的图来表示的话相当于下图 ： 当用户使用文件描述符 fd 来访问 socket 的时候，首先通过查找 fd 到 file 结构的映射 表得到 file 结构，然后通过 file 结构的 private_data 得到 socket 结构，进而可以得 到 sock 结构。在后续的 socket API（比如：bind()，listen()）中都是通过这种方式得 到 sock 结构体的。 sock,inet_sock,inet_connection_sock,tcp_sock在 socket 函数关系调用图中，非常重要的一步是调用 sk_alloc 为 struct socket 结构分配 struct sock 结构空间。但是 sk_alloc 函数分配的其实并不是 struct scok 结构空间而是分配了 strcut tcp_sock 结构的空间。下面这段是具体的代码： 123456789101112131415slab = prot-&gt;slab;if (slab != NULL) &#123; sk = kmem_cache_alloc(slab, priority &amp; ~__GFP_ZERO); if (!sk) return sk; if (priority &amp; __GFP_ZERO) &#123; if (offsetof(struct sock, sk_node.next) != 0) memset(sk, 0, offsetof(struct sock, sk_node.next)); memset(&amp;sk-&gt;sk_node.pprev, 0, prot-&gt;obj_size - offsetof(struct sock, sk_node.pprev)); &#125;&#125;else sk = kmalloc(prot-&gt;obj_size, priority); 从上面这段代码我们可以看出，如果 slab 存在，则用专用的缓存来分配 sock，如果不存 在的话，则在通用缓存中分配 prot-&gt;obj_size 大小的空间作为 sock 的空间。对于 tcp socket 来说。 prot 变量是 tcp_prot，从它的定义中我们可以看到它的 obj_size 字段是 tcp_sock 的大小，初始化代码如下： 1.obj_size = sizeof(struct tcp_sock), 不过，tcp_prot 本身是存在 slab 的，在 inet_init 函数中存在下面这条函数调用： 1rc = proto_register(&amp;tcp_prot, 1); 在 proto_register 中则有如下代码： 123prot-&gt;slab = kmem_cache_create(prot-&gt;name, prot-&gt;obj_size, 0, SLAB_HWCACHE_ALIGN | prot-&gt;slab_flags, NULL); 这段代码用于分配 tcp_prot 结构的 slab 字段缓存，而这个缓存的元素大小还是 obj_size。所以在 sk_alloc 中最后返回的空间大小为 tcp_sock 的大小，而不是 sock 的大小。 但是代码中把 tcp_sock 转换成了 sock 和 inet_sock 指针来进行初始化。之后又 在 tcp_v4_init_sock 中把他转换成 inet_connection_sock 和 tcp_sock 指针进行 初始化。 之所以可以这么做，是因为这几个结构中存在一种包含关系，下面是这几个结构的定义： 12345678910111213141516171819202122 struct sock &#123; struct sock_common __sk_common; ...... &#125;; struct inet_sock &#123; /* sk and pinet6 has to be the first two members of inet_sock */ struct sock sk; ...... &#125; struct inet_connection_sock &#123; /* inet_sock has to be the first member! */ struct inet_sock icsk_inet; ......&#125; struct tcp_sock &#123; /* inet_connection_sock has to be the first member of tcp_sock */ struct inet_connection_sock inet_conn; ......&#125; 可以看到，后面的每一个结构的定义都把前面的结构包含在结构的最开头的位置。这样一来 ，他们直接就形成了一种层次话的关系。这是一种变相的继承方式，可以把一个子类“向上 转型”为父类。个人认为这种方式是 c 语言中实现继承和多态的手法。 在 sk_alloc 中分配一个 tcp_sock 空间之后转换成 sock，inet_sock， inet_connetion_sock 相当于下图： 所以他们之间向上一级进行转换是不会有问题的。 重点的静态全局变量 sock_mnt 这个变量我们在 上一篇 中有提到。在初始化好了 socket 文 件系统之后，最终的挂载点结构 vfsmount 存放在 sock_mnt 这个结构体中。 sys_socket 系统调用的第一步就是分配一个 socket 结构空间，而这个结构就是通过 sock_mnt 来创建的。在 sock_mnt 结构中存放了 socket 文件系统的 super block，而在 super block 中有分配 inode 的函数。对于 socket 文件系统来说， 这个分配函数分配的是 socket_alloc 结构。 sock_alloc 返回的就是这个结构体 的 socket 成员。具体的请查看 上一篇 文章。 net_families 我们给 socket() 函数传递的三个参数其实是层层递进的关系。首先用 domain 指明协 议簇，然后通过第二个参数 type 指明该协议簇下面的协议类型，最后通过第三个参数 protocol 指明这种类型的具体协议。 不同的协议簇在创建 socket 结构的时候使用的方法不一样，为了使得接口统一，抽象 了 net_proto_family 这个结构。它里面有一个指针函数成员 create 用来设置前面 通过 sock_mnt 分配的 socket 结构。 像前面的 fd 和 file 结构的关系一样，socket() 函数提供的 AF_INET 只是一个标 志而已，而不是真正的 net_proto_family 结构。要找到真正的 net_proto_family 则需要通过另一个映射表。这个映射表就是 net_families。它是定义在 net/socktet.c 中的全局变量： 1static const struct net_proto_family *net_families[NPROTO] __read_mostly; 在代码中通过: 1pf = rcu_dereference(net_families[family]); 这行代码，对 net_families 进行下标索引找到我们想要的 struct net_proto_family 结构。而 net_families 中的内容则是在各个协议簇初始化的时 候通过 sock_register 注册进去的。 inetsw 这个全局变量和前面的 net_families 功能可以说是一样的，也是用来做映射，不同 的是 inetsw 的映射是用于第二个参数和第三个参数的。 inetsw 的 “sw” 后缀就是 “switch” 的缩写，从命名上就可以看出它是用来做映射转 换的。 inetsw 是一个数组，每一个 socket type 都会在它里面有一个对应的元素。 不过和 net_families 不同的是，inetsw 中的元素不是唯一确定的，而是一个链表 ，而这个链表就是用于第三个参数的转换了。 在每一个 inetsw 的链表中，而每一个链表成员都是 struct inet_protosw 结构体 。最终通过比较这个结构体的 protocol 字段和传入进来的 protocol 参数来找到最终 的 struct inet_protosw。如果我们使用 socket(AF_INET, SOCK_STREAM, 0); 调 用，经过前面这几次转换之后最终得到的 struct inet_protosw 结构变量是一个描述 tcp 协议的结构体。 struct inet_protosw 也有 “sw” 后缀，因为它本身也相当于一个转换器，不过前面 提到到转换不同的是这里的转换是在 socket layer 和具体实现之间的转换，这个结 构体中有如下两个成员： 12struct proto *prot;const struct proto_ops *ops; 这两个结构体中定义了大量的同名的函数指针，只不过参数不一样。比如 listen 这 个函数，在 struct proto_ops 中的定义是： 123int (*bind)(struct socket *sock, struct sockaddr *myaddr, int sockaddr_len); 而在 struct proto 中的定义是这样: 123int (*bind)(struct sock *sk, struct sockaddr *uaddr, int addr_len); 两个函数函数原型除除了在第一个参数不同之外其他都是一样的。而正是从这个参数的 区别中我们可以看出它们两者在应用范围上的不同。前者使用 struct socket 作为参 数而后者使用 struct sock 作为参数，这说明前者主要是面向 socket layer 的接 口，而后者则是内核协议栈具体实现中的接口。我想这大概也是为什么 struct inet_protosw 为何以 “sw” 结尾的原因。 tcp_prot, inet_stream_ops 前面提到 socket inet_protosw 面向不同的层次提供了两个不同的结构，而对于 tcp 协议来说这两个接口分别是 tcp_proto （面向实现内部）和 inet_stream_ops （ 面向 socket layer）。在 struct socket 结构体的定义中有如下字段： 1const struct proto_ops *ops; 在 inet_create 它被赋值成了 inet_stream_ops （当然这是对于创建 tcp socket 来说）。而在 struct sock 中定义了如下两个字段： 12#define sk_prot __sk_common.skc_protstruct proto *sk_prot_creator; 也就是说 sock 结构体中包含了 proto 相关的字段，这两个字段在 sock 的初始化的时 候都被初始化成了 tcp_prot。 前面的 sk_prot 字段其实只是宏定义，因为真正对应的的 struct proto 是定义在 sk_common 中的字段。而 sock 结构体定义了一个类型是 sk_common 的字段 __sk_common。 总结用户通过得到的文件描述符 sock_fd 可以找到对于的 struct file 结构，而 struct file 结构有 struct socket 的引用，后者则包含了 struct sock 的引用。 在 struct socket 中有一套面向 socket layer 中的接口 struct proto_ops（ inet_stream_ops） 而在 struct sock 中有具体的协议的接口 struct proto（ tcp_prot）。 [^2]: 《追踪 Linux TCP/IP 代码运行——基于 2.6 内核》—— 秦健 编著]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket API 实现（零）—— 文件系统注册]]></title>
    <url>%2F2014%2F10%2F22%2Fsocket-filesystem%2F</url>
    <content type="text"><![CDATA[注：本文中的源码是 2.6.32.63。在 2.6.39 中已经废弃了 get_sb 函数，取而代之的 是 mount 函数，这两函数的原型有些许差别，不过对于本文的主题在逻辑上来说没有太 多的区别。 socket 的概念接口socket 的使用非常的广泛，中文一般翻译成“套接字”。那么 socket 到底是什么东西呢？ 下面这段话是从 man 7 socket 中摘录下来的： The BSD compatible sockets are the uniforminterface between the user process and the network protocol stacks in the kernel. 翻译成中文： 和 BSD 兼容的 sockets 是用户进程和内核网络协议栈之间的统一接口。 我们把这一层接口叫做 socket layer，所以从结构上来说，图示如下： 所以从结构层面上来说，socket 是一个接口层，用来连接用户进程和内核到协议栈。它属 于系统调用的一部分，我们一般称之为 socket API。 进程间通信技术在最原始到 UNIX 中没有 socket 到概念存在，它最早出现在 BSD 中。之所以引入这个概 念是因为随着网络技术的发展，人们已经不满足于一台机器上到进程之间进行通信，而 socket 的引入就是为了使得不同机器上的进程可以跨过计算机网络进行通信。 从这个层面上来说，socket 是一种进程间通信（IPC）的技术，用于不同机器上的进程[^1] 。 文件socket 作为一种进程间通信到技术，在设计上被设计成位于用户进程和内核协议栈中间到 一个接口，但是从具体实现角度来说，它是一种特殊的文件[^2]，毕竟在 UNIX 的世界里一 切都是文件（这种设计被 BSD 和 Linux 沿用）。这样以来我们可以通过统一到文件接口（ read，write ）进行 socket 的读写。 我们知道任何到文件都是由文件系统来管理，socket 文件也不例外。不过 socket 文件因 为本身并没有磁盘上的实体文件和他对应，所以 socket 文件系统其实是一个逻辑文件系统 （或者说伪文件系统）。这个文件系统只存在于内存当中，这篇文章就是分析这个文件系统 是如何工作的。 socket 文件系统的初始化一切从 net/socket.c 文件中^3的以下这行代码开始 1core_initcall(sock_init); /* early initcall */ 这段代码是一个宏定义的扩展，它最终的效果是在编译的过程中把一个指向 sock_init 这个函数的指针放入到一个初始化段中去，这个段的名称是.initcall1.init。 内核启动函数 kernel_init() 最终会调用这些初始化段中的函数来完成初始化工作。也 就是说在内核初始化的过程中最终会调用 sock_init 这个函数，而这个函数最终完成 socket layer 这一层的初始化工作。 在 sock_init 这个函数的尾部有下面这段代码： 123init_inodecache();register_filesystem(&amp;sock_fs_type);sock_mnt = kern_mount(&amp;sock_fs_type); init_inodecache 这个函数作用是用来建立一个 socket 结构以及它对应的 inode 节点 的 SLAB缓存。 register_filesystem(&amp;sock_fs_type) 的作用则是把 sock_fs_type 加入到内核的文件系统列表中。这个列表定义在 fs/filesystem.c 中，它的定义如下。 1static struct file_system_type *file_systems; 所有在内核中注册的文件系统都会添加到这个列表中去，因为这个列表是一个指针列表，所 以注册的文件系统需要保证内存不被释放，否则会发生非法指针访问错误。比如这里的 sock_fs_type 它定义在 net/socket.c 文件下，它的定义如下。 12345static struct file_system_type sock_fs_type = &#123; .name = "sockfs", .get_sb = sockfs_get_sb, .kill_sb = kill_anon_super,&#125;; 因为它是一个静态的全局变量，所以不用担心内存被释放掉。 最后一条语句 sock_mnt = kern_mount(&amp;sock_fs_type); 则真正的完成了对 socket 文 件系统的初始化工作。 kern_mount 函数首先创建一个 vfsmount，然后调用的是 file_system_type 的 get_sb 函数来得到文件系统的 super block 并进行初始化， 最后用初始化过后的 super block 设置 vfsmount 中的参数，从上面的 sock_fs_type 的定义我们可以看出，对于 socket 文件系统来说 get_sb 是 sockfs_get_fs，而 sockfs_get_fs 最终调用了 get_sb_pseudo 这个函数。 get_sb_pseudo 主要完成了下面几件事情： 调用 sget 为 socket 文件系统创建一个新的super block。 sget 则是通过调用 alloc_super 分配空间。 根据 file_system_type 对 sget 得到super block进行初始化。其中最主要的是设 置它的操作函数（如何创建 inode 和销毁 inode 等等）： 1s-&gt;s_op = ops ? ops : &amp;simple_super_operations; 对于我们的 socket 文件系统来说，传递给 ops 的值是 sockfs_ops，也就是下面这个 结构： 12345static const struct super_operations sockfs_ops = &#123; .alloc_inode = sock_alloc_inode, .destroy_inode =sock_destroy_inode, .statfs = simple_statfs,&#125;; 所以对于 socket 文件系统来说，最终我们创建一个 inode 调用的是 sock_alloc_inode 这个函数。 创建一个新的 root inode，因为这是第一个 inode，所以它的 inode 号被设置成了 1 。我们刚刚说过对于 socket 文件系统来说，它最终调用sock_alloc_inode函数。这 个函数的具体代码如下： 12struct socket_alloc *ei;ei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL); 也就是说它在前面通过 sock_init 中的 init_inodecache();建立的 inode 缓存中分 配了一块合适的空间。 值得一提的是，它分配的并不是 inode 结构，而是一个 struct socket_alloc 结构。 这个结构的定义如下： 1234struct socket_alloc &#123; struct socket socket; struct inode vfs_inode;&#125;; 它是 socket 结构体和 inode 结构体的结合体。也就是说一个 socket 结构就有一个 inode 结构和它一一对应。需要面向文件系统进行操作的时候使用这个 inode，而需要 面向 socket layer 进行处理的时候使用 socket。在内核中还提供来这两个成员相互转 换到辅助函数 123static inline struct socket *SOCKET_I(struct inode *inode)static inline struct inode *SOCK_INODE(struct socket *socket) 创建一个目录项，用刚刚的 inode 实例化这个目录项，也就是说设置这个目录项的 inode 为前面创建的 inode。并把这个新的目录项作为前面新建的super block的根目 录。 用这个初始化过的 super block 设置前面在 kern_mount 中建立的 vfsmount。 整个处理流程到这来就算是结束了。最终返回一个设置好的 vfsmount 给 socket_init 函数。这个 vfsmount 最终被存储在了 sock_mnt 中。这个变量也是定义在 net/socket.c 中的一个静态变量，定义如下： 1static struct vfsmount *sock_mnt __read_mostly; 所以最终在 sock_init 执行之后，就可以通过 sock_mnt 的来访问这个 socket 文件 系统了。 [^1]: 传统的进程间通信技术，比如信号、管道、信号量、共享内存等等。这些技术都是用于同一机器上到进程。当然 socket 也可以用于本机上的进程通信。 [^2]: 你可以使用 lsof -U 命令来查看打开的 socket 文件，一般来说在 /tmp 目录下会有很多这类文件。]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LKD 总结 —— 第二章]]></title>
    <url>%2F2014%2F10%2F09%2Flkd-chapter-two%2F</url>
    <content type="text"><![CDATA[概述第二章其实是非常简单的一章，主要讲了以下两个方面的内容： 如何获取源码和编译 Linux Kernel 有哪些与众不同的特点 对于第一个问题，个人觉得这本书里面的讲解并不是特别的清晰，我在本文中根据自己摸索 出来的一些经验进行了总结，供大家参考。 如何获取内核的源码和编译内核如何获取源码获取源码的压缩包（tarball）获取源码最直接的方式是访问内核的 官方网站，在官网上你可以找到最 新的内核，以及目前的长期维护版本的最近更新版本的压缩包。 很多时候我们需要找到一些官网首页上不存在的版本，比如如果你正在看一本关于内核的书 ，而这本书使用的内核版本现在已经停止开发了，而新的内核版本和书上的版本改动较大难 以理解，这个时候我们可能会需要一个和书本上一模一样的版本。 内核的网站保存了所有的内核版本，虽然你不能在首页上直接找到它，但是你可以通过以下 链接 找到 我们在官方网站上下载到的都是压缩包，旧的版本一般分为 bz2 版本和 gz 版本，而目前 的版本则包括 gz 版本和 xz 版本，建议下载 bz2 或者 xz 版本，因为它们的压缩效果要 好一些。 bz2 和 gz 版本的解压方式书本上有提到，这里不再重复，如果你下载的是 xz 版本可以使用下面的方式解压： 12unxz linux-x.y.z.tar.xztar -xvf linux.x.y.x.tar 通过 git 获取最新的版本前面提到的方式获取到的压缩包比较小，方便下载和拷贝。但是不断的会有新的版本出现， 如果你不想自己不断的打补丁，那么可能需要不断下载压缩包，以获得最新的稳定版本。 如果你不想不断的下载新的压缩包，你可以考虑使用 git 获取最新的稳定版本，有更新的 时候也可以通过git[^1]很方便的进行更新。 如果你想获得最新的稳定版本可以使用下面的命令： 12git clonegit://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git 你将会得到一个全新的目录 linux-stable。如果你想要更新里面的内容以获取最新的内核 代码，可以通过在 linux-stable 根目录下执行命令来达到目的： 1git pull git 使得版本控制变得非常的方便，但是由于内核的代码量非常大，如果你的网速不是很理 想，那么这将会是一个非常漫长的等待过程。因此具体使用上面提到的哪一种做法可能因人 而异。 如何编译源代码有了源代码之后可以编译它给自己的系统安装全新的内核。在网上的资料中提到的编译安装 的方式一般步骤如下： make menuconfig（或者 make config、 make gconfig、 make xconfig） make oldconfig make sudo make modules_install sudo make install 上面提到的方式是编译内核的正常方式，但是对于一般初学者来说并不是最佳的方式。 第一步的作用是对内核进行配置， Linux Kernel 的可定制性非常的高， 你可以只编译你 需要的部分得到一个最适合你的机器的内核版本。但是内核的配置其实非常的复杂，无论你 是使用基于终端的 menuconfig 还是图形界面的 gconfig（gtk+）和 xconfig（qt）你都需 要在浩如烟海的配置选项中找出你想要的那些选项。对于一般人来说这是不太可能完成的任 务，一方面配置太多无法找到一一查看，另外就算你有精力一一查看你也不一定能看懂选择 到底是什么意思（很多选项和硬件相关，没有一定基础基本上搞不明白）。 为了减少配置的困难，你可以尝试以下三种选择： make defconfig 找到当前 Linux 发行版本的 config 文件，然后使用它作为配置文件编译新的内核 make localmodconfig 第一种方式是直接根据你的系统架构选择默认的配置，这个配置一般会得到一个精巧的的 内核版本。但是默认的配置一般式内核维护者给出的配置，因此不一定适合你的电脑，所以 很有可能你编译得到的新的内核无法正常的启动。不过这个方法对于初学者体验如何编译安 装内核来说是一个不错的选择。 第二种方式是使用当前 Linux 发行版本的 config 文件作为你的配置。这个配置文件一 般存在以下三个目录之一： /boot/ (ubuntu, centos) /proc/ (arch) /usr/src/linux/ 找到这些文件之后把它拷贝到你下载的内核根目录下改名为 .config 之后使用 make oldcongig。一般来说因为新的内核会加入很多新的配置选择，因此你在 make oldconfig 过程中会遇到很多新的选项需要你选择，此时一般使用默认值就可以了（直接 按 Enter）。 上面的这种方式一般能得到一个可以运行的的内核。不过出于兼容各种硬件的考虑，发行版 本的配置一般会包含非常多的模块，所以你得到的内核可能会比较臃肿。 第三种方式其实是第二种方式的一个变种，如果你直接在下载的内核源码根目录下面执行 make localmodconfig，那么相关的脚本会使用找到当前发行版本的配置文件作为蓝本， 然后通过 lsmod 命令找到目前使用了哪些模块，之后选择这些模块的相关配置选项，取消 其他的选项，这样一来你会得到一个较小而且能用的版本。 这种方式可以说是较为可行的一种方式，不过因为它是根据当前系统正在使用的模块来进行 选项设置的，所以如果你当前没有用到某一模块，那么你编译的新内核讲不会包含该模块， 比如你当时没有插入 U 盘那么新的内核可能无法使用 U 盘。 为了解决这个问题你可以首 先手动使用 lsmod 找到目前系统使用的模块并把输出结构保存下来，然后修改这个输出 文件，增加你需要的模块（比如 U 盘驱动），最后把你修改过的模块列表作为参数传递给 make localmodconfig。具体的方式可以参考下面这个链接 其他小提示： 并不是所有的内核版本都能在你的电脑上正常的运行起来，所以如果你的电脑不能够 正常的运行你编译好的内核版本，你可以考虑换一个内核版本试试。 不要使用 /usr/src 目录作为你的源码编译目录。 编译内核的第一步——配置之前，你可能需要安装一些额外的包才能正常的使用 make meneconfig, make gconfig。不同的发行版本一般不一样，你可以在网上查找。（一 般是 ncurses 的头文件或者 gtk+ 和 qt 的头文件）。 一般的发行版本会有一个软件包帮你安装所有需要工具包（比如：ubuntu 的 kernel-package 和 centos 的 kernel-devel）。 使用 make -jn 会比 直接 make 快很多，n 一般是 CPU 核心数的两倍。 最后推荐一本关于内核的书籍 《Linux Kernel in a Nutshell》，中文名字叫 做《Linux 内核技术手册》。这本书英文版网上可以免费下载，书很薄读起来非常的轻松。 这本书涉及到内核编译的方方面面，虽然已经比较老了，但是仍然是一本值得一读的书。 Linux 内核的特性Linux 内核作为一个庞大的软件项目（据说有 1000+ 万行），没有一点自己的个性说不过 去。那么 Linux 内核到底包括哪些比较另类（相对于我们写的用户空间程序来说）特点呢 ？ 不使用 C 函数库，当然也就不会包含标准的 C 头文件 用 GNU C 编写而成 缺少内存保护机制 很难进行浮点运行 每个进程都有一个固定大小的内核栈 需要着重考虑同步和并发问题 可移植性对内核非常重要 这些特点书本上有非常详细的讲解，这里不再重复。值得一提的是第二点，大部分软件开发 都希望迎合标准（使用 ANSI C 或者 C89、C99 标准）而 Linux 内核却使用 GNU C 编写， 我想这或多或少和 GNU 与 Linux 之间的深厚渊源有点关系。 由于 Linux 内核是使用 GNU C 编写，里面使用了大量标准 C 中不存在的用法，除了书上提到的那些以外我在阅读源码 的时候也多少遇到过一些，我把它们整理在了 《C 语言的趣味用法》这篇博 文之中，有兴趣的可以看看。 [^1]: git 是一种新型的版本控制器，关于 git 的更多介绍可以访的 官网。]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>LKD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言的趣味用法]]></title>
    <url>%2F2014%2F09%2F30%2Fc-language-funny-usage%2F</url>
    <content type="text"><![CDATA[零长数组——Zero-Length Array12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct packet_head &#123; int len; char content[0];&#125;;int main(void)&#123; char content[] = "hello world"; struct packet_head *packet; packet = malloc(sizeof(struct packet_head) + sizeof(content)); packet-&gt;len = sizeof(content); memcpy(packet-&gt;content, content, sizeof(content)); printf("len: %d, content: %s\n", packet-&gt;len, packet-&gt;content); return 0;&#125; 在上面这段代码中结构体 packet_head 有一个成员 content 是一个长度为 0 的数组 。这种用法在 C 标准中并不存在，它是 GCC 的一个扩展用法。在编写网络协议实现的时候 用的比较多，在包头的结构体末尾定义一个这样的成员可以使得它指向包头后面的数据部分 。比如在上面的例子中，malloc 分配了包头和数据的空间，把返回值转换成包头类型， 从而使用 packet-&gt;content 来控制数据部分。 结构体内部的宏定义1234567struct __wait_queue &#123; unsigned int flags;#define WQ_FLAG_EXCLUSIVE 0x01 void *private; wait_queue_func_t func; struct list_head task_list;&#125;; 宏定义本身是没有作用域限制的，把宏定义写在一个结构体的内部并不表示这个这个宏定义 只能用在这个结构体内部。宏定义在编译之前的预处理部分就已经被替换了。之所以把宏定 义写在一个结构体的内部一般是表示这个宏定义一般用于结构体的某个成员，比如上面的这 个结构体中的宏定义 WQ_FLAG_EXCLUSIVE 用来表示结构体中 flags 的值（互斥的唤醒） 。 结构体内部的匿名联合体（或者结构体）12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; enum person_type &#123; STUDENT, TEACHER &#125;; struct person_struct &#123; enum person_type type; union &#123; int student_age; float teacher_salary; &#125;; &#125;; struct person_struct student = &#123; .type = STUDENT &#125;; struct person_struct teacher = &#123; .type = TEACHER &#125;; student.student_age = 23; teacher.teacher_salary = 6543.21; printf("Student age: %d\n", student.student_age); printf("Teacher salary: %.2f\n", teacher.teacher_salary); return 0;&#125; 在上面的例子中，person_struct 这个结构体内部包含了一个匿名的联合体，你可以通过 person.student_age 或者 person.teacher_salary 来引用这两个值。这是 C11 中的 新特性。 对齐12#define SKB_DATA_ALIGN(X) (((X) + (SMP_CACHE_BYTES - 1)) &amp; \ ~(SMP_CACHE_BYTES - 1)) 另 SMP_CACHE_BYTES - 1 为 mask 则上面的宏定义简化成 （x + mask）&amp; （～mask）， 首先加上 mask 使得不够 SMP_CACHE_BYTES 的部分先补齐，然后 &amp; ～mask 其实就是把 数据不足 SMP_CACHE_BYTES 的部分清除掉。比如 SMP_CACHE_BYTES = 4 （100），那 么 mask = 3 （011）。假设 x = 3，那么最后的结果是 110（6 = 3 + 3）&amp; 100（～3）= 100（4）。如果 x = 1，那么结果就是 100（4 = 1 + 3） &amp; 100 （～3） = 100（4）。假 设 x= 5，那么最后的结果是 1000（8 = 5 + 3） &amp;（1100） = 1000（8）。假设 x = 7， 那么结果是 1010（10 = 7 + 3） &amp; 1100（～3） = 1000 （8）。 强迫编译时出错1#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)])) 这个宏定义有两个地方值得注意：第一就是 !!(condition) 的使用，我们知道在 C 语言中 使用 非0 表示真，0表示假（而不是 1 表示真，0 表示假）。如果你想强制使用 1 表示真 ，0 表示假的话可以使用 !!(condition)。因为两次使用逻辑否运算不会改变 condition 到逻辑属性，但是因为逻辑运算到结果在 c 语言中用 1 表示真，0 表示假，所以最后到结 构可以保证一定使用 1 表示真，0 表示假。 第二个值得注意到地方就是 char[1 - 2 !!(condition)] 这种写法，因为 !!(condition) 结果只能是0、1，所以 1 - 2 condition) 的结果只可能是 1 或者 -1（ 当 condition 为真的时候结果是 1 - 2 = -1，当 condition 为假的时候结果时 1 - 0 = 1）。这样一来，如果 condition 为真，那么最终这个宏会被扩展成 (void)sizeof(char[-1])，显然这个表达式无法通过编译，因为 char[-1] 时非法的表达式 。 这个宏定义的作用是在编译时确保某些条件成立，使得错误在编译期间就暴露出来，有点类 似与 assert() 的作用。 完]]></content>
      <tags>
        <tag>C/CPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LKD 总结 —— 第一章]]></title>
    <url>%2F2014%2F09%2F18%2Flkd-chapter-one%2F</url>
    <content type="text"><![CDATA[Unix 的优点Linux 承袭了大量 Unix 的设计精华主要包括下面这些： 系统接口简单，也就是说系统调用设计的很合理 一切都是文件，这样就可以把数据和设备的访问统一到 open(), read(), write(), lseek(), close() 这组系统调用中 使用 C 语言编写，有非常好的可移植性（这个应该是相对与汇编语言来说吧） 快速的进程创建（fork） 简单而稳定的进程间通信机制（IPC） 操作系统和概述操作系统严格意义上来说指的只是它的内核、用户接口而不包括在上面运行的程序（不过个 人认为操作系统存在的意义就是让这些程序跑起来完成用户想要完成的工作）。在一个操作 系统中用户接口在最外层用来和用户进行交互，而在最内层提供基础服务的是内核。 内核主要由以下几部分组成：中断处理处理器、进程调度器、内存管理系统，网络服务、 IPC 等等。内核代码运行在内核空间（kernel-space），而用户程序运行在用户空间（ user-space）。内核空间和用户空间的概念需要日后慢慢理解，在 ULK（Understanding Linux Kernel） 里面提到了 CPU 有不同的工作模式，包括特权模式和非特权模式等，而内 核代码一般运行在特权模式，用户程序则运行在非特权模式，这种两个模式又被成为内核模 式（kernel mode）和用户模式（user mode）。内核空间和内核模式应该不是指的同一个概 念，在维基百科上的解释说虚拟地址空间分为内核空间和用户空间，这种解释应该是比较合 理的。 内核对上层来说，它给用户程序提供了系统调用。用户程序通过使用系统调用而陷入到内核 中执行内核代码，此时系统从用户空间切换到内核空间，而内核运行在进程上下文中（相对 于下文中的中断上下文）。对下层来说，内核需要管理系统中的硬件，这是通过中断来实现 的。当中断发生之后，系统执行中断处理器。此时系统在内核空间运行（运行的内核代码） 并且内核处于中断上下文。 任何一个时刻，处理器都只可能处于以下三种状态之一： 在用户空间，执行进程代码 在内核空间的进程上下文中执行内核代码（执行系统调用，此时内核其实是在替进程执行 代码，因为严格意义上来说系统调用是进程代码执行中的一步，属于这个进程的代码） 在内核空间的中断上下文中，处理中断（没有相关的进程，这是很重要的一点，没有相关 的进程也就意味着不能够阻塞，不能睡眠，无法调度） 所以其实内核并没有无时不刻的在运行。在第一种情况下执行的是用户代码，而后面两种情 况执行的是内核代码（一个处理器不可能同时执行两条指令，所以说上面三种情况是互斥的 ，操作系统在一直运行但并不表示它的内核在一直运行）。 宏内核和微内核这两种内核的争论从来没有停过，操作系统大神塔能鲍姆（学术派——微内核派）和林纳斯（ 实用派——宏内核派）就哪种内核好有过激烈的争论。宏内核，所有的内核代码都在一个地址 空间运行，内核间的交互可以通过简单的函数调用来完成，高效而简单，基本上所有的 Unix 都是宏内核（当然也包括它的后继者 Linux）。而微内核在学术上来说是非常美的设 计，内核的功能被分配给不同的进程（通常称为服务），也就是说内核代码运行在不同的地 址空间，服务间交互是通过 IPC 来完成的。理论上只有核心的服务需要运行在内核空间， 而其他的服务可以在用户空间运行，这可以大大的提供系统的健壮性（一个服务终止不会影 响其他的服务），也可以很好的实现模块化，同时不必要的服务也可以销毁节省空间。但是 在实际中，IPC 不但开销非常大也没有函数调用的高效性，同时为了减少在用户空间和内核 空间中的切换，目前的微内核都把服务放在内核空间（这就有违设计初衷）。 Linux 向来都是实用至上。它虽然是宏内核，但是它支持模块的动态加载，从而支持模块化 ，它也支持内核线程（类似于微内核的服务概念），此外内核本身是可抢占的，也就是可以 调度的（这类似微内核不同的服务之间可以调度）。这种设计融合了微内核和宏内核的优点 ，既没有微内核的开销又可以实现模块化。 Linux 独有的特点Linux 并不是 Unix 的直系后代，对于任何问题它都可以选着最佳的实践方案而不用考虑向 后兼容的问题（新建一套房子要比整修一套房子简单）。Linux 选着一个解决方案的标准在 于是否有合理的设计和优雅的实现，而不是在于它听上去美不美。 Linux 内核版本在书本上提到的版本号和目前使用的似乎不太一样，书本中的版本号如下： 2.6.26.1 第一个数字是主版本号，第二个为次版本号。次版本号决定内核版本是否是稳定的。如果次 版本号为偶数表示稳定否则是开发版本。版本号的前两位组成一个内核系列如 2.4 系列。 第三个数字表示版本修正，是在一个内核系列中（如 2.4 系列）因为BUG 修复、新驱动和 新特性的加入而发布的新版本（2.4.1）。同一系列相邻的修正号之间一般不会有太大的变 化。 但是这一方案在 2004 出现了变化。2.6 序列的开发周期无限延长，前面三位数字组成一个 小的迷你开发序列，如 2.6.26 序列。相邻的两个小的序列中可能会出现非常大的变化。因 为开发周期很长，比如 2.6.26 这个序列的开发周期可能长达数月，出现了严重的 BUG 需 要更新版本号的时候使用第四个数字（比如：2.6.26.1 中的 1，这有点像原来方案中的修 正号），这个 BUG 通常是目前的版本（这个例子中是 2.6.27）对上一个版本的 back-port 。 当前的版本号和书上的有了较大的不同。林纳斯已经成功把内核版本号从冗长的 2.6 直接 跳到了 3.0 （借口是内核发布 20 周年，为了升级版本号他可以说是煞费苦心，网上有这 一段有趣的故事，大家可以去看看，从中可以看出开源和不开源的区别[^1]），目前内核版 本演化到 3.17，目前的版本分为： Prepatch、Mainline、Stable、Longterm 四种而不是 稳定和开发两种[^2]，也没有再出现三位数的迷你开发序列。 [^1]: 林纳斯它虽然创造了 Linux 它也拥有 Linux 的商标，但是它没有权利觉得 Linux 的走向。Linux 到底会如何发展还是看社区的全体开发者的决定 [^2]: 目前到版本号也没有使用次版本号到奇偶性来区分稳定和不稳定，比如目前最新到 Stable 版本是 3.17.1 (2014-10-22)]]></content>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>LKD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emacs C、C++、Python 编程的简单配置]]></title>
    <url>%2F2014%2F09%2F16%2Femacs-c-cpp-python-config%2F</url>
    <content type="text"><![CDATA[简介Emacs 和 Vim 并称 Linux 下的两大编辑神器（不是 IDE，只是编辑器）。一般人认为这两 个编辑器的门槛太高，不容易学，使得很多人都只能敬仰却没有勇气使用它们。其实个人并 不认同这样的看法，Emacs 和 Vim 基本的操作其实并不复杂，而且它们各自都带有非常好 的入门教程。Emacs 在启动页面上会有一个非常通俗易懂的教程（tutorial），如果你关闭 的启动页面，你可以在菜单栏的 Help 下找到这个教程，如果你关闭的菜单栏可以使用 M-x （也就是 Alt + x）执行命令 menu-bar-mode 显示菜单栏。个人觉得这份教程对于初学者 的价值比任何其他资料都更高，如果你没有使用过 Emacs 或者说你还不是很熟悉它的话， 建议你先阅读这份文档。 Emacs 和 Vim 都有非常高的可定制性，你可以通过配置文件和插件对它们进行高度的定制 ，使得这个编辑器使用起来非常的称手（有它该有的功能，最主要是不该有的功能它没有） 。这大概也是它们比一般的 IDE 更受欢迎的主要原因吧。 当然凡事都有它的利弊，好的东西总是有点代价，那就是配置其实还是挺花时间的。我使用 Emacs 的时间其实不是很长，一路走来可以说是跌跌撞撞，目前也只能算是相对熟悉这个编 辑器而已。写这篇文章不是为了炫耀自己的配置有多厉害，而是希望能够总结自己的一些经 验，分享给大家，以减轻初学者在配置 Emacs 时的痛苦。本文如果有疏漏、错误的地方欢 迎大家指正出来。 配置目标由于本人主要使用 Emacs 做 c、c++ 的开发，所以本文的配置目标主要是把 Emacs 配置成 一个适合 c 和 c++ 的开发工具。另外我也在闲暇之余学一点 Python，所以这里的配置也 会涉及到 Python 的相关配置。 不过就编程而言，其中有很大一部分的配置对于各种语言的开发都是一样的，涉及到具体语 言的配置其实并不多。所以如果你想要 Emacs 做其他项目的开发，本文中的配置可能仍然 对你会有一些帮助。 本文的配置是基于 Emacs 24 进行的，如果你目前安装的版本低于这个版本建议你升级到该 版本。因为 Emacs 24 自带了包管理器 package，有了它安装和配置插件的难度可以大大的 降低。 配置文件及其结构在讲解具体的配置之前，我想先说一下配置文件和它的格式。所谓的配置文件官方名称叫做 初始化文件（initialization file，或者 init file），这个文件如果存在的话，Emacs 在启动的时候会加载并解析它。Emacs 会查找以下三个文件： ‘~/.emacs’, ‘~/.emacs.el’ , 或者‘~/.emacs.d/init.el’，其中 ’～‘ 表示你的 home 目录。所以你可以使用这三者之 一作为你的配置文件，相对来说第一个用的多一些。 结构主要是说你的配置文件按照怎么样一种布局书写，Emacs 本身并不要求你的配置文件按 照一定的结构来组织，但是一个良好的配置文件结构可以使得你的配置一目了然，同时也非 常方便你日后的查阅和修改（你一定会经常改动它，因为你会爱上 Emacs 的配置）。这就 像是任何一种语言都会有的编程规范，编译器不会要求你使用何种规范，但是好的规范可以 让人非常容易的读懂代码。记住编程首先是写给人看，然后才是写给机器看（这句话出自《 代码大全》）。 我按照下面的方式组织我的配置文件，你可以不用这种方式，但是你需要有自己固定的方式 。 文档注释 插件无关的公共设置（Emacs 自带的一些设置） 公共插件配置（和语言无关的插件配置） 特殊配置（如针对单个语言的具体插件配置） 按键绑定（把它放在最后面是因为按键绑定可能会涉及到相关插件） 配置内容下面我们开始说具体的配置内容，我们将会按照上面提到的结构逐点展开。完整的配置文件 可以从 这里下载. 插件无关的公共设置在 mode line 上显示行列号首先要说明一下什么是 mode line，一个刚刚启动的 Emacs 界面可以大致分成一下几个区 域。最上面是菜单栏，下面紧挨着工具栏（为了得到较大的编辑区域，上面这两块一般会被 隐藏起来）。在最底部是一个 echo 区域（echo area，才疏学浅实在不知道如何翻译 echo 为好），这个区域用来显示输出信息，同时也用来输入信息，比如执行 Emacs 命令。夹在 中间的大块区域在 Emacs 中被称为窗口（window），这里的窗口和图形界面里面的窗口不 一样，在 Emacs 中图形界面的窗口一般称为框架（frame）。我们所谓的 mode line 就是 一个窗口最下面突起的那一行。 把以下语句添加到配置文件中可以在 mode line 中显示行列号 123;; 在 mode line 上显示行列号(setq column-number-mode 1)(setq line-number-mode 1) 你也可以使用 linum-mode 在 buffer 的左边列出没一行的行号。你可以通过 M-x linum-mode 来暂时打开和关闭行号显示，也可以把 (global-linum-mode) 加入到你的配置 文件中，默认的显示行号。 去掉滚动条、菜单栏和工具栏大部分时候我们希望能够得到较大的编辑区域，Emacs 提供了相关的配置使得你可以最大化 你的编辑区域，你可以通过以下代码（写到配置文件里面）来去掉滚动条、菜单栏、工具栏 。 1234;; 取消滚动栏，工具栏(tool-bar-mode 0)(menu-bar-mode 0)(scroll-bar-mode 0) 这个配置一般会有两种形式，你也许还会看到下面这种形式（tool-bar-mode nil）。在 Emacs 24 中使用 nil 好像不能达到上面的效果，但是其他的一些配置使用 nil 又可以， 我不知道是什么原因，但为了统一风格，我一律使用 0 表示否定值。 关闭 Emacs 的起始欢迎页面Emacs 的起始欢迎页面对于初学者来说帮助比较大，可以了解各方面的信息，包括官方的教 程。但是对大部分人来说它有点碍事，也影响美观。下面的语句可以关闭它。 123;; 关闭emacs启动时的页面(setq inhibit-startup-message 1)(setq gnus-inhibit-startup-message 1) 以 y/n代表 yes/noEmacs 经常需要我们确认一些信息，比如你在没有保存文件的情况下关闭 Emacs，它会要你 确认是否保存文件，这个时候你需要输入 yes 来表示确定。这很繁琐，你可以使用下面的 语句改变这种交互方式，把 yes、no 改成 y、n，这样可以很方便的输入。 12;; 以 y/n代表 yes/no(fset 'yes-or-no-p 'y-or-n-p) 备份设置使用 Emacs 编辑文件，经常会发现多出一些以 ~ 结尾的文件，如果你是完美主义者或者你 有轻微强迫症（我就是），这是很难忍受的，我原来经常会去删除这些文件，直到后来找到 了更好的解决方式。在 Emacs 中你可以设置你自己的备份策略，包括备份几份数据，备份 到哪里等等。下面是我的备份策略设置： 123456;;; 设置备份策略(setq make-backup-files t)(setq kept-old-versions 2)(setq kept-new-versions 2)(setq delete-old-versions t)(setq backup-directory-alist '(("" . "~/.emacsbackup"))) 如果你完全不想备份可以直接把 make-backup-files 设置为 0，不过备份文件在很多时候 还是非常有用的，所以我并不建议你那样做。如果你不想备份文件出现在你的工作目录下， 你可以设置一个目录专门存放你的备份文件，然后使用 backup-directory-alist 这个变量 设置你的目录，比如我就把它设置在自己的 home 目录下的一个隐藏文件夹（.emacsbackup ）下面。 以上配置中间的三条语句是指明你的备份策略，保存最老的 2 份数据和最新的 2 份数据， 删除其余的备份。你可以自己改变其中的值，以保存你想要的份数。 公共插件配置Emacs 的插件数不胜数，你想要的各种功能都可以通过相关的插件来完成，这里介绍一些我 平常使用较多的插件。主要包括一下这些插件： package: 包管理插件 autopair: 括号的自动匹配 yasnippet: 代码块扩展 auto-complete: 代码智能补全 evil: 给 emacs 加入 vim 的功能 desktop: 保存工作环境 ido: 快速的查找文件、切换 buffer smex: 快速的输入 emacs 命令 gtags: 代码跳转，源码阅读神器 fill-column-indicator: 用于提示每行的代码字符限制 doxymacs: 写注释非常方便 jedi: 唯一需要的 python 插件。功能应有尽有 其中第一部分的插件是一些公用的插件，和具体的编程语言无关，第二部分的插件我主要用 在 c、cpp 开发中，第三部分的插件主要用在 Python 开发中。这里主要介绍第一部分的插 件。 包管理插件 —— package第一个要隆重介绍的插件是 package，这个插件是 Emacs 24 自带的插件，主要用来方便的 管理各种插件。介绍它之前需要先介绍一下 ELPA 这个概念，ELPA 是 Emacs Lisp Package Archive 的缩写，它相当于是一个插件（也就是 Lisp Package）仓库，里面有各种各样的 打包好了的 Emacs Lisp 代码（插件用 Emacs Lisp 语言编写，Emacs Lisp 是 Lisp 语言 的变种，级别应该相当于是 Scheme 语言，我们编写的配置文档其实也是 Emacs Lisp 语言 编写）。 我们知道 Emacs 的可定制性和扩展性都非常的高，这也就使得 Emacs 的插件不计其数，安 装和管理这些插件变得非常的繁杂。为了解决这个问题，就出现了 ELPA，把插件统一起来 。但是它只是一个仓库，我们需要一种便捷方式从仓库中下载和更新我们的插件。而这种便 捷的操作依然是通过插件完成，也就是这里提到的 package 插件，它内置在 Emacs 24 中 。如果你使用的不是 Emacs 24，建议你先升级到 24 版本。 因为 package 是一个内置的插件，所以你不需要安装，要使用它你只需要告诉它仓库（ ELPA）的位置即可。ELPA 有比较多，目前大家使用较多的是 MELPA，里面的插件非常丰富 ，我们这里提到的插件都可以在上面找到。下面是 package 的设置： 12345;; 设置 package system，这里使用 MELPA，里面的包可以说是应有尽有(require 'package)(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)(package-initialize) 注意不要漏掉了最后的 (package-initialize)。设置好了之后，我们可以通过执行 list-packages 命令（通过 M-x 然后输入指令）来查看所有的包，在查找到你想要的包之 后在改行输入 i 标记你要安装这个包，然后输入 x 执行你的安装指令，这样这个插件就会 自动安装到你的 Emacs 中去了（在 ~/.emacs.d/elpa/ 目录下面）。如果有包需要更新， 在你执行 list-package 命令之后在 echo 区域会有提示，此时直接输入 U 然后输入 x 可 以更新这些包。当然你也可以很方便的删除你安装的包，方式是在你想要删除的包上面输入 d 然后输入 x 执行它。 很方便吧，后面提到的插件都是通过这种方式来进行安装，以后不再重复。 括号自动匹配 —— autopair在编写大部分程序的时候我们都需要括号匹配，所以很多适合我们输入 ‘(‘ 的适合非常希 望能 Emacs 自动补全 ‘)’ 并且把光标停到两者中间。可是 Emacs 并默认没有提供这个功 能，它包含一个自带的模式 electric-pair-mode 可以完成这个工作，你可以使用 M-x 来 开启它也可以把它加入到你的配置文件中去。我尝试过使用 electric-pair-mode 但是感觉 不如 autopair 好用，最后还是选择了 autopair。 通过 package 安装之后你可以通过 M-x autopair-mode 来开启这个模式，也可以把他加入 到你的配置文件中默认开启它，或者针对某种主模式开启。对于 Emacs 的大多是插件，都 可以有这三种方式来使用它： 通过命令行，在需要的时候使用，比如: M-x autopaire-mode 通过配置文件，默认使用，比如把以下语句写入到配置文件中： 1(autopair-global-mode) 通过配置文件，对特殊的主模式下使用，比如： 1(add-hook 'c-mode-common-hook 'autopair-mode) 上面提到的三种方式对于大部分的插件都是通用的，不过不同的代码还是会有不同的使用方 式，重复它们其实没有太大的意义，最佳的方式是 google 一下，查找到这个插件的主页（ 一般在 github 上），然后通过看上面的官方使用文档确定如何进行下一步的配置。我在每 个插件的名字上加了官网链接，方便大家参考查阅。 代码扩展神器 yasnippet 和代码补全神器 auto-complete这两款插件可以说是编程必备的。其中 yasnippet 是用来做代码扩展的，比如你在编写 .c 文件时输入 io 然后按下扩展键，它会自动扩展成 #include &lt;stdio.h&gt;，输入 d 然后按下 扩展键之后会自动补全成 #define，非常的便捷。而 auto-complete 则是用来做代码补全 的，比如你在 .c 文件中定义了一个函数 my_function、和一个变量 my_name，在其他 位置输入 my 的时候它会把 my_function 和 my_name 列出来供你选择，这个功能基本 上的 IDE 都有提供，相信大家并不陌生。 这两款插件可以说殊途同归，虽然它们使用的原理不一样，但是它们最后都大大提高了代码 输入的速度。前者主要通过预先定义好用于扩展的 snippet，而后者好像主要是通过对 buffer 中的数据进行分词来提供补全的来源。 不过这两款插件同时使用了 TAB 键， yasnippt 用它来作为扩展键，而 auto-complete 用 来是作为提示触发键和选择键。为了解决这个冲突，我试过两种方法：第一，关闭 auto-complete 的自动提示，这样当你按下 TAB 的时候如果有相关的 yasnippt 代码扩展 ，会先进行 yasnippt 扩展，然后是 auto-complete 补全提示。第二种方式就是更改其中 之一的促发按键，我目前使用的就是这样中方法。下面是我的相关设置: 12345678910;; yasnippet setting(yas-global-mode 1)(define-key yas-minor-mode-map (kbd "&lt;tab&gt;") nil)(define-key yas-minor-mode-map (kbd "TAB") nil);; 设置 f2 为 yas 扩展快捷键(define-key yas-minor-mode-map (kbd "&lt;f2&gt;") 'yas-expand);; auto-complete(ac-config-default) 这里主要是把 yasnippt 的扩展键去掉，然后把他重新绑定到 f2 上（按键绑定的设置我一 般放在了配置文件的最末尾，写在这里是为了方便讲解）。 Vim 和 Emacs 的融合 —— EVILEvil，可以说插件正如其名，功能强大到邪恶的地步。在 Linux 领域有一场旷日持久的编 辑之战，使用号称“编辑器之神”的 Vim 的 V 党和使用号称“神的编辑器”的 Emacs 的 E 党 吵的不可开交，只为了争夺最好用的编辑器的虚名。我是一个实用主义者，我虽然使用 Emacs，但是我承认 Vim 一样非常强大，它的 normal mode 用来查看文档要比 Emacs 好用 的多，Vim 可以通过 hjkl 来移动光标，而 Emacs 需要按 C-p C-n C-f C-b 这些组合键。 但是 Vim 的编辑能力确实相对没有 Emacs 强， Vim 在输入的时候无法使用 hjkl 来定位 光标，而 Emacs 的按键仍然可用。 因此最好的方式就是把两者的精华融合在一起，得到世上最强大的编辑器 “Emacsim”，这也 就是这里要介绍的 Evil。Extensible Vi Layer for Emacs，它是 Emacs 的 一个 Vi 扩展层，使得我们在 Emacs 上可以使用 Vim 的强大功能，比如它的选择功能和方 便的文本阅读功能等等。 不过这两大神器的融合难免有一些不和谐的地方，比如按键上的冲突是在所难免的，好在 Evil 提供了重置按键的功能。下面是我收集的一些按键重绑定。这些按键的重新绑定可以 使得两者的融合更加的融洽，你可以根据自己的需求进行按键从绑定。 12345678910111213141516;; evil 把 emcas 和 vim 的精华糅合在一起(evil-mode 1);; normal mode 下可以使用 ",," 来切换 buffer，取消 q 按键绑定(define-key evil-normal-state-map (kbd ",,") 'evil-buffer)(define-key evil-normal-state-map (kbd "q") nil);; 输入模式下取消下面这些按键绑定，使得在输入的时候可以高效的移动光标(define-key evil-insert-state-map (kbd "C-e") nil)(define-key evil-insert-state-map (kbd "C-d") nil)(define-key evil-insert-state-map (kbd "C-k") nil)(define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state);; 其他绑定(define-key evil-motion-state-map (kbd "C-e") nil)(define-key evil-visual-state-map (kbd "C-c") 'evil-exit-visual-state) 因为 Vim 使用的是多模式编辑，Evil 也自然是多模式的，在不同的模式之间切换的时候， 默认会在 Emacs 的 mode line 上标记目前的模式，不过默认的方式太不显眼不是很容易识 别。我们希望 Emacs 可以很显眼的提示让我们目前是什么模式，Emacs 提供了设置每个模 式颜色的功能。下面这段代码来自 Emacs wiki，它可以使得不同的模式有不同的颜色显示 ： 123456789101112;; change mode-line color by evil state(lexical-let ((default-color (cons (face-background 'mode-line) (face-foreground 'mode-line)))) (add-hook 'post-command-hook (lambda () (let ((color (cond ((minibufferp) default-color) ((evil-insert-state-p) '("#e80000" . "#ffffff")) ((evil-emacs-state-p) '("#444488" . "#ffffff")) ((buffer-modified-p) '("#006fa0" . "#ffffff")) (t default-color)))) (set-face-background 'mode-line (car color)) (set-face-foreground 'mode-line (cdr color)))))) 这种方式在终端开启 Emacs（emacs -nw）的效果非常的好，但是使用 x-window 的话效果 不佳，如果你基本上都使用 x-window 启动 Emacs，那么你可以考虑使用 powerline 插件 。它原本是 Vim 的一个插件，目前有 Emacs 的版本，当然随着 Evil 的到来自然会有 powerline-evil 插件，安装 powerline 的时候会自动安装 powerline-evil。使用这个插 件之后 Evil 下的不同模式显示就近乎完美了。 保存工作环境 desktop 和 session每次关闭 Emacs 之后我们打开的 buffer 都会随之关闭，很多时候我们需要保存我们的工 作环境，下次打开 Emacs 的时候希望原来打开的 buffer 依然存在。这个时候我们可以借 助 desktop 这个插件，它是一个内置插件，不需要安装只需要打开相应的模式即可，在关 闭 Emacs 的时候 desktop 会保存你开启的 buffer，这样下次打开工作环境还在，就好像 没有关闭过一样。 另一个类似的插件是 session，它可以 File 菜单下增加子菜单，记录我们最近访问的的文 件，就像大部分 IDE 提供的功能一样。不过因为我大部分时间关闭 menu-bar 而且使用了 desktop，这个插件的作用对我来说几乎为零，很少使用。 健步如飞的输入 —— ido、smex这两个插件也是重量级的，我非常喜欢。Emacs 的输入大部分时候都可以通过 TAB 键来补 全，但是没有一个直观的界面显示，这两个插件相当于是输入指令时的 auto-complete，它 可以大大减少输入的工作量。 ido 可以用来快速的查看文件和切换 buffer，当我们使用 ido 来打开文件的时候，我们可 以看到一个递进的文件层次结构，起初显示最顶层的目录和文件，当我们进入一个文件夹之 后显示该目录下的子项目。同样在切换 buffer 的时候，有了 ido 可以直观的看到有哪些 buffer，在你输入想要切换的 buffer 名称的时候 ido 也同时帮你进行筛选。此外 ido 本 身有记忆功能，可以让你快速的定位到上一次打开的文件夹。 ido 使得查找文件和切换 buffer 的任务变得异常的轻松，smex 则使得输入 Emacs 命令变 得非常便捷。smex 提供一个非常类似于 ido 的界面。在你输入命令的时候直观的给出后选 项，在输入的同时不断的筛选，同时也记录你最近使用过的命令，使得你可以很方便的输入 命令（其实大于大多数人来说，常用的命令也就那么几条，有了 smex，基本上不用输入多 少个字符就可以找到你想要的命令，因为它有记忆功能）。 纯文本编辑利器 —— orgorg mode 的强大并不是三言两语可以说清楚，它的官方文档就有好几百页。我本人并不是 很熟练的掌握它这里也不做过多的介绍，有兴趣的可以去看看它的官方网站，上面有官方文 档。 org 主要可以用来编写文档，它可以提供层次化的结构，使得你写作的时候可以条理清晰， 此外 org mode 实现了 GTD （好像是 Get Things Done 的缩写），它可以让你列出自己的 计划，给出你的完成时间，计划时间，提供一份日程表，让你对自己的生活进行很好的规划 。它还可以很方便的插入表格，转换成各种文件格式。也有专门用来写博客的 org2blog 插 件让你可以通过 Emacs 的 org 模式编写博客。 我对 org 并不是很熟，在这里只是简单的介绍和推荐，如果你想要更升入的了解它的功能 可以去看它的官方文档。 其他插件其他还有一些插件也很给力，比如 auto-complete-clang 可以在 auto-complete 的基础上 ，通过 clang 作为后端提供库函数的补全。ECB（Emacs Code Browser），可以让你像使用 IDE 一样使用 Emacs，它提供了文件的各种视图。你可以查看项目的目录结构、目录下的源 文件、源文件中的函数列表等等。 这些插件虽然很强大，但是会让 Emacs 变的很慢，一定意义上来说反而降低了 Emacs 的效 率，所以这里不做过多的介绍，如果你有兴趣，可以去它们的官网上查看具体的使用方式。 单个语言的特殊配置和GUI的特殊配置前面的配置都是一些通用的配置，并不限于某个语言。下面的配置则更多的是对于单个语言 的特殊配置。 c、cpp 插件配置行字符数限制 —— fill-colum-indicatorc、cpp 的一个编程规范就是每一行的字符不要超过 80 个字节，而我们在编程的时候不可 能去记住没一行目前有多少字节，我们需要一个直观的提示，这也就是 fill-colum-indicator 的作用。它会在屏幕的右边规定个字节的地方给出一条竖线，使得 你可以很直观的看到自己的代码是否超过了这个界限。你可以设置它指示的位置，颜色和竖 线的宽度。 1234(setq fci-rule-column 80) ;; 80 个字节处画竖线(setq fci-rule-color "orange") ;; 竖线为黄色(setq fci-rule-width 2) ;; 竖线宽度为 2 个像素(fci-mode 1) ;; 开启 fci 模式 代码跳转 —— gtags在编写或者阅读较大型的项目的时候，我们通常希望可以在函数的定义和实现中进行跳转， 这个功能大部分 IDE 都有提供Emacs 也可以实现它。Emacs 中实现代码跳转的方式很多， 比如 etags、cscope 等等，我个人比较习惯的使用的是gtags，它以 GNU GLOBAL 为依托， 所以在使用 gtags 之前你必须先安装 global。在官网的的源码包里有 gtags.el 这个插件 （在 MELPA 中有一个 ggtags 是 gtags 插件的扩展，个人觉得还不如这个原生的好用）， 如果你编译安装 global，那么在 /usr/local/share/ 目录下面会有 gtags.el 这个文件， 你可以把这个目录加到你的 load-path 中去，也可以自己建立一个文件夹（比如： ~/.emacs.d/plugins/），把源码包中的 gtags.el 放到该文件夹下之后把你建立的文件夹 添加到 load-path 中。 12(setq load-path (cons "~/.emacs.d/plugins/" load-path))(autoload 'gtags-mode "gtags" "" t) 目前我用它来阅读 Linux Kernel 的代码，个人感觉还是非常好用的，所以推荐给大家。 方便而美观的代码注释 —— doxymacsEmacs 本身的注释功能已经非常强大了，比如使用 M-; 可以插入注释，在注释里面使用 M-j 可以形成多行注释。如果你想要一个更加强大的注释插件，那么可以使用 doxymacs， 它可以用来插入整个文档的注释，函数的的注释，多行注释，单行注释等等。它还可以进行 注释的语法高亮，非常的好用。 不过 doxymacs 也需要编译安装，在 package 里面没办法直接安装这个插件。编译安装 doxymacs 相对来说复杂一些。具体的方式可以参考官方文档的。 自定义函数为了让上面这些配置只对 c、cpp 有效，我们可以定义一个函数，在函数里面写入我们的配 置，然后把这个函数挂到 c 和 cpp 的 mode 上面： 12345678910111213141516171819202122232425262728(defun my-c-mode-hook()"This is the function of c mode hook";; set fci-mode argument(setq fci-rule-column 80)(setq fci-rule-color "orange")(setq fci-rule-width 2)(fci-mode 1);; gtags mode and doxymacs(setq load-path (cons "~/.emacs.d/plugins/" load-path))(autoload 'gtags-mode "gtags" "" t);; open gtags mode(gtags-mode 1);; doxymacs mode(doxymacs-mode 1);; 回车换行自动缩进(setq-default indent-tabs-mode nil)(global-set-key (kbd "RET") 'newline-and-indent);; 缩进风格设置(setq c-default-style '((java-mode . "java") (awk-mode . "awk") (other . "linux")))) 函数定义好了之后，通过 hook 把它挂到 c-common-hook 上面。 1(add-hook 'c-mode-common-hook 'my-c-mode-hook) Python 插件配置Python 的配置除了前面提到的 fill-colum-indicator 之外（Python 一般要求每行不超过 79 个字符，而 c、cpp 则一般是 80 个字符，所以虽然这个插件通用，我还是分开写它们 的配置）我只推荐一个插件——jedi。这个插件功能非常的强大，它可以用来实现 代码补全，代码跳转， docstring 的查看等等。 jdei 的安装相对要麻烦一下，主要分为一下几个步骤： 安装相关依赖，包括 virtual、epc、jedi 123sudo pip install virtualenvsudo pip install epcsudo pip install jedi 用 package 安装 jdei 插件(package 在安装这个插件的同时会安装它依赖的的插件) 在 Emacs 中执行命令 jedi:install-server 安装完成之后可以通过以下配置开启 jedi: 123;; setup jedi(jedi:setup)(setq jedi:complete-on-dot t) 同样的，你可以定义一个方法把上面的配置写到函数中，然后通过 hook 挂到 python mode 中。 jedi 的具体使用方式，请查考它的官方文档 下面是一些基本的快捷键： 1234567891011;; &lt;C-tab&gt; jedi:complete;; Complete code at point.;; C-c ? jedi:show-doc;; Show the documentation of the object at point.;; C-c . jedi:goto-definition;; Goto the definition of the object at point.;; C-c , jedi:goto-definition-pop-marker;; Goto the last point where jedi:goto-definition was called. jedi 在 python 3 下好像并不能很好的工作，建议使用 Python 2 来配置它。（我在 Arch 下配置的时候因为它以 Python3 作为默认的 Python 版本配置没有成功，把默认改成 Python2 之后可以正常工作）。 GUI 特殊配置Emacs 中还有一些配置只有在使用 x-window 的时候才有效，比如设置字体，使用 powerline 和系统共享剪贴板等等。 为此我专门为 x-window 配置定义了一个函数，当使用 x-window 的时候执行该函数，以配 置 GUI 特殊功能。 123456(defun x-window-config() (powerline-center-evil-theme) (setq x-select-enable-clipboard 1) (set-default-font "Courier 10 Pitch"))(if window-system (x-window-config)) 按键绑定按键绑定之所以放在最后面是因为按键的绑定可能涉及到前面提到的插件，在所有的插件都 配置完成之后设置按键绑定可以清晰明了，也防止冲突，这里的按键绑定主要是 f1-f12 的 绑定，具体绑定如下，你也可以绑定其他的按键： 1234567891011121314151617181920;; 设置 f1 打开帮助文档(global-set-key [f1] 'info);; 设置 f2 为 yas 扩展快捷键(define-key yas-minor-mode-map (kbd "&lt;f2&gt;") 'yas-expand);; 设置 f3 关闭当前buffer(global-set-key [f3] 'kill-this-buffer);; 设置 f4 打开 eshell(global-set-key [f4] 'eshell);; 设置 f10 为查找符号的引用(global-set-key [f10] 'gtags-find-rtag);; 设置 f11 为查找符号的定义(global-set-key [f11] 'gtags-find-tag);; 设置 f12 返回原来的位置(global-set-key [f12] 'gtags-pop-stack) 其中 f1 是默认的绑定，f2 作为 yasnippt 的扩展键，f3 用来关闭当前 buffer（Emacs 的C-x k 是默认的关闭 buffer 按键）。f10 到 f12 是专门绑定到 gtags 插件的相关函数 上的，这样可以使得 gtags 的使用非常便捷。 我把 f4 绑定为打开 eshell。Emacs 本身支持 shell 和 eshell，其中前者的使用并不是 很方便，比如你想要执行上一条命令你需要使用 M-p，而不能使用上箭头（同样下一条命令 需要用 M-n），而后者方便很多。eshell 是用 Emacs lisp 写的，所以和 Emacs 的融合比 较好，不存在上面的问题。此外因为它是 Emacs lisp 语言编写的，你可以在 eshell 中执 行 Emacs 命令，不过应该很少会有人这么干，因为 smex 已经足够强大了。 完]]></content>
      <tags>
        <tag>Emacs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 中断、抢占、锁之间的关系]]></title>
    <url>%2F2014%2F09%2F06%2Flinux-interrupt-preemptive-lock%2F</url>
    <content type="text"><![CDATA[抢占（preempt）现代操作系统为了提高资源的利用率一般都支持多任务（这里不想纠结进程、线程、内核线 程之间的关系所以使用任务一词），但是因为系统资源有限，系统中同一时间点能够运行的 任务是有限的（单核的话只有一个，多核可能有多个）。为了解决这个冲突，操作系统不得 不在任务之间不断的切换，让一些任务运行一段时间之后睡眠，然后从原来处于睡眠状态的 任务中选出一些来继续运行。这种从一个运行的任务切换到另一个运行的任务的行为叫做任 务切换，而任务切换是通过调度来完成的。 调度又分为两种调度：抢占式的调度和非抢占式的调度。在非抢占式的调度中，任务之间通 过协调来决定哪一个任务将会在下一刻运行，而在抢占式的调度中这一决策由调度器来完成 。调度器这种暂时停止一个任务的运行从而让另一个任务运行的行为就称为抢占。Linux 使 用的就是抢占式调度。 抢占一般又分为用户抢占和内核抢占。用户抢占：是指的内核在返回用户空间时做出的抢占 决定，它可能发生在一下两种情况下： 内核从一个系统调用中返回用户空间（也就是说一个进程调用了一个系统调用从而陷入内 核空间，当内核完成了这个系统调用之后返回用户空间）。 内核从一个中断处理器中返回用户空间（也就是说一个进程在正常执行中内核收到中断信 号转而执行中断处理器，中断处理器完成任务之后返回用户空间继续原来的进程执行） 内核抢占：是指在内核代码的执行过程中发生的抢占。通常在执行内核代码时必须等待内核 代码执行完成之后才能进行下一次调度（也就是上面的用户抢占的两种情况），也就是说调 度器无法在任务还处于内核中的时候对它进行抢占。Linux 实现了的内核抢占使得内核代码 的执行也可以被抢占，条件是当前任务没有持有锁。这是通过在每一个进程的 thread_info 中加入 preempt_count 计数器来实现的，如果这个计数器为 0 表示可以 抢占，否则就不行。以下四中情况下可能会发生内核抢占： 中断处理器结束并返回内核空间之前（也就是说内核代码正在执行的时候被中断） 内核再次变成可以抢占的时候（内核是否可以抢占需要依赖 preempt_count 如果它从 非零变成零也就是再次变为可抢占） 内核代码显式调用 schedule() 函数（如果内核代码显式调用该函数表明内核代码确定 目前可以抢占，否则就是代码的 BUG 了） 任务在内核中阻塞（这也会导致 schedule() 被调用） 中断（interrupt）内核需要管理硬件资源，也就是说需要和硬件之间有通信方式存在。考虑到处理器一般速度 比硬件快上好几个级别，让内核发送请求而等待硬件的响应显然是不可取的。我们需要一种 方式使得硬件能够通知内核，让内核响应硬件的请求。 方式之一是通过“轮询”定期的检查硬件的状态从而进行响应，显然这种方式的开销太大。另 一种更为合理的方式是提供一种机制，让硬件在需要和内核通信的时候给内核发送信号，这 种机制就是“中断”。而当内核收到信号之后去处理信号的代码叫做“中断处理器”（注意不要 混淆中断处理器还中断控制器，前者是内核函数属于软件范畴，而后者是一个芯片是硬件范 畴）。 很显然中断在任何时刻都可能会发生，因为这是一种异步的通信方式，内核无法控制硬件在 什么时候会去发送信号给它（比如说内核它永远不可能知道你下一次敲击键盘是什么时候） 。 中断和抢占的关系关于中断和抢占之间的关系，在《Linux Kernel Development (Third Edition)》的P127页 中断控制的第二段中，作者提到了这样一句话： Moreover, disabling interrupts also disbles kernel preemption. 也就是说其实中断和抢占有着比较密切的联系，我并不能完全理解这句话的意义。其中最后 一个词语 kernel preemption 指的是否仅仅是内核抢占还是包括用户抢占不得而知（从字 面上说应该是单独指的内核抢占）。 在 stack overflow 中有很多人提这个问题，各种解释众说纷纭不过有一点可以肯定的是， 中断处理器结束运行之后无论是返回用户空间（用户抢占）还是返回内核空间（内核抢占） 都有可能会发生调度从而出现抢占，这点在前面关于抢占的讨论中有提到过。从这个角度理 解，阻止了中断至少不会出现从中断处理器中返回而导致的抢占。 （关于这段话如果大家有更好的解释欢迎补充，我目前还没有系统的读内核代码，所以没有 看到他们之间的直接联系） 另外中断处理是在一个特殊的上下文（context）中断上下文中完成的，在这个上下文中中 断处理器无法阻塞也不能睡眠，因为它本身没有一个进程在背后支撑，所以它是不可调度的 。也就是说中断处理器是无法抢占的。但是中断处理器还是有可能被其他的中断处理器中断 的，因为中断可能发生在任何的时候，如果出现了更高优先级的中断，那么很可能当前中断 处理器的处理再次被中断。 抢占和锁的关系抢占中的内核抢占可以发生的条件是任务不能持有锁，也就是说 preempt_count 必须是为 零，所以说加锁可以阻止内核抢占。 Linux 内核提供了阻止内核抢占的 API – preempt_disable() 和 preempty_enable() 。这两个函数其实是通过控制 preempt_count 来达到效果的。下面是 preempt_disble() 的定义： 12345#define preempt_disable() \do &#123; \ preempt_count_inc(); \ barrier(); \&#125; while (0) 从代码中我们可以明显的看到它直接调用的就是增加 preemptc_count 的值的另一个例程 （routine，这里用 routine 是因为它本身还是一个宏定义，而这个宏定义的最终扩展 会调用一个函数，我不想去区分宏定义和函数在这里的差别，所以使用了 routine 而不 是 function），从而达到了阻止内核抢占的效果。 所以说锁和内核抢占有直接的联系，因为持有锁的任务不能进行内核抢占。LKD 中我目前没 有看到关于锁和用户抢断之间的联系这里不妄下定论。 中断和锁的关系中断和锁理论上说应该没有直接的联系，但是在实践中有较大的瓜葛。在同步处理中，锁是 起着非常关键的作用，而当加锁和中断联系在一起的时候问题就变得非常有趣了。 因为中断随时可能发生，所以很有可能会出现以下这种情况：当一个任务正在执行的时候被 中断的到来打断了。一般情况下这并没有什么大碍，等待中断处理结束之候原任务可以继续 运行（或者运行其他任务，因为从中断处理返回之后会进行调度）。但是如果涉及到同步问 题处理，事情就变得复杂了。 我们知道为了防止竞争条件的出现，我们需要给共享数据加锁形成临界区。在中断处理器中 同样如此，但是因为中断处理器本身不能被阻塞也不能睡眠所以它能使用的锁就只有自旋锁 （spin lock）。假设任务 A 获得了某个临界区的自旋锁 L 但是还没有退出临界区（也就 是还没有释放这把自旋锁），这个时候它被一个突如其来的中断打断，内核转而执行中断处 理器 B，而这个中断处理器 B 同样需要访问这个临界区，因此它需要先获取自旋锁 L，于 是中断处理器 B 开始自旋因为锁被 A 占有而 A 被 B 打断无法运行也就无法释放自旋锁 L ，更糟糕的是中断处理是无法抢占的所以 B 一直自旋，这就形成了死锁。 因此在实践中使用自旋锁的同时一般会阻止中断的发生，Linux 内核甚至提供了同时完成这 两个步骤的 API – spin_lock_irqsave()、spin_unlock_irqrestore() 等等。阻止中 断可以使得代码不被当前处理器上的中断打断，而加锁可以使得防止其他处理器上的任务同 时处理数据。结合这两者就可以很好的处理同步问题了。 以上内容是我阅读《Linux Kernel Development(Third Edition)》时的一些总结，如果有 错误的地方欢迎大家指正。]]></content>
      <tags>
        <tag>Linux Kernel</tag>
      </tags>
  </entry>
</search>
